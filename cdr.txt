
============================================================
FILE: AppliedTrunkRuleInfo.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/AppliedTrunkRuleInfo.java
SIZE: 0.61 KB
MODIFIED: 2025-06-04 13:40:58
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class AppliedTrunkRuleInfo {
    public BigDecimal rateValue;
    public Boolean includesVat;
    public Integer seconds;
    public Long newTelephonyTypeId;
    public String newTelephonyTypeName;
    public Long newOperatorId;
    public String newOperatorName;
    public BigDecimal vatRate; // VAT from the context of the newTelephonyType and newOperator
}

============================================================
FILE: AssignmentCause.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/AssignmentCause.java
SIZE: 0.77 KB
MODIFIED: 2026-02-25 13:54:32
============================================================
// File: com/infomedia/abacox/telephonypricing/component/cdrprocessing/AssignmentCause.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

// Based on IMDEX_ASIGNA_* constants
public enum AssignmentCause {
    NOT_ASSIGNED(0),      // Default or if no specific cause (PHP defaulted to 0)
    EXTENSION(0),         // IMDEX_ASIGNA_EXT
    AUTH_CODE(1),         // IMDEX_ASIGNA_CLAVE
    IGNORED_AUTH_CODE(2), // IMDEX_IGNORA_CLAVE
    CONFERENCE(4),        // IMDEX_ASIGNA_CONFE
    TRANSFER(5),          // IMDEX_ASIGNA_TRANS
    RANGES(6);            // IMDEX_ASIGNA_RANGOS

    private final Integer value;

    AssignmentCause(Integer value) {
        this.value = value;
    }

    public Integer getValue() {
        return value;
    }
}

============================================================
FILE: CallDirection.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/CallDirection.java
SIZE: 0.29 KB
MODIFIED: 2025-06-04 13:40:58
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

public enum CallDirection {
    OUTGOING(0),
    INCOMING(1);

    private final int value;
    CallDirection(int value) {
        this.value = value;
    }
    public int getValue() {
        return value;
    }
}

============================================================
FILE: CallOriginDeterminationService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/CallOriginDeterminationService.java
SIZE: 11.01 KB
MODIFIED: 2025-08-28 14:36:42
============================================================
// File: com/infomedia/abacox/telephonypricing/component/cdrprocessing/CallOriginDeterminationService.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.CommunicationLocation;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

@Service
@Log4j2
@RequiredArgsConstructor
public class CallOriginDeterminationService {

    private final PrefixLookupService prefixLookupService;
    private final IndicatorLookupService indicatorLookupService;
    private final TelephonyTypeLookupService telephonyTypeLookupService;
    private final OperatorLookupService operatorLookupService;

    /**
     * PHP equivalent: buscarOrigen
     */
    public IncomingCallOriginInfo determineIncomingCallOrigin(String processedExternalCallerId,
                                                              Long hintedTelephonyTypeIdFromTransform,
                                                              CommunicationLocation commLocation) {
        log.debug("Determining incoming call origin for: {}, Hinted Type: {}, CommLocation: {}",
                processedExternalCallerId, hintedTelephonyTypeIdFromTransform, commLocation.getDirectory());
        IncomingCallOriginInfo result = new IncomingCallOriginInfo();
        result.setEffectiveNumber(processedExternalCallerId);
        result.setTelephonyTypeId(TelephonyTypeEnum.LOCAL.getValue()); // PHP default
        result.setTelephonyTypeName(telephonyTypeLookupService.getTelephonyTypeName(result.getTelephonyTypeId()));
        result.setIndicatorId(commLocation.getIndicatorId());
        result.setOperatorId(null);

        if (processedExternalCallerId == null || processedExternalCallerId.isEmpty()) {
            log.debug("External caller ID is empty, cannot determine origin accurately.");
            return result;
        }

        String numberForProcessing = processedExternalCallerId;
        List<String> pbxPrefixes = commLocation.getPbxPrefix() != null ?
                Arrays.asList(commLocation.getPbxPrefix().split(",")) : java.util.Collections.emptyList();

        CleanPhoneNumberResult cleanPhoneNumber = CdrUtil.cleanPhoneNumber(numberForProcessing, pbxPrefixes, false);

        // --- Path A (PHP: if ($maxCaracterAExtraer > 0)) ---
        if (cleanPhoneNumber.isPbxPrefixStripped()) {
            String numberAfterPbxStrip = cleanPhoneNumber.getCleanedNumber();
            log.debug("Path A (PBX prefix stripped): Number for prefix lookup: {}", numberAfterPbxStrip);
            List<PrefixInfo> prefixes = prefixLookupService.findMatchingPrefixes(
                    numberAfterPbxStrip, commLocation, false, null
            );
            for (PrefixInfo pi : prefixes) {
                if (hintedTelephonyTypeIdFromTransform == null || hintedTelephonyTypeIdFromTransform.equals(pi.getTelephonyTypeId())) {
                    Optional<DestinationInfo> destInfoOpt = indicatorLookupService.findDestinationIndicator(
                            numberAfterPbxStrip,
                            pi.getTelephonyTypeId(),
                            pi.getTelephonyTypeMinLength() != null ? pi.getTelephonyTypeMinLength() : 0,
                            commLocation.getIndicatorId(),
                            pi.getPrefixId(),
                            commLocation.getIndicator().getOriginCountryId(),
                            pi.getBandsAssociatedCount() > 0,
                            false,
                            pi.getPrefixCode()
                    );
                    if (destInfoOpt.isPresent() && destInfoOpt.get().getIndicatorId() != null && destInfoOpt.get().getIndicatorId() > 0) {
                        DestinationInfo di = destInfoOpt.get();
                        // The operator is the one from the PrefixInfo (pi) that we are currently testing.
                        result.setOperatorId(pi.getOperatorId());
                        result.setOperatorName(pi.getOperatorName());
                        result.setEffectiveNumber(di.getMatchedPhoneNumber());
                        updateResultFromDestinationInfo(result, di, pi.getTelephonyTypeId(), pi.getTelephonyTypeName(), commLocation);
                        log.debug("Path A match found: {}", result);
                        return result; // Return immediately, mimicking PHP's 'break'
                    }
                    if (hintedTelephonyTypeIdFromTransform != null && hintedTelephonyTypeIdFromTransform.equals(pi.getTelephonyTypeId())) {
                        log.debug("Hinted type {} used in Path A but no destination found. Breaking from Path A prefix loop.", hintedTelephonyTypeIdFromTransform);
                        break;
                    }
                }
            }
        }

        // --- Path B (PHP: if ($arreglo['INDICATIVO_ID'] <= 0)) ---
        log.debug("Path B (No PBX prefix stripped or Path A failed): Number for processing: {}", numberForProcessing);
        List<IncomingTelephonyTypePriority> typePriorities = telephonyTypeLookupService.getIncomingTelephonyTypePriorities(
                commLocation.getIndicator().getOriginCountryId()
        );

        if (hintedTelephonyTypeIdFromTransform != null) {
            log.debug("Path B: Prioritizing hinted telephony type: {}", hintedTelephonyTypeIdFromTransform);
            Optional<IncomingTelephonyTypePriority> hintedTypePriorityOpt = typePriorities.stream()
                    .filter(tp -> tp.getTelephonyTypeId().equals(hintedTelephonyTypeIdFromTransform))
                    .findFirst();

            if (hintedTypePriorityOpt.isPresent()) {
                IncomingTelephonyTypePriority hintedTypePriority = hintedTypePriorityOpt.get();
                int phoneLen = numberForProcessing.length();
                if (phoneLen >= hintedTypePriority.getMinSubscriberLength() && phoneLen <= hintedTypePriority.getMaxSubscriberLength()) {
                    Optional<DestinationInfo> destInfoOpt = indicatorLookupService.findDestinationIndicator(
                            numberForProcessing,
                            hintedTypePriority.getTelephonyTypeId(),
                            hintedTypePriority.getMinSubscriberLength(),
                            commLocation.getIndicatorId(),
                            null,
                            commLocation.getIndicator().getOriginCountryId(),
                            false,
                            true,
                            null
                    );
                    if (destInfoOpt.isPresent() && destInfoOpt.get().getIndicatorId() != null && destInfoOpt.get().getIndicatorId() > 0) {
                        DestinationInfo di = destInfoOpt.get();
                        setOperatorForIncomingPathB(result, hintedTypePriority.getTelephonyTypeId(), di, commLocation);
                        result.setEffectiveNumber(di.getMatchedPhoneNumber());
                        updateResultFromDestinationInfo(result, di, hintedTypePriority.getTelephonyTypeId(), hintedTypePriority.getTelephonyTypeName(), commLocation);
                        log.debug("Path B match found using HINTED type {}: {}", hintedTelephonyTypeIdFromTransform, result);
                        return result;
                    }
                }
            }
        }

        for (IncomingTelephonyTypePriority typePriority : typePriorities) {
            if (hintedTelephonyTypeIdFromTransform != null && typePriority.getTelephonyTypeId().equals(hintedTelephonyTypeIdFromTransform)) {
                continue;
            }

            int phoneLen = numberForProcessing.length();
            if (phoneLen >= typePriority.getMinSubscriberLength() && phoneLen <= typePriority.getMaxSubscriberLength()) {
                Optional<DestinationInfo> destInfoOpt = indicatorLookupService.findDestinationIndicator(
                        numberForProcessing,
                        typePriority.getTelephonyTypeId(),
                        typePriority.getMinSubscriberLength(),
                        commLocation.getIndicatorId(),
                        null,
                        commLocation.getIndicator().getOriginCountryId(),
                        false,
                        true,
                        null
                );
                if (destInfoOpt.isPresent() && destInfoOpt.get().getIndicatorId() != null && destInfoOpt.get().getIndicatorId() > 0) {
                    DestinationInfo di = destInfoOpt.get();
                    setOperatorForIncomingPathB(result, typePriority.getTelephonyTypeId(), di, commLocation);
                    result.setEffectiveNumber(di.getMatchedPhoneNumber());
                    updateResultFromDestinationInfo(result, di, typePriority.getTelephonyTypeId(), typePriority.getTelephonyTypeName(), commLocation);
                    log.debug("Path B match found: {}", result);
                    return result; // Return immediately, mimicking PHP's 'break 2'
                }
            }
        }
        log.debug("No definitive origin found for incoming call '{}'. Returning defaults.", processedExternalCallerId);
        return result;
    }

    private void setOperatorForIncomingPathB(IncomingCallOriginInfo result, Long telephonyTypeId, DestinationInfo di, CommunicationLocation commLocation) {
        if (telephonyTypeId.equals(TelephonyTypeEnum.CELLULAR.getValue())) {
            operatorLookupService.findOperatorForIncomingCellularByIndicatorBands(di.getIndicatorId())
                .ifPresent(opInfo -> {
                    result.setOperatorId(opInfo.getId());
                    result.setOperatorName(opInfo.getName());
                });
        }
    }

    private void updateResultFromDestinationInfo(IncomingCallOriginInfo result, DestinationInfo di,
                                                 Long matchedTelephonyTypeId, String matchedTelephonyTypeName,
                                                 CommunicationLocation commLocation) {
        result.setIndicatorId(di.getIndicatorId());
        result.setDestinationDescription(di.getDestinationDescription());

        if (Objects.equals(result.getIndicatorId(), commLocation.getIndicatorId())) {
            result.setTelephonyTypeId(TelephonyTypeEnum.LOCAL.getValue());
            result.setTelephonyTypeName(telephonyTypeLookupService.getTelephonyTypeName(TelephonyTypeEnum.LOCAL.getValue()));
        } else if (indicatorLookupService.isLocalExtended(di.getNdc(), commLocation.getIndicatorId(), di.getIndicatorId())) {
            result.setTelephonyTypeId(TelephonyTypeEnum.LOCAL_EXTENDED.getValue());
            result.setTelephonyTypeName(telephonyTypeLookupService.getTelephonyTypeName(TelephonyTypeEnum.LOCAL_EXTENDED.getValue()));
        } else {
            result.setTelephonyTypeId(matchedTelephonyTypeId);
            result.setTelephonyTypeName(matchedTelephonyTypeName);
        }
    }
}

============================================================
FILE: CallRecordPersistenceService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/CallRecordPersistenceService.java
SIZE: 7.8 KB
MODIFIED: 2026-02-25 12:05:34
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.CallRecord;
import com.infomedia.abacox.telephonypricing.db.entity.CommunicationLocation;
import jakarta.persistence.EntityManager;
import jakarta.persistence.NoResultException;
import jakarta.persistence.PersistenceContext;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.hibernate.exception.ConstraintViolationException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.support.TransactionTemplate;

import java.time.LocalDateTime;
import java.util.*;

@Service
@Log4j2
@RequiredArgsConstructor
public class CallRecordPersistenceService {

    @PersistenceContext
    private EntityManager entityManager;
    private final CdrConfigService cdrConfigService;
    
    // Inject the Transaction Manager
    private final PlatformTransactionManager transactionManager;

    /**
     * Batch lookup for duplicate checking.
     * Efficiently checks if a list of hashes exists in the DB using a single query.
     */
    @Transactional(readOnly = true)
    public Set<UUID> findExistingHashes(List<UUID> hashes) { // Changed List<Long> to List<UUID>
        if (hashes == null || hashes.isEmpty()) return Collections.emptySet();

        List<UUID> found = entityManager.createQuery(
                        "SELECT cr.ctlHash FROM CallRecord cr WHERE cr.ctlHash IN :hashes", UUID.class) // Changed Long.class to UUID.class
                .setParameter("hashes", hashes)
                .getResultList();

        return new HashSet<>(found);
    }

    /**
     * Creates a CallRecord entity in memory from the DTO.
     * Does NOT persist to DB. Used by the BatchWorker.
     */
    public CallRecord createEntityFromDto(CdrData cdrData, CommunicationLocation commLocation) {
        CallRecord callRecord = new CallRecord();
        mapCdrDataToCallRecord(cdrData, callRecord, commLocation);
        return callRecord;
    }

    /**
     * Synchronous persistence method.
     * Used ONLY for Admin Reprocessing or specific synchronous flows.
     * Performs inline duplicate check and inline compression.
     * 
     * Concurrency Safety:
     * Uses TransactionTemplate with REQUIRES_NEW to isolate the insert attempt.
     */
    public CallRecord saveOrUpdateCallRecord(CdrData cdrData, CommunicationLocation commLocation) {
        if (cdrData.isMarkedForQuarantine()) {
            return null;
        }

        UUID cdrHash = cdrData.getCtlHash(); // Changed Long to UUID

        TransactionTemplate txTemplate = new TransactionTemplate(transactionManager);
        txTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);

        try {
            return txTemplate.execute(status -> {
                // 1. Quick duplicate check
                List<Long> existingIds = entityManager.createQuery("SELECT cr.id FROM CallRecord cr WHERE cr.ctlHash = :hash", Long.class)
                        .setParameter("hash", cdrHash)
                        .getResultList();

                if (!existingIds.isEmpty()) {
                    log.debug("Duplicate CDR detected during sync save. Hash: {}", cdrHash);
                    return entityManager.find(CallRecord.class, existingIds.get(0));
                }

                CallRecord callRecord = createEntityFromDto(cdrData, commLocation);
                entityManager.persist(callRecord);
                entityManager.flush();

                return callRecord;
            });

        } catch (Exception e) {
            if (isDuplicateKeyException(e)) {
                log.debug("Race condition detected for CallRecord hash {}. Fetching existing.", cdrHash);
                return txTemplate.execute(retryStatus -> findByCtlHash(cdrHash));
            } else {
                log.error("Database error while saving CallRecord during sync process: {}", e.getMessage());
                return null;
            }
        }
    }

    @Transactional(readOnly = true)
    public CallRecord findByCtlHash(UUID ctlHash) { // Changed Long to UUID
        try {
            return entityManager.createQuery("SELECT cr FROM CallRecord cr WHERE cr.ctlHash = :hash", CallRecord.class)
                    .setParameter("hash", ctlHash)
                    .getSingleResult();
        } catch (NoResultException e) {
            return null;
        }
    }

    @Transactional
    public int deleteByFileInfoId(Long fileInfoId) {
        if (fileInfoId == null) return 0;
        int deletedCount = entityManager.createQuery("DELETE FROM CallRecord cr WHERE cr.fileInfoId = :fileInfoId")
                .setParameter("fileInfoId", fileInfoId)
                .executeUpdate();
        log.debug("Deleted {} CallRecord(s) for FileInfo ID: {}", deletedCount, fileInfoId);
        return deletedCount;
    }

    /**
     * Maps fields from CdrData DTO to CallRecord Entity.
     */
    public void mapCdrDataToCallRecord(CdrData cdrData, CallRecord callRecord, CommunicationLocation commLocation) {

        callRecord.setDial(truncate(cdrData.getEffectiveDestinationNumber(), 50));
        callRecord.setDestinationPhone(truncate(cdrData.getOriginalFinalCalledPartyNumber(), 50));
        callRecord.setCommLocationId(commLocation.getId());
        callRecord.setServiceDate(cdrData.getDateTimeOrigination());
        callRecord.setOperatorId(cdrData.getOperatorId());
        callRecord.setEmployeeExtension(truncate(cdrData.getCallingPartyNumber(), 50));
        callRecord.setEmployeeAuthCode(truncate(cdrData.getAuthCodeDescription(), 50));
        callRecord.setIndicatorId(cdrData.getIndicatorId());
        callRecord.setDuration(cdrData.getDurationSeconds());
        callRecord.setRingCount(cdrData.getRingingTimeSeconds());
        callRecord.setTelephonyTypeId(cdrData.getTelephonyTypeId());
        callRecord.setBilledAmount(cdrData.getBilledAmount());
        callRecord.setPricePerMinute(cdrData.getPricePerMinute());
        callRecord.setInitialPrice(cdrData.getInitialPricePerMinute());
        callRecord.setIsIncoming(cdrData.getCallDirection() == CallDirection.INCOMING);
        callRecord.setTrunk(truncate(cdrData.getDestDeviceName(), 50));
        callRecord.setInitialTrunk(truncate(cdrData.getOrigDeviceName(), 50));
        callRecord.setEmployeeId(cdrData.getEmployeeId());
        callRecord.setEmployeeTransfer(truncate(cdrData.getEmployeeTransferExtension(), 50));
        
        if (cdrData.getTransferCause() != null) callRecord.setTransferCause(cdrData.getTransferCause().getValue());
        if (cdrData.getAssignmentCause() != null) callRecord.setAssignmentCause(cdrData.getAssignmentCause().getValue());
        
        callRecord.setDestinationEmployeeId(cdrData.getDestinationEmployeeId());
        
        if (cdrData.getFileInfo() != null) {
            callRecord.setFileInfoId(cdrData.getFileInfo().getId());
        }

        callRecord.setCtlHash(cdrData.getCtlHash());
    }

    private boolean isDuplicateKeyException(Exception e) {
        Throwable cause = e;
        while (cause != null) {
            if (cause instanceof ConstraintViolationException || 
                (cause.getMessage() != null && cause.getMessage().toLowerCase().contains("duplicate key"))) {
                return true;
            }
            cause = cause.getCause();
        }
        return false;
    }

    private String truncate(String input, int limit) {
        if (input == null) return "";
        return input.length() > limit ? input.substring(0, limit) : input;
    }
}

============================================================
FILE: CallTypeAndDirectionService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/CallTypeAndDirectionService.java
SIZE: 6.61 KB
MODIFIED: 2026-02-24 23:46:58
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.CommunicationLocation;
import com.infomedia.abacox.telephonypricing.db.entity.Employee;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service
@Log4j2
@RequiredArgsConstructor
public class CallTypeAndDirectionService {

    private final IncomingCallProcessorService incomingCallProcessorService;
    private final OutgoingCallProcessorService outgoingCallProcessorService;
    private final InternalCallProcessorService internalCallProcessorService;
    private final EmployeeLookupService employeeLookupService;
    private final PbxSpecialRuleLookupService pbxSpecialRuleLookupService;

    /**
     * PHP equivalent: Orchestrates logic from CargarCDR's main loop after
     * `evaluar_Formato`,
     * leading into `procesaEntrante` or `procesaSaliente`.
     * This method determines the initial nature of the call and then delegates.
     */
    public void processCall(CdrData cdrData, LineProcessingContext processingContext) {
        log.debug("Processing call for CDR: {}", cdrData.getCtlHash());

        // Store the initial direction determined by the parser
        CallDirection initialDirection = cdrData.getCallDirection();

        // Initial determination of internal call (PHP: es_llamada_interna)
        if (!cdrData.isInternalCall()) {
            checkIfPotentiallyInternal(cdrData, processingContext);
        }
        log.debug("Initial call attributes - Direction: {}, Internal: {}", initialDirection, cdrData.isInternalCall());

        cdrData.setEffectiveDestinationNumber(cdrData.getFinalCalledPartyNumber());

        // An incoming call that is found to be internal must be processed as internal,
        // not as incoming.
        if (cdrData.isInternalCall()) {
            // PHP: procesaEntrante -> info_interna -> InvertirLlamada
            if (initialDirection == CallDirection.INCOMING) {
                log.debug("Re-classifying INCOMING call as INTERNAL for processing. CDR: {}", cdrData.getCtlHash());
                CdrUtil.swapFull(cdrData, true); // Full swap including trunks
                cdrData.setCallDirection(CallDirection.OUTGOING); // It's now treated as an outgoing internal call
            }
            internalCallProcessorService.processInternal(cdrData, processingContext, false);
        } else if (initialDirection == CallDirection.INCOMING) {
            incomingCallProcessorService.processIncoming(cdrData, processingContext);
        } else { // OUTGOING
            outgoingCallProcessorService.processOutgoing(cdrData, processingContext, false);
        }

        log.debug("Finished processing call. Final Direction: {}, Internal: {}, TelephonyType: {}",
                cdrData.getCallDirection(), cdrData.isInternalCall(), cdrData.getTelephonyTypeId());
    }

    /**
     * Logic adapted from PHP's `es_llamada_interna`
     * This is called if the parser (like Cisco CM 6.0) hasn't already definitively
     * marked the call as internal.
     */
    private void checkIfPotentiallyInternal(CdrData cdrData, LineProcessingContext lineProcessingContext) {
        log.debug("Checking if call is potentially internal. Calling: '{}', FinalCalled: '{}'",
                cdrData.getCallingPartyNumber(), cdrData.getFinalCalledPartyNumber());
        ExtensionLimits limits = lineProcessingContext.getCommLocationExtensionLimits();
        CommunicationLocation commLocation = lineProcessingContext.getCommLocation();

        if (CdrUtil.isPossibleExtension(cdrData.getCallingPartyNumber(), limits)) {
            log.debug("Calling party '{}' is a possible extension. Checking destination for internal call.",
                    cdrData.getCallingPartyNumber());
            String destinationForInternalCheck = CdrUtil
                    .cleanPhoneNumber(cdrData.getFinalCalledPartyNumber(), null, false).getCleanedNumber();
            log.debug("Cleaned destination for internal check: {}", destinationForInternalCheck);

            Optional<String> pbxInternalTransformed = pbxSpecialRuleLookupService.applyPbxSpecialRule(
                    destinationForInternalCheck, commLocation.getDirectory(), PbxRuleDirection.INTERNAL.getValue());
            if (pbxInternalTransformed.isPresent()) {
                destinationForInternalCheck = pbxInternalTransformed.get();
                cdrData.setInternalCheckPbxTransformedDest(destinationForInternalCheck);
                log.debug("Destination transformed by PBX internal rule: {}", destinationForInternalCheck);
            }

            if ((destinationForInternalCheck.length() == 1 && destinationForInternalCheck.matches("\\d")) ||
                    CdrUtil.isPossibleExtension(destinationForInternalCheck, limits)) {
                cdrData.setInternalCall(true);
                log.debug("Marked as internal call based on destination '{}' format/possibility.",
                        destinationForInternalCheck);
            } else if (destinationForInternalCheck.matches("\\d+") &&
                    (!destinationForInternalCheck.startsWith("0") || destinationForInternalCheck.equals("0")) &&
                    !destinationForInternalCheck.isEmpty()) {
                log.debug("Destination '{}' is numeric, not starting with 0 (or is '0'). Checking extension ranges.",
                        destinationForInternalCheck);
                Optional<Employee> employeeFromRange = employeeLookupService.findEmployeeByExtensionRange(
                        destinationForInternalCheck,
                        null, lineProcessingContext.getExtensionRanges(),
                        cdrData.getDateTimeOrigination(), lineProcessingContext.getHistoricalData());
                if (employeeFromRange.isPresent()) {
                    cdrData.setInternalCall(true);
                    log.debug("Marked as internal call based on destination '{}' matching an extension range.",
                            destinationForInternalCheck);
                } else {
                    log.debug("Destination '{}' did not match any extension range.", destinationForInternalCheck);
                }
            } else {
                log.debug("Destination '{}' not identified as internal by format or range.",
                        destinationForInternalCheck);
            }
        } else {
            log.debug("Calling party '{}' is not a possible extension. Not an internal call.",
                    cdrData.getCallingPartyNumber());
        }
    }
}

============================================================
FILE: CdrConfigService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/CdrConfigService.java
SIZE: 5.49 KB
MODIFIED: 2026-02-25 12:10:50
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.component.configmanager.ConfigKey;
import com.infomedia.abacox.telephonypricing.component.configmanager.ConfigService;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
@Log4j2
@RequiredArgsConstructor
public class CdrConfigService {

    private final ConfigService configService;

    @Value("${app.cdr.processing.enabled:true}")
    private boolean cdrProcessingEnabledProperty;

    // --- Constants based on PHP defines ---
    // Original PHP: define('_ACUMTOTAL_MAXEXT', 1000000);
    public static final int MAX_EXTENSION_LENGTH_FOR_INTERNAL_CHECK = 1000000;
    // Original PHP: define('_IMDEX_MAXLINEAS', 500);
    public static final int CDR_PROCESSING_BATCH_SIZE = 500;
    // Original PHP: Hardcoded value 0 for internal operator lookups
    public static final Long DEFAULT_OPERATOR_ID_FOR_INTERNAL = null;

    public boolean isSpecialValueTariffingEnabled() {
        // Original PHP: $usar_valorespecial = ValidarUso($link, 'valorespecial');
        return configService.getValue(ConfigKey.SPECIAL_VALUE_TARIFFING).asBoolean();
    }

    public int getMinCallDurationForTariffing() {
        // Original PHP: $min_tiempo = defineParamCliente('CAPTURAS_TIEMPOCERO', $link);
        int val = configService.getValue(ConfigKey.MIN_CALL_DURATION_FOR_TARIFFING).asInteger();
        return Math.max(0, val);
    }

    public int getMaxCallDurationSeconds() {
        // Original PHP: $max_tiempo = defineParamCliente('CAPTURAS_TIEMPOMAX', $link);
        // (in minutes)
        int maxMinutes = configService.getValue(ConfigKey.MAX_CALL_DURATION_MINUTES).asInteger();
        return maxMinutes * 60; // Convert minutes to seconds
    }

    public String getMinAllowedCaptureDate() {
        // Original PHP: $fechamin = defineParamCliente('CAPTURAS_FECHAMIN', $link);
        return configService.getValue(ConfigKey.MIN_ALLOWED_CAPTURE_DATE).asString();
    }

    public int getMaxAllowedCaptureDateDaysInFuture() {
        // Original PHP: $dias_add = defineParamCliente('CAPTURAS_FECHAMAX', $link);
        int val = configService.getValue(ConfigKey.MAX_ALLOWED_CAPTURE_DATE_DAYS_IN_FUTURE).asInteger();
        return Math.max(0, val);
    }

    public boolean createEmployeesAutomaticallyFromRange() {
        // Original PHP: $auto_fun = ObtenerGlobales($link, 'auto_fun');
        return configService.getValue(ConfigKey.CREATE_EMPLOYEES_AUTOMATICALLY_FROM_RANGE).asBoolean();
    }

    public Long getDefaultTelephonyTypeForUnresolvedInternalCalls() {
        // Original PHP: $interna_defecto = defineParamCliente('CAPTURAS_INTERNADEF',
        // $link);
        String valStr = configService.getValue(ConfigKey.DEFAULT_UNRESOLVED_INTERNAL_CALL_TYPE_ID).asString();
        try {
            long val = Long.parseLong(valStr);
            return val > 0 ? val : null;
        } catch (NumberFormatException e) {
            log.debug("NFE for DEFAULT_TELEPHONY_TYPE_FOR_UNRESOLVED_INTERNAL, using default {}",
                    ConfigKey.DEFAULT_UNRESOLVED_INTERNAL_CALL_TYPE_ID.getDefaultValue());
            return Long.parseLong(ConfigKey.DEFAULT_UNRESOLVED_INTERNAL_CALL_TYPE_ID.getDefaultValue());
        }
    }

    public boolean areExtensionsGlobal() {
        // Original PHP: $ext_globales = ObtenerGlobales($link, 'ext_globales');
        return configService.getValue(ConfigKey.EXTENSIONS_GLOBAL).asBoolean();
    }

    public boolean areAuthCodesGlobal() {
        // Original PHP: $claves_globales = ObtenerGlobales($link, 'claves_globales');
        return configService.getValue(ConfigKey.AUTH_CODES_GLOBAL).asBoolean();
    }

    public String getAssumedText() {
        // Original PHP: define('_ASUMIDO', ' (Asumido)');
        return configService.getValue(ConfigKey.ASSUMED_TEXT).asString();
    }

    public String getOriginText() {
        // Original PHP: define('_ORIGEN', 'Origen');
        return configService.getValue(ConfigKey.ORIGIN_TEXT).asString();
    }

    public String getPrefixText() {
        // Original PHP: define('_PREFIJO', 'Prefijo');
        return configService.getValue(ConfigKey.PREFIX_TEXT).asString();
    }

    /**
     * PHP equivalent: _FUNCIONARIO
     * 
     * @return The default prefix for auto-created employee names from ranges.
     */
    public String getEmployeeNamePrefixFromRange() {
        // Original PHP: $prefijo = trim($row["RANGOEXT_PREFIJO"]); if ($prefijo == '')
        // { $prefijo = _FUNCIONARIO; }
        return configService.getValue(ConfigKey.EMPLOYEE_NAME_PREFIX_FROM_RANGE).asString();
    }

    /**
     * PHP equivalent: _NN_VALIDA
     * 
     * @return The placeholder string for an empty but valid partition.
     */
    public String getNoPartitionPlaceholder() {
        // Original PHP: define('_NN_VALIDA', 'NN-VALIDA');
        return configService.getValue(ConfigKey.NO_PARTITION_PLACEHOLDER).asString();
    }

    /**
     * Returns whether CDR processing is fully enabled.
     * Both the application property (app.cdr.processing.enabled) AND the
     * per-tenant DB config key must be true for processing to run.
     */
    public boolean isCdrProcessingEnabled() {
        return cdrProcessingEnabledProperty && configService.getValue(ConfigKey.CDR_PROCESSING_ENABLED).asBoolean();
    }
}

============================================================
FILE: CdrData.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/CdrData.java
SIZE: 4.61 KB
MODIFIED: 2026-02-25 12:06:05
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.component.utils.XXHash128Util;
import com.infomedia.abacox.telephonypricing.db.entity.Employee;
import com.infomedia.abacox.telephonypricing.db.entity.FileInfo;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;
import lombok.extern.log4j.Log4j2;

import java.math.BigDecimal;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.util.UUID;

@Data
@NoArgsConstructor
@Log4j2
public class CdrData {
    // Fields from PHP's $info_arr after parsing
    @ToString.Exclude
    private String rawCdrLine;
    
    private UUID ctlHash;
    private LocalDateTime dateTimeOrigination; 
    private String callingPartyNumber; 
    private String finalCalledPartyNumber; 
    private String originalFinalCalledPartyNumber; 
    private String originalFinalCalledPartyNumberPartition; 

    private Integer durationSeconds; 
    private String authCodeDescription; 
    private CallDirection callDirection = CallDirection.OUTGOING; 
    private Integer ringingTimeSeconds; 

    // Cisco specific fields
    private String callingPartyNumberPartition;
    private String finalCalledPartyNumberPartition; 
    private String originalCalledPartyNumber;
    private String originalCalledPartyNumberPartition;
    private String lastRedirectDn; 
    private String lastRedirectDnPartition; 
    private String originalLastRedirectDn;
    private String destMobileDeviceName; 
    private String finalMobileCalledPartyNumber; 

    private Integer lastRedirectRedirectReason; 
    private String origDeviceName; 
    private String destDeviceName; 
    private String disconnectCauseOrig;
    private String disconnectCauseDest;

    // Video related fields
    private String origVideoCodec;
    private Integer origVideoBandwidth;
    private String origVideoResolution;
    private String destVideoCodec;
    private Integer destVideoBandwidth;
    private String destVideoResolution;

    // Conference/Join related
    private Integer joinOnBehalfOf;
    private Integer destCallTerminationOnBehalfOf;
    private Long destConversationId;
    private Long globalCallIDCallId;
    private String conferenceIdentifierUsed; 

    // Fields populated during enrichment
    private Long employeeId;
    private Employee employee; 
    private Long destinationEmployeeId;
    private Employee destinationEmployee; 
    private AssignmentCause assignmentCause = AssignmentCause.NOT_ASSIGNED;
    private TransferCause transferCause = TransferCause.NONE;
    private String employeeTransferExtension; 

    private Long telephonyTypeId;
    private String telephonyTypeName; 
    private Long operatorId;
    private String operatorName; 
    private Long indicatorId; 
    private String destinationCityName; 
    private String effectiveDestinationNumber; 

    private BigDecimal billedAmount = BigDecimal.ZERO;
    private BigDecimal pricePerMinute = BigDecimal.ZERO;
    private BigDecimal initialPricePerMinute = BigDecimal.ZERO;
    private boolean priceIncludesVat = false;
    private boolean initialPriceIncludesVat = false;
    private BigDecimal vatRate = BigDecimal.ZERO;
    private boolean chargeBySecond = false;

    private boolean isInternalCall = false; 
    private String pbxSpecialRuleAppliedInfo;

    private FileInfo fileInfo;
    private Long commLocationId;

    private boolean markedForQuarantine = false;
    private String quarantineReason;
    private String quarantineStep;

    //Additional Processing Data
    private SpecialServiceInfo specialServiceTariff;
    private boolean normalizedTariffApplied = false;
    private BigDecimal specialRateDiscountPercentage;
    private String internalCheckPbxTransformedDest;
    private String originalCallerIdBeforePbxIncoming;
    private String originalCallerIdBeforeCMETransform;
    private Long hintedTelephonyTypeIdFromTransform;
    private String originalDialNumberBeforeCMETransform;
    private String originalDialNumberBeforePbxOutgoing;
    private String originalDialNumberBeforePbxIncoming;

    public long getDateTimeOriginationEpochSeconds() {
    return dateTimeOrigination != null ? dateTimeOrigination.atZone(ZoneId.systemDefault()).toEpochSecond() : 0;
}

    public void setRawCdrLine(String rawCdrLine) {
        this.rawCdrLine = rawCdrLine;
        // Changed to use XXHash128Util
        this.ctlHash = XXHash128Util.hash(rawCdrLine.getBytes(StandardCharsets.UTF_8));
    }
}

============================================================
FILE: CdrEnrichmentService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/CdrEnrichmentService.java
SIZE: 11.68 KB
MODIFIED: 2026-02-27 10:57:47
============================================================
// File: com/infomedia/abacox/telephonypricing/component/cdrprocessing/CdrEnrichmentService.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.CommunicationLocation;
import com.infomedia.abacox.telephonypricing.db.entity.Employee;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.util.List;
import java.util.Objects;

@Service
@Log4j2
@RequiredArgsConstructor
public class CdrEnrichmentService {

    private final CallTypeAndDirectionService callTypeAndDirectionService;
    private final EmployeeLookupService employeeLookupService;
    private final CdrConfigService appConfigService;
    private final TelephonyTypeLookupService telephonyTypeLookupService; // For default names

    public CdrData enrichCdr(CdrData cdrData, LineProcessingContext processingContext) {
        CommunicationLocation commLocation = processingContext.getCommLocation();
        if (cdrData == null || cdrData.isMarkedForQuarantine()) {
            log.debug("CDR is null or already marked for quarantine. Skipping enrichment. CDR: {}",
                    cdrData != null ? cdrData.getCtlHash() : "NULL");
            return cdrData;
        }
        log.debug("Starting enrichment for CDR: {}", cdrData.getCtlHash());
        cdrData.setCommLocationId(commLocation.getId());

        try {
            // This call now handles the main flow: es_llamada_interna -> procesaEntrante/procesaSaliente
            callTypeAndDirectionService.processCall(cdrData, processingContext);

            // Added support for GLOBAL_EXTENSION_IGNORE
            if (cdrData.isMarkedForQuarantine() &&
                    (QuarantineErrorType.INTERNAL_SELF_CALL.name().equals(cdrData.getQuarantineStep()) ||
                            QuarantineErrorType.INTERNAL_POLICY_IGNORE.name().equals(cdrData.getQuarantineStep()) ||
                            QuarantineErrorType.GLOBAL_EXTENSION_IGNORE.name().equals(cdrData.getQuarantineStep()) ||
                            (cdrData.getQuarantineStep() != null
                                    && cdrData.getQuarantineStep().contains("IgnorePolicy")))) {
                log.debug(
                        "CDR quarantined during call type processing (Self-call/Ignore Policy). Skipping further enrichment. Hash: {}",
                        cdrData.getCtlHash());
                return cdrData;
            }

            // Employee assignment logic
            assignEmployeeToCdr(cdrData, processingContext);

            // Final duration check
            if (cdrData.getDurationSeconds() != null
                    && cdrData.getDurationSeconds() <= appConfigService.getMinCallDurationForTariffing()) {
                if (cdrData.getTelephonyTypeId() != null &&
                        cdrData.getTelephonyTypeId() > 0 &&
                        cdrData.getTelephonyTypeId() != TelephonyTypeEnum.ERRORS.getValue()) {
                    log.debug("Call duration {}s <= min. Setting type to NO_CONSUMPTION after all processing.",
                            cdrData.getDurationSeconds());
                    cdrData.setTelephonyTypeId(TelephonyTypeEnum.NO_CONSUMPTION.getValue());
                    cdrData.setTelephonyTypeName(telephonyTypeLookupService
                            .getTelephonyTypeName(TelephonyTypeEnum.NO_CONSUMPTION.getValue()));
                    cdrData.setBilledAmount(BigDecimal.ZERO);
                    cdrData.setPricePerMinute(BigDecimal.ZERO);
                    cdrData.setInitialPricePerMinute(BigDecimal.ZERO);
                }
            }

            // Transfer cleanup
            finalizeTransferInformation(cdrData);

        } catch (Exception e) {
            log.debug("Unhandled exception during CDR enrichment for line: {}", cdrData.getCtlHash(), e);
            cdrData.setMarkedForQuarantine(true);
            cdrData.setQuarantineReason("Enrichment failed: " + e.getMessage());
            cdrData.setQuarantineStep(QuarantineErrorType.ENRICHMENT_ERROR.name());
        }
        log.debug("Finished enrichment for CDR: {}. Billed Amount: {}, Type: {}", cdrData.getCtlHash(),
                cdrData.getBilledAmount(), cdrData.getTelephonyTypeName());
        return cdrData;
    }

    private void assignEmployeeToCdr(CdrData cdrData, LineProcessingContext processingContext) {
        String searchExtForEmployee;
        String searchAuthCodeForEmployee;
        Long commLocationId = processingContext.getCommLocation().getId();
        List<String> ignoredAuthCodes = processingContext.getCdrProcessor().getIgnoredAuthCodeDescriptions();

        // PHP: $arreglo_fun = ObtenerFuncionario_Arreglo($link, $ext, $clave,
        // $incoming, $info_cdr['date'], $funext, $COMUBICACION_ID, $tipo_fun);
        // $ext is callingPartyNumber, $clave is authCode, $incoming is callDirection
        // $tipo_fun (0=any_origin, 2=local_origin) depends on ext_globales.
        // For incoming, PHP's ObtenerFuncionario_Arreglo uses $ext (our extension) and
        // $clave (auth code, but ignored for incoming).
        // For outgoing, it uses $ext (our extension) and $clave (auth code).

        if (cdrData.getCallDirection() == CallDirection.INCOMING) {
            searchExtForEmployee = cdrData.getCallingPartyNumber(); // This is our extension after parser swap
            searchAuthCodeForEmployee = null; // Auth code not relevant for identifying our extension on an incoming
                                              // call
        } else { // OUTGOING or internal processed as outgoing
            searchExtForEmployee = cdrData.getCallingPartyNumber();
            searchAuthCodeForEmployee = cdrData.getAuthCodeDescription();
        }

        Employee foundEmployee = employeeLookupService.findEmployeeByExtensionOrAuthCode(
                searchExtForEmployee,
                searchAuthCodeForEmployee,
                commLocationId,
                ignoredAuthCodes,
                processingContext.getExtensionRanges(),
                cdrData.getDateTimeOrigination(),
                processingContext.getHistoricalData())
                .orElse(null);

        if (foundEmployee != null) {
            cdrData.setEmployeeId(foundEmployee.getId());
            cdrData.setEmployee(foundEmployee);
            log.debug("Found employee: ID={}, Ext={}", foundEmployee.getId(), foundEmployee.getExtension());

            boolean authCodeProvided = searchAuthCodeForEmployee != null && !searchAuthCodeForEmployee.isEmpty();
            boolean authCodeMatchedAndValid = authCodeProvided &&
                    foundEmployee.getAuthCode() != null &&
                    foundEmployee.getAuthCode()
                            .equalsIgnoreCase(searchAuthCodeForEmployee)
                    && processingContext.getIgnoredAuthCodes().stream()
                            .noneMatch(desc -> desc.equalsIgnoreCase(searchAuthCodeForEmployee));

            if (authCodeMatchedAndValid) {
                cdrData.setAssignmentCause(AssignmentCause.AUTH_CODE);
            } else if (authCodeProvided) {
                cdrData.setAssignmentCause(AssignmentCause.IGNORED_AUTH_CODE);
            } else {
                cdrData.setAssignmentCause(AssignmentCause.EXTENSION);
            }
            // If employee was found via range (ID is null for conceptual employee from
            // range)
            if (foundEmployee.getId() == null && cdrData.getAssignmentCause() == AssignmentCause.EXTENSION) {
                cdrData.setAssignmentCause(AssignmentCause.RANGES);
            }
            log.debug("Employee assignment cause: {}", cdrData.getAssignmentCause());

        } else {
            cdrData.setAssignmentCause(AssignmentCause.NOT_ASSIGNED);
            log.debug("Employee not found for Ext: {}, AuthCode: {}", searchExtForEmployee, searchAuthCodeForEmployee);
        }

        // PHP: if (!ExtensionEncontrada($arreglo_fun) && !$es_interna &&
        // isset($info['funcionario_redir']) && $info['funcionario_redir']['comid'] ==
        // $COMUBICACION_ID)
        // This logic assigns the call to the redirecting employee if the primary
        // employee wasn't found and it's a transfer.
        if (cdrData.getEmployeeId() == null && !cdrData.isInternalCall() &&
                cdrData.getLastRedirectDn() != null && !cdrData.getLastRedirectDn().isEmpty() &&
                cdrData.getTransferCause() != TransferCause.NONE
                && cdrData.getTransferCause() != TransferCause.CONFERENCE_END) {
            Employee redirEmployee = employeeLookupService.findEmployeeByExtensionOrAuthCode(
                    cdrData.getLastRedirectDn(), null, // No auth code for redirect lookup
                    commLocationId, ignoredAuthCodes, processingContext.getExtensionRanges(),
                    cdrData.getDateTimeOrigination(),
                    processingContext.getHistoricalData())
                    .orElse(null);
            if (redirEmployee != null &&
                    redirEmployee.getCommunicationLocation() != null &&
                    Objects.equals(redirEmployee.getCommunicationLocation().getId(), commLocationId)) {
                cdrData.setEmployeeId(redirEmployee.getId());
                cdrData.setEmployee(redirEmployee);
                cdrData.setAssignmentCause(AssignmentCause.TRANSFER);
                log.debug("Assigned call to redirecting employee (due to transfer): ID={}, Ext={}",
                        redirEmployee.getId(), redirEmployee.getExtension());
            }
        }
    }

    private void finalizeTransferInformation(CdrData cdrData) {
        if (cdrData.getTransferCause() != TransferCause.NONE &&
                cdrData.getLastRedirectDn() != null && !cdrData.getLastRedirectDn().isEmpty()) {
            cdrData.setEmployeeTransferExtension(cdrData.getLastRedirectDn());

            boolean transferToSelfOrOtherParty = false;
            String currentPartyExtension = null;
            String otherPartyExtension = null;

            if (cdrData.getCallDirection() == CallDirection.INCOMING) {
                currentPartyExtension = cdrData.getCallingPartyNumber(); // Our extension
                otherPartyExtension = cdrData.getFinalCalledPartyNumber(); // External number
            } else { // OUTGOING or internal
                currentPartyExtension = cdrData.getCallingPartyNumber(); // Our extension
                otherPartyExtension = cdrData.getFinalCalledPartyNumber(); // External/Internal number
            }

            if (Objects.equals(cdrData.getLastRedirectDn(), currentPartyExtension) ||
                    Objects.equals(cdrData.getLastRedirectDn(), otherPartyExtension)) {
                transferToSelfOrOtherParty = true;
            }

            if (transferToSelfOrOtherParty &&
                    cdrData.getTransferCause() != TransferCause.CONFERENCE &&
                    cdrData.getTransferCause() != TransferCause.CONFERENCE_NOW &&
                    cdrData.getTransferCause() != TransferCause.PRE_CONFERENCE_NOW) {
                log.debug(
                        "Clearing transfer info as it's a transfer to self/current party for non-conference. Original transfer ext: {}",
                        cdrData.getLastRedirectDn());
                cdrData.setEmployeeTransferExtension(null);
                cdrData.setTransferCause(TransferCause.NONE);
            } else {
                log.debug("Finalized transfer info. Transfer Ext: {}, Cause: {}",
                        cdrData.getEmployeeTransferExtension(), cdrData.getTransferCause());
            }
        }
    }
}

============================================================
FILE: CdrProcessingResultDto.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/CdrProcessingResultDto.java
SIZE: 0.42 KB
MODIFIED: 2025-09-01 11:21:58
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class CdrProcessingResultDto {
    private Long fileInfoId;
    private String status; // e.g., "COMPLETED", "FAILED"
    private String message;
    private long linesRead;
    private int successfulRecords;
    private int quarantinedRecords;
    private int skippedLines;
}

============================================================
FILE: CdrProcessor.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/CdrProcessor.java
SIZE: 1.73 KB
MODIFIED: 2025-11-26 14:32:43
============================================================
// File: com/infomedia/abacox/telephonypricing/cdr/CdrProcessor.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.CommunicationLocation;

import java.util.List;
import java.util.Map;

public interface CdrProcessor {
    /**
     * Probes the initial lines of a file to validate if this processor can handle the format.
     */
    boolean probe(List<String> initialLines);

    /**
     * Checks if the given line is a header line for this CDR type.
     */
    boolean isHeaderLine(String line);

    /**
     * Parses the header line and returns the column mapping.
     * Use this map in subsequent calls to evaluateFormat.
     *
     * @param headerLine The identified header line.
     * @return A map of Column Name -> Index
     */
    Map<String, Integer> parseHeader(String headerLine);

    /**
     * Parses a data line into a CdrData object.
     *
     * @param cdrLine The data line to parse.
     * @param commLocation The communication location context.
     * @param extensionLimits Limits for determining if a number is internal.
     * @param headerPositions The column mapping derived from the file header.
     * @return CdrData object, or null if the line should be skipped.
     */
    CdrData evaluateFormat(String cdrLine, CommunicationLocation commLocation, ExtensionLimits extensionLimits, Map<String, Integer> headerPositions);

    /**
     * Gets the unique identifiers for the plant types this processor handles.
     */
    List<Long> getPlantTypeIdentifiers();

    /**
     * Gets a list of authorization code descriptions that should be ignored.
     */
    List<String> getIgnoredAuthCodeDescriptions();
}

============================================================
FILE: CdrProcessorService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/CdrProcessorService.java
SIZE: 19.5 KB
MODIFIED: 2026-02-27 10:57:13
============================================================
// File: com/infomedia/abacox/telephonypricing/cdr/CdrProcessorService.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.component.utils.XXHash128Util;
import com.infomedia.abacox.telephonypricing.db.entity.*;
import com.infomedia.abacox.telephonypricing.multitenancy.TenantContext;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;

@Service
@Log4j2
public class CdrProcessorService {

    private final CdrEnrichmentService cdrEnrichmentService;
    private final CdrValidationService cdrValidationService;
    private final List<CdrProcessor> cdrProcessors;
    private final CommunicationLocationLookupService commLocationLookupService;
    private final EmployeeLookupService employeeLookupService;
    private final FileInfoPersistenceService fileInfoPersistenceService;
    private final CallRecordPersistenceService callRecordPersistenceService;
    private final FailedCallRecordPersistenceService failedCallRecordPersistenceService;
    private final PersistenceQueueService persistenceQueueService;
    private final FileProcessingTrackerService trackerService;

    @PersistenceContext
    private EntityManager entityManager;

    public CdrProcessorService(CdrEnrichmentService cdrEnrichmentService,
            CdrValidationService cdrValidationService,
            List<CdrProcessor> cdrProcessors,
            CommunicationLocationLookupService commLocationLookupService,
            EmployeeLookupService employeeLookupService,
            FileInfoPersistenceService fileInfoPersistenceService,
            CallRecordPersistenceService callRecordPersistenceService,
            FailedCallRecordPersistenceService failedCallRecordPersistenceService,
            PersistenceQueueService persistenceQueueService,
            FileProcessingTrackerService trackerService) {
        this.cdrEnrichmentService = cdrEnrichmentService;
        this.cdrValidationService = cdrValidationService;
        this.cdrProcessors = cdrProcessors;
        this.commLocationLookupService = commLocationLookupService;
        this.employeeLookupService = employeeLookupService;
        this.fileInfoPersistenceService = fileInfoPersistenceService;
        this.callRecordPersistenceService = callRecordPersistenceService;
        this.failedCallRecordPersistenceService = failedCallRecordPersistenceService;
        this.persistenceQueueService = persistenceQueueService;
        this.trackerService = trackerService;
    }

    @Transactional(propagation = Propagation.REQUIRED, readOnly = true)
    public void processCdrBatch(List<LineProcessingContext> batch) {
        if (batch.isEmpty())
            return;

        // Pre-register count in tracker BEFORE processing/queueing
        Map<Long, Integer> countsByFile = new HashMap<>();
        Set<String> uniqueExtensions = new HashSet<>();
        Set<String> uniqueAuthCodes = new HashSet<>();

        for (LineProcessingContext ctx : batch) {
            if (ctx.getFileInfoId() != null) {
                countsByFile.merge(ctx.getFileInfoId(), 1, Integer::sum);
            }

            // Collect unique identifiers for pre-fetching
            // We need to parse enough to get the extension and auth code
            CdrData preCdr = ctx.getCdrProcessor().evaluateFormat(
                    ctx.getCdrLine(), ctx.getCommLocation(),
                    ctx.getCommLocationExtensionLimits(), ctx.getHeaderPositions());

            if (preCdr != null) {
                if (preCdr.getCallingPartyNumber() != null)
                    uniqueExtensions.add(preCdr.getCallingPartyNumber());
                if (preCdr.getAuthCodeDescription() != null)
                    uniqueAuthCodes.add(preCdr.getAuthCodeDescription());
            }
        }
        countsByFile.forEach(trackerService::incrementPendingCount);

        // Pre-fetch historical timelines
        HistoricalDataContainer historicalData = employeeLookupService.prefetchHistoricalData(uniqueExtensions,
                uniqueAuthCodes);
        batch.forEach(ctx -> ctx.setHistoricalData(historicalData));

        // Capture TenantContext to propagate to parallel threads
        String tenantId = TenantContext.getTenant();

        // Use custom ForkJoinPool to prevent current thread (with transaction) from
        // participatings
        try (ForkJoinPool customPool = new ForkJoinPool(
                Math.min(batch.size(), Runtime.getRuntime().availableProcessors()))) {
            customPool.submit(() -> {
                batch.parallelStream().forEach(ctx -> {
                    try {
                        TenantContext.setTenant(tenantId);
                        processSingleCdrLineInternal(ctx);
                    } finally {
                        TenantContext.clear();
                    }
                });
            }).get(); // Wait for completion
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Processing interrupted", e);
        } catch (ExecutionException e) {
            throw new RuntimeException("Processing failed", e.getCause());
        }
    }

    public ProcessingOutcome processSingleCdrLineSync(LineProcessingContext lineProcessingContext) {
        return processSingleCdrLineInternal(lineProcessingContext);
    }

    /**
     * Processes a single CDR line context and returns the result.
     * Does NOT persist or queue anything.
     */
    public ProcessedCdrResult processCdrData(LineProcessingContext lineProcessingContext) {
        String cdrLine = lineProcessingContext.getCdrLine();
        CommunicationLocation targetCommLocation = lineProcessingContext.getCommLocation();
        CdrData cdrData = null;

        try {
            FileInfo currentFileInfo = lineProcessingContext.getFileInfo();
            CdrProcessor processor = lineProcessingContext.getCdrProcessor();

            cdrData = processor.evaluateFormat(
                    cdrLine,
                    targetCommLocation,
                    lineProcessingContext.getCommLocationExtensionLimits(),
                    lineProcessingContext.getHeaderPositions());

            if (cdrData == null) {
                return ProcessedCdrResult.builder()
                        .outcome(ProcessingOutcome.SKIPPED)
                        .build();
            }

            cdrData.setFileInfo(currentFileInfo);
            cdrData.setCommLocationId(targetCommLocation.getId());

            boolean isValid = cdrValidationService.validateInitialCdrData(cdrData);
            if (!isValid || cdrData.isMarkedForQuarantine()) {
                return buildResult(cdrData, null, ProcessingOutcome.QUARANTINED);
            }

            cdrData = cdrEnrichmentService.enrichCdr(cdrData, lineProcessingContext);

            if (cdrData.isMarkedForQuarantine()) {
                return buildResult(cdrData, null, ProcessingOutcome.QUARANTINED);
            } else {
                return buildResult(cdrData, targetCommLocation, ProcessingOutcome.SUCCESS);
            }

        } catch (Exception e) {
            log.error("Unhandled exception processing CDR line: {}", cdrLine, e);

            if (cdrData == null) {
                cdrData = new CdrData();
                cdrData.setRawCdrLine(cdrLine);
                if (lineProcessingContext.getFileInfo() != null) {
                    cdrData.setFileInfo(lineProcessingContext.getFileInfo());
                }
                cdrData.setCommLocationId(targetCommLocation.getId());
            }

            cdrData.setMarkedForQuarantine(true);
            cdrData.setQuarantineReason(e.getMessage());
            // Updated to use explicit enum name
            cdrData.setQuarantineStep(QuarantineErrorType.UNHANDLED_EXCEPTION.name());

            return buildResult(cdrData, null, ProcessingOutcome.QUARANTINED);
        }
    }

    private ProcessedCdrResult buildResult(CdrData cdrData, CommunicationLocation commLocation,
            ProcessingOutcome outcome) {
        QuarantineErrorType errorType = null;
        String errorMessage = null;
        String errorStep = null;

        if (outcome == ProcessingOutcome.QUARANTINED) {
            errorType = resolveErrorType(cdrData.getQuarantineStep());
            errorMessage = cdrData.getQuarantineReason();
            errorStep = cdrData.getQuarantineStep();
        }

        return ProcessedCdrResult.builder()
                .tenantId(TenantContext.getTenant())
                .cdrData(cdrData)
                .commLocation(commLocation)
                .outcome(outcome)
                .errorType(errorType)
                .errorMessage(errorMessage)
                .errorStep(errorStep)
                .build();
    }

    private ProcessingOutcome processSingleCdrLineInternal(LineProcessingContext lineProcessingContext) {
        ProcessedCdrResult result = processCdrData(lineProcessingContext);

        if (result.getOutcome() == ProcessingOutcome.SKIPPED) {
            // If skipped, we must decrement the tracker immediately
            if (lineProcessingContext.getFileInfo() != null) {
                trackerService.decrementPendingCount(lineProcessingContext.getFileInfo().getId(), 1);
            }
            return ProcessingOutcome.SKIPPED;
        }

        // Submit to persistence queue
        persistenceQueueService.submit(result);

        return result.getOutcome();
    }

    private QuarantineErrorType resolveErrorType(String step) {
        if (step == null)
            return QuarantineErrorType.INITIAL_VALIDATION_ERROR;
        try {
            return QuarantineErrorType.valueOf(step);
        } catch (IllegalArgumentException e) {
            return QuarantineErrorType.INITIAL_VALIDATION_ERROR;
        }
    }

    private CdrProcessor getProcessorForPlantType(Long plantTypeId) {
        return cdrProcessors.stream()
                .filter(p -> p.getPlantTypeIdentifiers().contains(plantTypeId))
                .findFirst()
                .orElseThrow(
                        () -> new IllegalArgumentException("No CDR processor found for plant type ID: " + plantTypeId));
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public boolean reprocessCallRecord(Long callRecordId) {
        CallRecord callRecord = entityManager.find(CallRecord.class, callRecordId);
        if (callRecord == null) {
            log.info("Reprocessing request for CallRecord ID {} failed: Record not found.", callRecordId);
            return false;
        }

        // 1. Retrieve Raw String via File Scan
        String cdrString;
        try {
            cdrString = findRawCdrLineInFile(callRecord.getFileInfoId(), callRecord.getCtlHash());
        } catch (Exception e) {
            log.error("Failed to retrieve raw CDR line for CallRecord ID {}", callRecordId, e);
            return false;
        }

        if (cdrString == null) {
            log.error("Original CDR line not found in file for CallRecord ID {} (Hash: {})", callRecordId,
                    callRecord.getCtlHash());
            return false;
        }

        Optional<LineProcessingContext> contextOpt = buildReprocessingContext(
                cdrString,
                callRecord.getCommLocationId(),
                callRecord.getFileInfoId());

        if (contextOpt.isEmpty()) {
            return false;
        }

        CdrData processedCdrData = executeReprocessingLogic(contextOpt.get());

        if (processedCdrData.isMarkedForQuarantine()) {
            failedCallRecordPersistenceService.quarantineRecord(
                    processedCdrData,
                    resolveErrorType(processedCdrData.getQuarantineStep()),
                    processedCdrData.getQuarantineReason(),
                    callRecordId);
            entityManager.remove(callRecord);
            return false;
        } else {
            // Update using Sync method
            callRecordPersistenceService.mapCdrDataToCallRecord(processedCdrData, callRecord,
                    contextOpt.get().getCommLocation());
            entityManager.merge(callRecord);
            return true;
        }
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public boolean reprocessFailedCallRecord(Long failedCallRecordId) {
        FailedCallRecord failedCallRecord = entityManager.find(FailedCallRecord.class, failedCallRecordId);
        if (failedCallRecord == null) {
            return false;
        }

        // 1. Retrieve Raw String via File Scan
        String cdrString;
        try {
            cdrString = findRawCdrLineInFile(failedCallRecord.getFileInfoId(), failedCallRecord.getCtlHash());
        } catch (Exception e) {
            log.error("Failed to retrieve raw CDR line for FailedCallRecord ID {}", failedCallRecordId, e);
            return false;
        }

        if (cdrString == null) {
            log.error("Original CDR line not found in file for FailedCallRecord ID {} (Hash: {})", failedCallRecordId,
                    failedCallRecord.getCtlHash());
            return false;
        }

        Optional<LineProcessingContext> contextOpt = buildReprocessingContext(
                cdrString,
                failedCallRecord.getCommLocationId(),
                failedCallRecord.getFileInfoId());

        if (contextOpt.isEmpty()) {
            return false;
        }

        CdrData processedCdrData = executeReprocessingLogic(contextOpt.get());

        if (processedCdrData.isMarkedForQuarantine()) {
            QuarantineErrorType errorType = resolveErrorType(processedCdrData.getQuarantineStep());

            failedCallRecord.setErrorType(errorType.name());
            failedCallRecord.setErrorMessage(processedCdrData.getQuarantineReason());
            entityManager.merge(failedCallRecord);
            return false;
        } else {
            CallRecord newCallRecord = callRecordPersistenceService.saveOrUpdateCallRecord(processedCdrData,
                    contextOpt.get().getCommLocation());
            if (newCallRecord != null) {
                entityManager.remove(failedCallRecord);
                return true;
            }
            return false;
        }
    }

    private Optional<LineProcessingContext> buildReprocessingContext(String cdrLine, Long commLocationId,
            Long fileInfoId) {
        if (commLocationId == null)
            return Optional.empty();

        Optional<CommunicationLocation> commLocationOpt = commLocationLookupService.findById(commLocationId);
        if (commLocationOpt.isEmpty())
            return Optional.empty();

        CommunicationLocation commLocation = commLocationOpt.get();
        FileInfo fileInfo = fileInfoPersistenceService.findById(fileInfoId);

        CdrProcessor processor = getProcessorForPlantType(commLocation.getPlantTypeId());
        Map<Long, ExtensionLimits> extensionLimits = employeeLookupService.getExtensionLimits();
        Map<Long, List<ExtensionRange>> extensionRanges = employeeLookupService.getExtensionRanges();

        Map<String, Integer> headerPositions = new HashMap<>();
        if (fileInfo != null) {
            Optional<FileInfoData> fileDataOpt = fileInfoPersistenceService.getOriginalFileData(fileInfoId);
            if (fileDataOpt.isPresent()) {
                try (InputStream is = fileDataOpt.get().content();
                        InputStreamReader reader = new InputStreamReader(is, StandardCharsets.UTF_8);
                        BufferedReader br = new BufferedReader(reader)) {

                    String line;
                    int linesChecked = 0;
                    while ((line = br.readLine()) != null && linesChecked < 5) {
                        line = line.trim();
                        if (!line.isEmpty() && processor.isHeaderLine(line)) {
                            headerPositions = processor.parseHeader(line);
                            break;
                        }
                        linesChecked++;
                    }
                } catch (IOException e) {
                    log.error("Failed to read header from FileInfo ID {} for reprocessing.", fileInfoId, e);
                }
            }
        }

        LineProcessingContext context = LineProcessingContext.builder()
                .cdrLine(cdrLine)
                .commLocation(commLocation)
                .cdrProcessor(processor)
                .extensionRanges(extensionRanges)
                .extensionLimits(extensionLimits)
                .fileInfo(fileInfo)
                .headerPositions(headerPositions)
                .build();

        return Optional.of(context);
    }

    /**
     * Reads the associated file stream and scans for the line matching the specific
     * hash.
     * This replaces the need to store the string in the DB.
     */
    private String findRawCdrLineInFile(Long fileInfoId, UUID targetHash) throws IOException {
        if (fileInfoId == null || targetHash == null)
            return null;

        Optional<FileInfoData> fileDataOpt = fileInfoPersistenceService.getOriginalFileData(fileInfoId);
        if (fileDataOpt.isEmpty())
            return null;

        try (InputStream is = fileDataOpt.get().content();
                InputStreamReader reader = new InputStreamReader(is, StandardCharsets.UTF_8);
                BufferedReader br = new BufferedReader(reader)) {

            String line;
            while ((line = br.readLine()) != null) {
                String trimmed = line.trim();
                if (trimmed.isEmpty())
                    continue;

                // Re-calculate hash exactly as CdrData does it
                UUID lineHash = XXHash128Util.hash(trimmed.getBytes(StandardCharsets.UTF_8));

                if (lineHash.equals(targetHash)) {
                    return trimmed;
                }
            }
        }
        return null;
    }

    private CdrData executeReprocessingLogic(LineProcessingContext context) {
        CdrData cdrData = context.getCdrProcessor().evaluateFormat(
                context.getCdrLine(),
                context.getCommLocation(),
                context.getCommLocationExtensionLimits(),
                context.getHeaderPositions());

        if (cdrData == null) {
            cdrData = new CdrData();
            cdrData.setRawCdrLine(context.getCdrLine());
            cdrData.setMarkedForQuarantine(true);
            cdrData.setQuarantineReason("Parser returned null during reprocessing.");
            cdrData.setQuarantineStep(QuarantineErrorType.PARSER_ERROR.name());
        }
        cdrData.setFileInfo(context.getFileInfo());
        cdrData.setCommLocationId(context.getCommLocationId());

        boolean isValid = cdrValidationService.validateInitialCdrData(cdrData);
        if (!isValid || cdrData.isMarkedForQuarantine()) {
            return cdrData;
        }

        return cdrEnrichmentService.enrichCdr(cdrData, context);
    }
}

============================================================
FILE: CdrRoutingService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/CdrRoutingService.java
SIZE: 17.17 KB
MODIFIED: 2026-02-27 11:38:51
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.CommunicationLocation;
import com.infomedia.abacox.telephonypricing.db.entity.ExtensionRange;
import com.infomedia.abacox.telephonypricing.db.entity.FileInfo;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@Service
@Log4j2
@RequiredArgsConstructor
public class CdrRoutingService {

    private final CommunicationLocationLookupService commLocationLookupService;
    private final CdrProcessorService cdrProcessorService;
    private final FileInfoPersistenceService fileInfoPersistenceService;
    private final FailedCallRecordPersistenceService failedCallRecordPersistenceService;
    private final CallRecordPersistenceService callRecordPersistenceService;
    private final List<CdrProcessor> cdrProcessors;
    private final EmployeeLookupService employeeLookupService;
    private final FileProcessingTrackerService trackerService;
    private final CdrConfigService cdrConfigService;

    private CdrProcessor getProcessorForPlantType(Long plantTypeId) {
        return cdrProcessors.stream()
                .filter(p -> p.getPlantTypeIdentifiers().contains(plantTypeId))
                .findFirst()
                .orElseThrow(
                        () -> new IllegalArgumentException("No CDR processor found for plant type ID: " + plantTypeId));
    }

    private void processStreamContent(FileInfo fileInfo, InputStream contentStream,
            Map<Long, ExtensionLimits> extensionLimits,
            Map<Long, List<ExtensionRange>> extensionRanges) {

        // METRICS: Start Timer
        long startTime = System.currentTimeMillis();

        trackerService.initFile(fileInfo.getId());

        Long plantTypeId = fileInfo.getPlantTypeId().longValue();
        CdrProcessor initialParser = getProcessorForPlantType(plantTypeId);
        Map<String, Integer> currentFileHeaderMap = null;

        // METRICS: Counters
        long lineCount = 0;
        long totalProcessedCount = 0;
        long unroutableCdrCount = 0;

        List<LineProcessingContext> batch = new ArrayList<>(CdrConfigService.CDR_PROCESSING_BATCH_SIZE);

        try (InputStreamReader reader = new InputStreamReader(contentStream, StandardCharsets.UTF_8);
                BufferedReader bufferedReader = new BufferedReader(reader)) {

            String line;
            while ((line = bufferedReader.readLine()) != null) {
                lineCount++;
                String trimmedLine = line.trim();
                if (trimmedLine.isEmpty())
                    continue;

                if (currentFileHeaderMap == null && initialParser.isHeaderLine(trimmedLine)) {
                    currentFileHeaderMap = initialParser.parseHeader(trimmedLine);
                    continue;
                }

                if (currentFileHeaderMap == null) {
                    CdrData tempData = new CdrData();
                    tempData.setRawCdrLine(trimmedLine);
                    tempData.setFileInfo(fileInfo);
                    failedCallRecordPersistenceService.quarantineRecord(tempData,
                            QuarantineErrorType.MISSING_HEADER,
                            "CDR data encountered before header", null);
                    unroutableCdrCount++;
                    continue;
                }

                CdrData preliminaryCdrData = initialParser.evaluateFormat(trimmedLine, null, null,
                        currentFileHeaderMap);
                if (preliminaryCdrData == null)
                    continue;

                preliminaryCdrData.setRawCdrLine(trimmedLine);
                preliminaryCdrData.setFileInfo(fileInfo);

                Optional<CommunicationLocation> targetCommLocationOpt = commLocationLookupService
                        .findBestCommunicationLocation(
                                plantTypeId,
                                preliminaryCdrData.getCallingPartyNumber(),
                                preliminaryCdrData.getCallingPartyNumberPartition(),
                                preliminaryCdrData.getFinalCalledPartyNumber(),
                                preliminaryCdrData.getFinalCalledPartyNumberPartition(),
                                preliminaryCdrData.getLastRedirectDn(),
                                preliminaryCdrData.getLastRedirectDnPartition(),
                                preliminaryCdrData.getDateTimeOrigination());

                if (targetCommLocationOpt.isPresent()) {
                    CommunicationLocation targetCommLocation = targetCommLocationOpt.get();
                    CdrProcessor finalProcessor = getProcessorForPlantType(targetCommLocation.getPlantTypeId());

                    LineProcessingContext lineProcessingContext = LineProcessingContext.builder()
                            .cdrLine(trimmedLine)
                            .commLocation(targetCommLocation)
                            .cdrProcessor(finalProcessor)
                            .extensionRanges(extensionRanges)
                            .extensionLimits(extensionLimits)
                            .fileInfo(fileInfo)
                            .headerPositions(currentFileHeaderMap)
                            .build();
                    batch.add(lineProcessingContext);
                } else {
                    unroutableCdrCount++;
                    preliminaryCdrData.setCommLocationId(null);
                    failedCallRecordPersistenceService.quarantineRecord(preliminaryCdrData,
                            QuarantineErrorType.PENDING_ASSOCIATION,
                            "Could not route CDR to a CommunicationLocation", null);
                }

                if (batch.size() >= CdrConfigService.CDR_PROCESSING_BATCH_SIZE) {
                    cdrProcessorService.processCdrBatch(batch);
                    totalProcessedCount += batch.size();
                    batch.clear();
                }
            }

            if (!batch.isEmpty()) {
                cdrProcessorService.processCdrBatch(batch);
                totalProcessedCount += batch.size();
                batch.clear();
            }

            trackerService.markParsingComplete(fileInfo.getId());

            // METRICS: Final Calculation
            long endTime = System.currentTimeMillis();
            long durationMs = endTime - startTime;
            double seconds = durationMs / 1000.0;
            double linesPerSecond = (seconds > 0) ? (lineCount / seconds) : 0.0;

            log.info(
                    "Outcome for file [{}]: SUCCESS. Time: {}ms. Speed: {} lines/sec. Read: {}, Routed: {}, Unroutable: {}",
                    fileInfo.getFilename(),
                    durationMs,
                    String.format("%.2f", linesPerSecond),
                    lineCount,
                    totalProcessedCount,
                    unroutableCdrCount);

        } catch (IOException e) {
            log.error("Outcome for file [{}]: FAILED. IO Error.", fileInfo.getFilename(), e);
            trackerService.markParsingComplete(fileInfo.getId());
            fileInfoPersistenceService.updateStatus(fileInfo.getId(), FileInfo.ProcessingStatus.FAILED);
        }
    }

    public void processFileInfo(Long fileInfoId) {
        // Guard: if CDR processing was disabled while this task was queued/running,
        // reset the file back to PENDING so it's not orphaned as IN_PROGRESS.
        if (!cdrConfigService.isCdrProcessingEnabled()) {
            log.info("CDR processing disabled by configuration. Resetting FileInfo ID {} back to PENDING.", fileInfoId);
            fileInfoPersistenceService.updateStatus(fileInfoId, FileInfo.ProcessingStatus.PENDING);
            return;
        }

        log.info("Starting processing for FileInfo ID: {}", fileInfoId);
        FileInfo fileInfo = fileInfoPersistenceService.findById(fileInfoId);

        if (fileInfo == null) {
            log.error("FileInfo ID {}: FAILED (Missing Data)", fileInfoId);
            return;
        }

        Optional<FileInfoData> fileDataOpt = fileInfoPersistenceService.getOriginalFileData(fileInfoId);

        if (fileDataOpt.isPresent()) {
            try (InputStream contentStream = fileDataOpt.get().content()) {
                Map<Long, ExtensionLimits> extensionLimits = employeeLookupService.getExtensionLimits();
                Map<Long, List<ExtensionRange>> extensionRanges = employeeLookupService.getExtensionRanges();

                processStreamContent(fileInfo, contentStream, extensionLimits, extensionRanges);
            } catch (IOException e) {
                log.error("Stream read error for file {}", fileInfoId, e);
            }
        }
    }

    @Transactional
    public void cleanupRecordsForFile(Long fileInfoId) {
        log.debug("Cleaning up existing records for FileInfo ID: {}", fileInfoId);
        int deletedCallRecords = callRecordPersistenceService.deleteByFileInfoId(fileInfoId);
        int deletedFailedRecords = failedCallRecordPersistenceService.deleteByFileInfoId(fileInfoId);
        log.info("Cleanup complete for FileInfo ID {}: Deleted {} CallRecords and {} FailedCallRecords.",
                fileInfoId, deletedCallRecords, deletedFailedRecords);
    }

    public void reprocessFileInfo(Long fileInfoId, boolean cleanupExistingRecords) {
        log.info("Starting reprocessing for FileInfo ID: {}", fileInfoId);
        if (cleanupExistingRecords) {
            cleanupRecordsForFile(fileInfoId);
        }
        processFileInfo(fileInfoId);
    }

    @Transactional
    public CdrProcessingResultDto routeAndProcessCdrStreamSync(FileInfo fileInfo) {
        long startTime = System.currentTimeMillis();
        log.info("Starting SYNCHRONOUS CDR stream processing for FileInfo ID: {}", fileInfo.getId());

        fileInfoPersistenceService.updateStatus(fileInfo.getId(), FileInfo.ProcessingStatus.IN_PROGRESS);

        CdrProcessingResultDto.CdrProcessingResultDtoBuilder resultBuilder = CdrProcessingResultDto.builder()
                .fileInfoId(fileInfo.getId());
        long lineCount = 0;
        int successfulRecords = 0;
        int quarantinedRecords = 0;
        int skippedLines = 0;
        FileInfo.ProcessingStatus finalStatus = FileInfo.ProcessingStatus.FAILED;
        String finalMessage = "An unexpected error occurred.";

        try {
            Optional<FileInfoData> fileDataOpt = fileInfoPersistenceService.getOriginalFileData(fileInfo.getId());

            if (!fileDataOpt.isPresent()) {
                throw new RuntimeException("Failed to retrieve file content for FileInfo ID: " + fileInfo.getId());
            }

            Map<Long, ExtensionLimits> extensionLimits = employeeLookupService.getExtensionLimits();
            Map<Long, List<ExtensionRange>> extensionRanges = employeeLookupService.getExtensionRanges();
            CdrProcessor initialParser = getProcessorForPlantType(fileInfo.getPlantTypeId().longValue());
            Map<String, Integer> currentHeaderMap = null;

            try (InputStream inputStream = fileDataOpt.get().content();
                    InputStreamReader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8);
                    BufferedReader bufferedReader = new BufferedReader(reader)) {

                String line;
                while ((line = bufferedReader.readLine()) != null) {
                    lineCount++;
                    String trimmedLine = line.trim();
                    if (trimmedLine.isEmpty())
                        continue;

                    if (currentHeaderMap == null && initialParser.isHeaderLine(trimmedLine)) {
                        currentHeaderMap = initialParser.parseHeader(trimmedLine);
                        continue;
                    }

                    if (currentHeaderMap == null) {
                        CdrData tempData = new CdrData();
                        tempData.setRawCdrLine(trimmedLine);
                        tempData.setFileInfo(fileInfo);
                        failedCallRecordPersistenceService.quarantineRecord(
                                tempData,
                                QuarantineErrorType.MISSING_HEADER,
                                "CDR data encountered before header (sync processing)",
                                null);
                        quarantinedRecords++;
                        continue;
                    }

                    CdrData preliminaryCdrData = initialParser.evaluateFormat(trimmedLine, null, null,
                            currentHeaderMap);
                    if (preliminaryCdrData == null) {
                        skippedLines++;
                        continue;
                    }

                    Optional<CommunicationLocation> targetCommLocationOpt = commLocationLookupService
                            .findBestCommunicationLocation(
                                    fileInfo.getPlantTypeId().longValue(),
                                    preliminaryCdrData.getCallingPartyNumber(),
                                    preliminaryCdrData.getCallingPartyNumberPartition(),
                                    preliminaryCdrData.getFinalCalledPartyNumber(),
                                    preliminaryCdrData.getFinalCalledPartyNumberPartition(),
                                    preliminaryCdrData.getLastRedirectDn(),
                                    preliminaryCdrData.getLastRedirectDnPartition(),
                                    preliminaryCdrData.getDateTimeOrigination());

                    if (targetCommLocationOpt.isPresent()) {
                        CommunicationLocation targetCommLocation = targetCommLocationOpt.get();
                        CdrProcessor finalProcessor = getProcessorForPlantType(targetCommLocation.getPlantTypeId());

                        LineProcessingContext context = LineProcessingContext.builder()
                                .cdrLine(trimmedLine)
                                .commLocation(targetCommLocation)
                                .cdrProcessor(finalProcessor)
                                .extensionRanges(extensionRanges)
                                .extensionLimits(extensionLimits)
                                .fileInfo(fileInfo)
                                .headerPositions(currentHeaderMap)
                                .build();

                        ProcessingOutcome outcome = cdrProcessorService.processSingleCdrLineSync(context);
                        switch (outcome) {
                            case SUCCESS -> successfulRecords++;
                            case QUARANTINED -> quarantinedRecords++;
                            case SKIPPED -> skippedLines++;
                        }
                    } else {
                        quarantinedRecords++;
                        preliminaryCdrData.setRawCdrLine(trimmedLine);
                        preliminaryCdrData.setFileInfo(fileInfo);
                        preliminaryCdrData.setCommLocationId(null);
                        failedCallRecordPersistenceService.quarantineRecord(
                                preliminaryCdrData,
                                QuarantineErrorType.PENDING_ASSOCIATION,
                                "Could not route CDR to a CommunicationLocation",
                                null);
                    }
                }
            }

            finalStatus = FileInfo.ProcessingStatus.COMPLETED;
            finalMessage = "File processed successfully.";

            long endTime = System.currentTimeMillis();
            long durationMs = endTime - startTime;

            log.info(
                    "Sync processing completed for FileInfo ID {}: {} lines. Time: {}ms. {} successful, {} quarantined, {} skipped",
                    fileInfo.getId(), lineCount, durationMs, successfulRecords, quarantinedRecords, skippedLines);

        } catch (Exception e) {
            log.error("Critical failure during synchronous processing of file ID: {}. Rolling back.",
                    fileInfo.getId(), e);
            finalStatus = FileInfo.ProcessingStatus.FAILED;
            finalMessage = "Processing failed: " + e.getMessage();
            throw new RuntimeException("Synchronous processing failed for FileInfo ID " + fileInfo.getId(), e);
        } finally {
            fileInfoPersistenceService.updateStatus(fileInfo.getId(), finalStatus);
        }

        return resultBuilder
                .status(finalStatus.name())
                .message(finalMessage)
                .linesRead(lineCount)
                .successfulRecords(successfulRecords)
                .quarantinedRecords(quarantinedRecords)
                .skippedLines(skippedLines)
                .build();
    }
}

============================================================
FILE: CdrUtil.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/CdrUtil.java
SIZE: 11.27 KB
MODIFIED: 2026-02-24 23:44:23
============================================================
// File: com/infomedia/abacox/telephonypricing/component/cdrprocessing/CdrUtil.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import lombok.extern.log4j.Log4j2;

@Log4j2
public class CdrUtil {

    private static final int PROBE_LINE_COUNT = 5; // Read the first few lines for validation

    public static List<String> parseCsvLine(String line, String separator) {
        if (line == null)
            return Arrays.asList("");
        return Arrays.stream(line.split(Pattern.quote(separator)))
                .map(CdrUtil::cleanCsvField)
                .collect(Collectors.toList());
    }

    public static String cleanCsvField(String field) {
        if (field == null)
            return "";
        String cleaned = field.trim();
        cleaned = cleaned.replace("\u0000", "");

        if (cleaned.startsWith("\"") && cleaned.endsWith("\"") && cleaned.length() >= 2) {
            cleaned = cleaned.substring(1, cleaned.length() - 1);
        }
        return cleaned;
    }

    public static String decimalToIp(long dec) {
        if (dec < 0) {
            log.trace("Received negative decimal for IP conversion: {}, returning as string.", dec);
            return String.valueOf(dec);
        }
        return String.format("%d.%d.%d.%d",
                (dec & 0xFF),
                (dec >> 8) & 0xFF,
                (dec >> 16) & 0xFF,
                (dec >> 24) & 0xFF);
    }

    public static CleanPhoneNumberResult cleanPhoneNumber(String number, List<String> pbxExitPrefixes,
            boolean modoSeguro) {
        if (number == null) {
            return new CleanPhoneNumberResult("", false);
        }
        String currentNumber = number.trim();
        log.trace("Cleaning phone number: '{}', PBX Prefixes: {}, ModoSeguro: {}", number, pbxExitPrefixes, modoSeguro);

        String numberAfterPrefixStrip = currentNumber;
        boolean pbxPrefixWasStripped = false;

        boolean pbxPrefixDefined = pbxExitPrefixes != null && !pbxExitPrefixes.isEmpty();
        int phpMaxCaracterAExtraer = -1;

        if (pbxPrefixDefined) {
            String longestMatchingPrefix = "";
            for (String prefix : pbxExitPrefixes) {
                String trimmedPrefix = prefix.trim();
                if (!trimmedPrefix.isEmpty() && currentNumber.startsWith(trimmedPrefix)) {
                    if (trimmedPrefix.length() > longestMatchingPrefix.length()) {
                        longestMatchingPrefix = trimmedPrefix;
                    }
                }
            }
            if (!longestMatchingPrefix.isEmpty()) {
                numberAfterPrefixStrip = currentNumber.substring(longestMatchingPrefix.length());
                phpMaxCaracterAExtraer = longestMatchingPrefix.length();
                pbxPrefixWasStripped = true;
                log.trace("PBX prefix '{}' stripped. Number is now: '{}'", longestMatchingPrefix,
                        numberAfterPrefixStrip);
            } else {
                phpMaxCaracterAExtraer = 0;
                log.trace("PBX prefixes defined but none matched current number '{}'", currentNumber);
            }
        }

        if (phpMaxCaracterAExtraer == 0) {
            numberAfterPrefixStrip = "";
        }

        if (modoSeguro && numberAfterPrefixStrip.isEmpty() && phpMaxCaracterAExtraer == 0) {
            numberAfterPrefixStrip = currentNumber;
            log.trace("ModoSeguro is true and no PBX prefix matched, reverting to original for further cleaning: '{}'",
                    numberAfterPrefixStrip);
        }

        String numToClean = numberAfterPrefixStrip;

        if (numToClean.startsWith("+")) {
            numToClean = numToClean.substring(1);
            log.trace("Stripped leading '+'. Number is now: '{}'", numToClean);
        }

        if (numToClean.isEmpty()) {
            log.trace("Number is empty after initial cleaning. Returning empty.");
            return new CleanPhoneNumberResult("", pbxPrefixWasStripped);
        }

        String firstChar = String.valueOf(numToClean.charAt(0));
        String restOfNumber = numToClean.length() > 1 ? numToClean.substring(1) : "";
        StringBuilder cleanedRest = new StringBuilder();

        if (!restOfNumber.isEmpty()) {
            for (char c : restOfNumber.toCharArray()) {
                if (Character.isDigit(c)) {
                    cleanedRest.append(c);
                } else {
                    log.trace("Non-digit '{}' found after first char. Stopping cleaning of rest.", c);
                    break;
                }
            }
        }

        String finalCleanedNumber = firstChar + cleanedRest.toString();
        log.debug("Cleaned phone number result: '{}', Prefix Stripped: {}", finalCleanedNumber, pbxPrefixWasStripped);
        return new CleanPhoneNumberResult(finalCleanedNumber, pbxPrefixWasStripped);
    }

    /**
     * Performs a complete swap of calling/called party information, including
     * numbers, partitions,
     * and optionally trunks. This replicates the full logic of PHP's
     * `InvertirLlamada`.
     *
     * @param cdrData    The CdrData object to modify.
     * @param swapTrunks If true, swaps origDeviceName and destDeviceName.
     */
    public static void swapFull(CdrData cdrData, boolean swapTrunks) {
        log.debug("Performing FULL swap. SwapTrunks: {}. Before: Calling='{}'({}), FinalCalled='{}'({})",
                swapTrunks, cdrData.getCallingPartyNumber(), cdrData.getCallingPartyNumberPartition(),
                cdrData.getFinalCalledPartyNumber(), cdrData.getFinalCalledPartyNumberPartition());

        // Swap numbers
        String tempExt = cdrData.getCallingPartyNumber();
        cdrData.setCallingPartyNumber(cdrData.getFinalCalledPartyNumber());
        cdrData.setFinalCalledPartyNumber(tempExt);

        // Swap partitions
        String tempExtPart = cdrData.getCallingPartyNumberPartition();
        cdrData.setCallingPartyNumberPartition(cdrData.getFinalCalledPartyNumberPartition());
        cdrData.setFinalCalledPartyNumberPartition(tempExtPart);

        // Update "original" and "effective" fields to reflect the new state
        cdrData.setOriginalFinalCalledPartyNumber(cdrData.getFinalCalledPartyNumber());
        cdrData.setOriginalFinalCalledPartyNumberPartition(cdrData.getFinalCalledPartyNumberPartition());
        cdrData.setEffectiveDestinationNumber(cdrData.getFinalCalledPartyNumber());

        if (swapTrunks) {
            swapTrunks(cdrData);
        }

        log.debug("FULL swap complete. After: Calling='{}'({}), FinalCalled='{}'({})",
                cdrData.getCallingPartyNumber(), cdrData.getCallingPartyNumberPartition(),
                cdrData.getFinalCalledPartyNumber(), cdrData.getFinalCalledPartyNumberPartition());
    }

    /**
     * Performs a PARTIAL swap, exchanging only the calling and called numbers.
     * Partitions and trunks are NOT affected. This is for the non-conference
     * incoming detection case.
     * 
     * @param cdrData The CdrData object to modify.
     */
    public static void swapPartyNumbersOnly(CdrData cdrData) {
        log.debug("Performing PARTIAL swap of party numbers only. Before: Calling='{}', FinalCalled='{}'",
                cdrData.getCallingPartyNumber(), cdrData.getFinalCalledPartyNumber());

        String tempExt = cdrData.getCallingPartyNumber();
        cdrData.setCallingPartyNumber(cdrData.getFinalCalledPartyNumber());
        cdrData.setFinalCalledPartyNumber(tempExt);

        // Update "original" and "effective" fields to reflect the new state
        cdrData.setOriginalFinalCalledPartyNumber(cdrData.getFinalCalledPartyNumber());
        cdrData.setEffectiveDestinationNumber(cdrData.getFinalCalledPartyNumber());

        log.debug("PARTIAL swap complete. After: Calling='{}', FinalCalled='{}'",
                cdrData.getCallingPartyNumber(), cdrData.getFinalCalledPartyNumber());
    }

    public static void swapTrunks(CdrData cdrData) {
        log.debug("Swapping trunks. Before: Orig='{}', Dest='{}'", cdrData.getOrigDeviceName(),
                cdrData.getDestDeviceName());
        String tempTrunk = cdrData.getOrigDeviceName();
        cdrData.setOrigDeviceName(cdrData.getDestDeviceName());
        cdrData.setDestDeviceName(tempTrunk);
        log.debug("Swapped trunks. After: Orig='{}', Dest='{}'", cdrData.getOrigDeviceName(),
                cdrData.getDestDeviceName());
    }

    public static String cleanExtension(String extension) {
        if (extension == null)
            return "";
        String cleaned = extension.trim();
        // Remove leading '+' if present
        if (cleaned.startsWith("+"))
            cleaned = cleaned.substring(1);
        // Step 1: Trim and remove whitespace
        return cleaned.replaceAll("\\s+", "");
    }

    public static boolean isPossibleExtension(String extensionNumber, ExtensionLimits limits) {
        if (limits == null || extensionNumber == null || extensionNumber.isEmpty()) {
            return false;
        }
        String cleanedExt = CdrUtil.cleanPhoneNumber(extensionNumber, null, false).getCleanedNumber();
        if (cleanedExt.startsWith("+"))
            cleanedExt = cleanedExt.substring(1);

        if (limits.getSpecialFullExtensions() != null && limits.getSpecialFullExtensions().contains(cleanedExt)) {
            return true;
        }

        boolean phpExtensionValidaForNumericRange = (!cleanedExt.startsWith("0") || cleanedExt.equals("0")) &&
                cleanedExt.matches("\\d+");

        if (phpExtensionValidaForNumericRange) {
            try {
                long extNumValue = Long.parseLong(cleanedExt);
                return extNumValue >= limits.getMinLength() && extNumValue <= limits.getMaxLength();
            } catch (NumberFormatException e) {
                return false;
            }
        }
        return false;
    }

    /**
     * Reads the first few lines of a file for probing/validation using streaming.
     * Never loads the entire file into memory.
     *
     * @param file The file to read from.
     * @return A list of the first few lines (up to PROBE_LINE_COUNT).
     */
    public static List<String> readInitialLinesFromFile(File file) {
        List<String> lines = new ArrayList<>();
        if (file == null || !file.exists() || file.length() == 0) {
            return lines;
        }

        try (InputStream inputStream = new FileInputStream(file);
                InputStreamReader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8);
                BufferedReader bufferedReader = new BufferedReader(reader)) {

            String line;
            while ((line = bufferedReader.readLine()) != null && lines.size() < PROBE_LINE_COUNT) {
                lines.add(line);
            }

            log.debug("Read {} initial lines from file for probing", lines.size());

        } catch (IOException e) {
            log.error("Failed to read initial lines from file '{}' for probing.", file.getName(), e);
        }

        return lines;
    }
}

============================================================
FILE: CdrValidationService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/CdrValidationService.java
SIZE: 6.78 KB
MODIFIED: 2026-02-27 10:41:22
============================================================
// File: com/infomedia/abacox/telephonypricing/component/cdrprocessing/CdrValidationService.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Service
@Log4j2
public class CdrValidationService {

    private final CdrConfigService appConfigService;

    public CdrValidationService(CdrConfigService appConfigService) {
        this.appConfigService = appConfigService;
    }

    public boolean validateInitialCdrData(CdrData cdrData) {
        log.debug("Validating initial CDR data: {}", cdrData.getCtlHash());
        List<String> errorMessages = new ArrayList<>();
        List<String> warningMessages = new ArrayList<>();
        QuarantineErrorType primaryErrorType = null;
        QuarantineErrorType primaryWarningType = null;

        // PHP: if (trim($info_cdr['ext']) == '') { InvertirLlamada($info_cdr); ... }
        if ((cdrData.getCallingPartyNumber() == null || cdrData.getCallingPartyNumber().isEmpty()) &&
                (cdrData.getFinalCalledPartyNumber() != null && !cdrData.getFinalCalledPartyNumber().isEmpty())) {
            log.debug("CallingPartyNumber is blank but FinalCalledPartyNumber is not. Performing full swap and treating as INCOMING. CDR: {}", cdrData.getCtlHash());
            CdrUtil.swapFull(cdrData, true); // Full swap including trunks
            cdrData.setCallDirection(CallDirection.INCOMING);
            cdrData.setInternalCall(false); // Ensure it's not treated as internal after this swap
        }

        if (cdrData.getDateTimeOrigination() == null) {
            errorMessages.add("Missing or invalid origination date/time (PHP: _ESPERABA_FECHA).");
            if (primaryErrorType == null) primaryErrorType = QuarantineErrorType.INVALID_DATE;
        } else {
            LocalDateTime minDate = DateTimeUtil.stringToLocalDateTime(appConfigService.getMinAllowedCaptureDate() + " 00:00:00");
            if (minDate != null && cdrData.getDateTimeOrigination().isBefore(minDate)) {
                warningMessages.add("Origination date " + cdrData.getDateTimeOrigination() + " is before minimum allowed " + minDate + " (PHP: _FECHANO Min).");
                if (primaryWarningType == null) primaryWarningType = QuarantineErrorType.INVALID_DATE;
            }
            int maxDaysFuture = appConfigService.getMaxAllowedCaptureDateDaysInFuture();
            if (maxDaysFuture > 0 && cdrData.getDateTimeOrigination().isAfter(LocalDateTime.now().plusDays(maxDaysFuture))) {
                warningMessages.add("Origination date " + cdrData.getDateTimeOrigination() + " is too far in the future (max " + maxDaysFuture + " days) (PHP: _FECHANO Max).");
                if (primaryWarningType == null) primaryWarningType = QuarantineErrorType.INVALID_DATE;
            }
        }

        if (cdrData.getCallingPartyNumber() != null && cdrData.getCallingPartyNumber().contains(" ")) {
            errorMessages.add("Calling party number '" + cdrData.getCallingPartyNumber() + "' contains spaces (PHP: _ESPERABA_NUMERO).");
            if (primaryErrorType == null) primaryErrorType = QuarantineErrorType.INVALID_NUMBER_FORMAT;
        }

        if (cdrData.getFinalCalledPartyNumber() != null && !cdrData.getFinalCalledPartyNumber().isEmpty() &&
                !cdrData.getFinalCalledPartyNumber().equalsIgnoreCase("ANONYMOUS") &&
                !cdrData.getFinalCalledPartyNumber().matches("^[0-9#*+]+$")) {
            errorMessages.add("Final called party number '" + cdrData.getFinalCalledPartyNumber() + "' contains invalid characters (PHP: _ESPERABA_NUMERO).");
            if (primaryErrorType == null) primaryErrorType = QuarantineErrorType.INVALID_NUMBER_FORMAT;
        }

        if (cdrData.getDurationSeconds() == null || cdrData.getDurationSeconds() < 0) {
            errorMessages.add("Invalid call duration: " + cdrData.getDurationSeconds() + " (PHP: _ESPERABA_NUMEROPOS).");
            if (primaryErrorType == null) primaryErrorType = QuarantineErrorType.INVALID_DURATION;
        } else {
            if (cdrData.getDurationSeconds() < appConfigService.getMinCallDurationForTariffing()) {
                if (appConfigService.getMinCallDurationForTariffing() > 0) {
                    warningMessages.add("Call duration " + cdrData.getDurationSeconds() + "s is less than minimum " + appConfigService.getMinCallDurationForTariffing() + "s (PHP: _TIEMPONO Min).");
                    if (primaryWarningType == null) primaryWarningType = QuarantineErrorType.INVALID_DURATION;
                }
            }
            if (appConfigService.getMaxCallDurationSeconds() > 0 && cdrData.getDurationSeconds() > appConfigService.getMaxCallDurationSeconds()) {
                warningMessages.add("Call duration " + cdrData.getDurationSeconds() + "s exceeds maximum allowed " + appConfigService.getMaxCallDurationSeconds() + "s (PHP: _TIEMPONO Max).");
                if (primaryWarningType == null) primaryWarningType = QuarantineErrorType.INVALID_DURATION;
            }
        }

        if (cdrData.isMarkedForQuarantine() && cdrData.getQuarantineReason() != null &&
                cdrData.getQuarantineStep() != null && cdrData.getQuarantineStep().startsWith("evaluateFormat")) {
            if (errorMessages.isEmpty()) {
                errorMessages.add("Marked for quarantine by parser: " + cdrData.getQuarantineReason());
            }
        }

        if (!errorMessages.isEmpty()) {
            cdrData.setMarkedForQuarantine(true);
            if (cdrData.getQuarantineReason() == null || !cdrData.getQuarantineReason().startsWith("Marked for quarantine by parser:")) {
                cdrData.setQuarantineReason(String.join("; ", errorMessages));
            }
            if (cdrData.getQuarantineStep() == null || !cdrData.getQuarantineStep().startsWith("evaluateFormat")) {
                cdrData.setQuarantineStep(primaryErrorType != null ? primaryErrorType.name() : QuarantineErrorType.INITIAL_VALIDATION_ERROR.name());
            }
            log.debug("CDR validation errors: {}. Quarantine set.", errorMessages);
            return false;
        } else if (!warningMessages.isEmpty()) {
            cdrData.setMarkedForQuarantine(true);
            cdrData.setQuarantineReason(String.join("; ", warningMessages));
            cdrData.setQuarantineStep(primaryWarningType != null ? primaryWarningType.name() : QuarantineErrorType.INITIAL_VALIDATION_WARNING.name());
            log.debug("CDR validation warnings (leading to quarantine): {}. Quarantine set.", warningMessages);
            return true;
        }

        log.debug("CDR data passed initial validation without errors or quarantinable warnings.");
        return true;
    }
}

============================================================
FILE: CiscoCm60CdrProcessor.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/CiscoCm60CdrProcessor.java
SIZE: 27.45 KB
MODIFIED: 2026-02-27 10:52:12
============================================================
// File: com/infomedia/abacox/telephonypricing/component/cdrprocessing/CiscoCm60CdrProcessor.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.CommunicationLocation;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.*;

@Component("ciscoCm60Processor")
@Log4j2
@RequiredArgsConstructor
public class CiscoCm60CdrProcessor implements CdrProcessor {

    // Now a list to support multiple identifiers
    public static final List<Long> PLANT_TYPE_IDENTIFIERS = List.of(26L, 56L);
    private static final String INTERNAL_CDR_RECORD_TYPE_HEADER_KEY = "cdrrecordtype";
    private static final String CDR_SEPARATOR = ",";
    private static final String DEFAULT_CONFERENCE_IDENTIFIER_PREFIX = "b";

    // Stateless mapping for key normalization
    private final Map<String, String> conceptualToActualHeaderMap = new HashMap<>();

    // REMOVED stateful field 'currentHeaderPositions'

    private String conferenceIdentifierActual = DEFAULT_CONFERENCE_IDENTIFIER_PREFIX;

    private static final List<String> IGNORED_AUTH_CODES = List.of("Invalid Authorization Code",
            "Invalid Authorization Level");
    private final CdrConfigService cdrConfigService;

    // --- List of fields that indicate a CMR file, not a CDR file ---
    private static final List<String> CMR_SPECIFIC_FIELDS = List.of(
            "numberPacketsSent",
            "numberOctetsSent",
            "jitter",
            "latency",
            "varVQMetrics");

    @Override
    public CdrData evaluateFormat(String cdrLine, CommunicationLocation commLocation, ExtensionLimits extensionLimits,
                                  Map<String, Integer> headerPositions) {
        // log.trace("Evaluating Cisco CM 6.0 CDR line: {}", cdrLine); // Reduce log
        // noise

        // 1. Validate Header Context
        if (headerPositions == null || headerPositions.isEmpty()
                || !headerPositions.containsKey("_max_mapped_header_index_")) {
            log.debug("Cisco CM 6.0 Headers not provided in context. Cannot process line: {}", cdrLine);
            CdrData errorData = new CdrData();
            errorData.setRawCdrLine(cdrLine);
            errorData.setMarkedForQuarantine(true);
            errorData.setQuarantineReason("Header map missing in processing context (reprocessing error?)");
            errorData.setQuarantineStep(QuarantineErrorType.MISSING_HEADER.name());
            return errorData;
        }

        List<String> fields = CdrUtil.parseCsvLine(cdrLine, CDR_SEPARATOR);
        CdrData cdrData = new CdrData();
        cdrData.setRawCdrLine(cdrLine);

        String firstField = fields.isEmpty() ? "" : fields.get(0);
        if (INTERNAL_CDR_RECORD_TYPE_HEADER_KEY.equalsIgnoreCase(firstField)) {
            return null; // Skip header in data stream
        }
        if ("INTEGER".equalsIgnoreCase(firstField)) {
            return null; // Skip definition line
        }

        // cdrRecordType=1 is a CDR, cdrRecordType=2 is a CMR. We skip CMRs.
        if ("2".equals(firstField)) {
            return null;
        }

        // Determine min expected fields from the provided map
        int minExpectedFieldsForValidCdr = headerPositions.get("_max_mapped_header_index_") + 1;

        if (fields.size() < minExpectedFieldsForValidCdr) {
            log.debug("Cisco CM 6.0 CDR line has insufficient fields ({}). Expected at least {}. Line: {}",
                    fields.size(), minExpectedFieldsForValidCdr, cdrLine);
            cdrData.setMarkedForQuarantine(true);
            cdrData.setQuarantineReason(
                    "Insufficient fields. Found " + fields.size() + ", expected " + minExpectedFieldsForValidCdr);
            cdrData.setQuarantineStep(QuarantineErrorType.INSUFFICIENT_FIELDS.name());
            return cdrData;
        }

        // --- Start of field extraction using headerPositions ---
        cdrData.setDateTimeOrigination(
                parseEpochToLocalDateTime(getFieldValue(fields, "dateTimeOrigination", headerPositions)));
        LocalDateTime dateTimeConnect = parseEpochToLocalDateTime(
                getFieldValue(fields, "dateTimeConnect", headerPositions));
        LocalDateTime dateTimeDisconnect = parseEpochToLocalDateTime(
                getFieldValue(fields, "dateTimeDisconnect", headerPositions));
        cdrData.setDurationSeconds(parseIntField(getFieldValue(fields, "durationSeconds", headerPositions)));

        int ringingTime = 0;
        if (dateTimeConnect != null && cdrData.getDateTimeOrigination() != null) {
            ringingTime = (int) java.time.Duration.between(cdrData.getDateTimeOrigination(), dateTimeConnect)
                    .getSeconds();
        } else if (dateTimeDisconnect != null && cdrData.getDateTimeOrigination() != null) {
            ringingTime = (int) java.time.Duration.between(cdrData.getDateTimeOrigination(), dateTimeDisconnect)
                    .getSeconds();
            if (cdrData.getDurationSeconds() == null || cdrData.getDurationSeconds() > 0)
                cdrData.setDurationSeconds(0);
        }
        cdrData.setRingingTimeSeconds(Math.max(0, ringingTime));
        if (cdrData.getDurationSeconds() == null)
            cdrData.setDurationSeconds(0);

        // --- Apply _NN_VALIDA logic during extraction ---
        String callingNumber = getFieldValue(fields, "callingPartyNumber", headerPositions);
        String callingPartition = getFieldValue(fields, "callingPartyNumberPartition", headerPositions).toUpperCase();
        if (callingPartition.isEmpty() && extensionLimits != null
                && CdrUtil.isPossibleExtension(callingNumber, extensionLimits)) {
            callingPartition = cdrConfigService.getNoPartitionPlaceholder();
        }
        cdrData.setCallingPartyNumber(callingNumber);
        cdrData.setCallingPartyNumberPartition(callingPartition);

        String finalCalledNumber = getFieldValue(fields, "finalCalledPartyNumber", headerPositions);
        String finalCalledPartition = getFieldValue(fields, "finalCalledPartyNumberPartition", headerPositions)
                .toUpperCase();
        if (finalCalledPartition.isEmpty() && extensionLimits != null
                && CdrUtil.isPossibleExtension(finalCalledNumber, extensionLimits)) {
            finalCalledPartition = cdrConfigService.getNoPartitionPlaceholder();
        }
        cdrData.setFinalCalledPartyNumber(finalCalledNumber);
        cdrData.setFinalCalledPartyNumberPartition(finalCalledPartition);

        String lastRedirectNumber = getFieldValue(fields, "lastRedirectDn", headerPositions);
        String lastRedirectPartition = getFieldValue(fields, "lastRedirectDnPartition", headerPositions).toUpperCase();
        if (lastRedirectPartition.isEmpty() && CdrUtil.isPossibleExtension(lastRedirectNumber, extensionLimits)) {
            lastRedirectPartition = cdrConfigService.getNoPartitionPlaceholder();
        }
        cdrData.setLastRedirectDn(lastRedirectNumber);
        cdrData.setLastRedirectDnPartition(lastRedirectPartition);

        // --- Continue with other fields ---
        cdrData.setOriginalCalledPartyNumber(getFieldValue(fields, "originalCalledPartyNumber", headerPositions));
        cdrData.setOriginalCalledPartyNumberPartition(
                getFieldValue(fields, "originalCalledPartyNumberPartition", headerPositions).toUpperCase());
        cdrData.setDestMobileDeviceName(getFieldValue(fields, "destMobileDeviceName", headerPositions).toUpperCase());
        cdrData.setFinalMobileCalledPartyNumber(getFieldValue(fields, "finalMobileCalledPartyNumber", headerPositions));

        cdrData.setOriginalFinalCalledPartyNumber(cdrData.getFinalCalledPartyNumber());
        cdrData.setOriginalFinalCalledPartyNumberPartition(cdrData.getFinalCalledPartyNumberPartition());
        cdrData.setOriginalLastRedirectDn(cdrData.getLastRedirectDn());

        cdrData.setAuthCodeDescription(getFieldValue(fields, "authCodeDescription", headerPositions));
        cdrData.setLastRedirectRedirectReason(
                parseIntField(getFieldValue(fields, "lastRedirectRedirectReason", headerPositions)));
        cdrData.setOrigDeviceName(getFieldValue(fields, "origDeviceName", headerPositions));
        cdrData.setDestDeviceName(getFieldValue(fields, "destDeviceName", headerPositions));
        cdrData.setOrigVideoCodec(getFieldValue(fields, "origVideoCodec", headerPositions));
        cdrData.setOrigVideoBandwidth(parseIntField(getFieldValue(fields, "origVideoBandwidth", headerPositions)));
        cdrData.setOrigVideoResolution(getFieldValue(fields, "origVideoResolution", headerPositions));
        cdrData.setDestVideoCodec(getFieldValue(fields, "destVideoCodec", headerPositions));
        cdrData.setDestVideoBandwidth(parseIntField(getFieldValue(fields, "destVideoBandwidth", headerPositions)));
        cdrData.setDestVideoResolution(getFieldValue(fields, "destVideoResolution", headerPositions));
        cdrData.setJoinOnBehalfOf(parseIntField(getFieldValue(fields, "joinOnBehalfOf", headerPositions)));
        cdrData.setDestCallTerminationOnBehalfOf(
                parseIntField(getFieldValue(fields, "destCallTerminationOnBehalfOf", headerPositions)));
        cdrData.setDestConversationId(parseLongField(getFieldValue(fields, "destConversationId", headerPositions)));
        cdrData.setGlobalCallIDCallId(parseLongField(getFieldValue(fields, "globalCallIDCallId", headerPositions)));

        // log.trace("Initial parsed Cisco CM 6.0 fields: {}", cdrData);

        // --- Start of Logic Block (PHP: CM_FormatoCDR after field extraction) ---

        // Handle empty finalCalledPartyNumber
        if (cdrData.getFinalCalledPartyNumber() == null || cdrData.getFinalCalledPartyNumber().isEmpty()) {
            cdrData.setFinalCalledPartyNumber(cdrData.getOriginalCalledPartyNumber());
            cdrData.setFinalCalledPartyNumberPartition(cdrData.getOriginalCalledPartyNumberPartition());
        }
        // Handle case where finalCalled differs from originalCalled (potential
        // redirect)
        else if (!Objects.equals(cdrData.getFinalCalledPartyNumber(), cdrData.getOriginalCalledPartyNumber()) &&
                cdrData.getOriginalCalledPartyNumber() != null && !cdrData.getOriginalCalledPartyNumber().isEmpty()) {
            if (!isConferenceIdentifier(cdrData.getLastRedirectDn())) {
                cdrData.setLastRedirectDn(cdrData.getOriginalCalledPartyNumber());
                cdrData.setLastRedirectDnPartition(cdrData.getOriginalCalledPartyNumberPartition());
            }
        }

        boolean isConferenceByFinalCalled = isConferenceIdentifier(cdrData.getFinalCalledPartyNumber());

        if (isConferenceByFinalCalled) {
            TransferCause confTransferCause = (cdrData.getJoinOnBehalfOf() != null && cdrData.getJoinOnBehalfOf() == 7)
                    ? TransferCause.CONFERENCE_NOW
                    : TransferCause.CONFERENCE;
            setTransferCauseIfUnset(cdrData, confTransferCause);
            cdrData.setConferenceIdentifierUsed(cdrData.getFinalCalledPartyNumber());

            // *** UPDATED LEGACY ALIGNMENT (Matching PHP include_cm.php) ***

            // Raw state from Cisco: Calling=Participant, FinalCalled=Bridge, LastRedirect=Controller
            String participant = cdrData.getCallingPartyNumber();
            String participantPartition = cdrData.getCallingPartyNumberPartition();

            String bridgeId = cdrData.getFinalCalledPartyNumber();
            String bridgePartition = cdrData.getFinalCalledPartyNumberPartition();

            String controller = cdrData.getLastRedirectDn();
            String controllerPartition = cdrData.getLastRedirectDnPartition();

            // 1. The Controller (Responsible Local Party) MUST be the Calling Party (Origin)
            // This ensures InternalCallProcessor find the local employee in 'originEmpOpt'
            cdrData.setCallingPartyNumber(controller);
            cdrData.setCallingPartyNumberPartition(controllerPartition);

            // 2. The Participant (The party being joined) becomes the Final Called Party (Destination)
            cdrData.setFinalCalledPartyNumber(participant);
            cdrData.setFinalCalledPartyNumberPartition(participantPartition);

            // 3. Store the Bridge ID in LastRedirect (Maps to FUN_TRANSFER / ACUMTOTAL_FUN_TRANSFER)
            cdrData.setLastRedirectDn(bridgeId);
            cdrData.setLastRedirectDnPartition(bridgePartition);

            CdrUtil.swapTrunks(cdrData);

            // 4. Set Direction to OUTGOING.
            // The local initiator is calling out to a participant via the bridge.
            cdrData.setCallDirection(CallDirection.OUTGOING);

        } else {
            if (isConferenceIdentifier(cdrData.getLastRedirectDn()) && setTransferCauseIfUnset(cdrData, TransferCause.CONFERENCE_END)) {
                cdrData.setConferenceIdentifierUsed(cdrData.getLastRedirectDn());
            }
        }

        // Determine call direction after potential conference swaps
        if (!isConferenceByFinalCalled) {
            // Non-conference incoming detection (External to Internal)
            boolean isCallingPartyEffectivelyExternal = !isPartitionPresent(cdrData.getCallingPartyNumberPartition()) ||
                    !CdrUtil.isPossibleExtension(cdrData.getCallingPartyNumber(), extensionLimits);
            boolean isFinalCalledPartyInternalFormat = isPartitionPresent(cdrData.getFinalCalledPartyNumberPartition())
                    && CdrUtil.isPossibleExtension(cdrData.getFinalCalledPartyNumber(), extensionLimits);
            boolean isRedirectPartyInternalFormat = isPartitionPresent(cdrData.getLastRedirectDnPartition()) &&
                    CdrUtil.isPossibleExtension(cdrData.getLastRedirectDn(), extensionLimits);

            if (isCallingPartyEffectivelyExternal && (isFinalCalledPartyInternalFormat || isRedirectPartyInternalFormat)) {
                cdrData.setCallDirection(CallDirection.INCOMING);
                CdrUtil.swapPartyNumbersOnly(cdrData);
            }
        }

        // Determine if internal
        boolean isCallingPartyInternal = isPartitionPresent(cdrData.getCallingPartyNumberPartition()) &&
                CdrUtil.isPossibleExtension(cdrData.getCallingPartyNumber(), extensionLimits);
        boolean isFinalCalledPartyInternal = isPartitionPresent(cdrData.getFinalCalledPartyNumberPartition()) &&
                CdrUtil.isPossibleExtension(cdrData.getFinalCalledPartyNumber(), extensionLimits);

        if (isCallingPartyInternal && isFinalCalledPartyInternal) {
            cdrData.setInternalCall(true);
        } else {
            cdrData.setInternalCall(false);
        }

        // Final transfer cause assignment
        boolean numberChangedByRedirect = false;
        if (cdrData.getLastRedirectDn() != null && !cdrData.getLastRedirectDn().isEmpty()) {
            if (cdrData.getCallDirection() == CallDirection.OUTGOING
                    && !Objects.equals(cdrData.getFinalCalledPartyNumber(), cdrData.getLastRedirectDn())) {
                numberChangedByRedirect = true;
            } else if (cdrData.getCallDirection() == CallDirection.INCOMING
                    && !Objects.equals(cdrData.getCallingPartyNumber(), cdrData.getLastRedirectDn())) {
                numberChangedByRedirect = true;
            }
        }

        if (numberChangedByRedirect) {
            if (cdrData.getTransferCause() == TransferCause.NONE) {
                Integer lastRedirectReason = cdrData.getLastRedirectRedirectReason();
                if (lastRedirectReason != null && lastRedirectReason > 0 && lastRedirectReason <= 16) {
                    cdrData.setTransferCause(TransferCause.NORMAL);
                } else {
                    TransferCause autoTransferCause = (cdrData.getDestCallTerminationOnBehalfOf() != null
                            && cdrData.getDestCallTerminationOnBehalfOf() == 7) ? TransferCause.PRE_CONFERENCE_NOW
                            : TransferCause.AUTO;
                    cdrData.setTransferCause(autoTransferCause);
                }
            }
        } else if (cdrData.getFinalMobileCalledPartyNumber() != null
                && !cdrData.getFinalMobileCalledPartyNumber().isEmpty()) {
            boolean numberChangedByMobileRedirect = false;
            if (cdrData.getCallDirection() == CallDirection.OUTGOING) {
                if (!Objects.equals(cdrData.getFinalCalledPartyNumber(), cdrData.getFinalMobileCalledPartyNumber())) {
                    numberChangedByMobileRedirect = true;
                    cdrData.setFinalCalledPartyNumber(cdrData.getFinalMobileCalledPartyNumber());
                    cdrData.setFinalCalledPartyNumberPartition(cdrData.getDestMobileDeviceName());
                    if (cdrData.isInternalCall()
                            && !CdrUtil.isPossibleExtension(cdrData.getFinalCalledPartyNumber(), extensionLimits)) {
                        cdrData.setInternalCall(false);
                    }
                }
            } else {
                if (!Objects.equals(cdrData.getFinalCalledPartyNumber(), cdrData.getFinalMobileCalledPartyNumber())) {
                    numberChangedByMobileRedirect = true;
                    cdrData.setFinalCalledPartyNumber(cdrData.getFinalMobileCalledPartyNumber());
                    cdrData.setFinalCalledPartyNumberPartition(cdrData.getDestMobileDeviceName());
                    cdrData.setInternalCall(false);
                }
            }
            if (numberChangedByMobileRedirect) {
                setTransferCauseIfUnset(cdrData, TransferCause.AUTO);
            }
        }

        if (isConferenceByFinalCalled &&
                cdrData.getCallingPartyNumber() != null &&
                Objects.equals(cdrData.getCallingPartyNumber(), cdrData.getFinalCalledPartyNumber())) {
            log.debug("Conference call where caller and callee are the same after all processing. Discarding CDR: {}",
                    cdrLine);
            return null;
        }
        cdrData.setEffectiveDestinationNumber(cdrData.getFinalCalledPartyNumber());
        cdrData.setOriginalFinalCalledPartyNumber(cdrData.getFinalCalledPartyNumber());

        return cdrData;
    }

    @PostConstruct
    public void initDefaultHeaderMappings() {
        conceptualToActualHeaderMap.put("callingPartyNumberPartition", "callingPartyNumberPartition".toLowerCase());
        conceptualToActualHeaderMap.put("callingPartyNumber", "callingPartyNumber".toLowerCase());
        conceptualToActualHeaderMap.put("finalCalledPartyNumberPartition",
                "finalCalledPartyNumberPartition".toLowerCase());
        conceptualToActualHeaderMap.put("finalCalledPartyNumber", "finalCalledPartyNumber".toLowerCase());
        conceptualToActualHeaderMap.put("originalCalledPartyNumberPartition",
                "originalCalledPartyNumberPartition".toLowerCase());
        conceptualToActualHeaderMap.put("originalCalledPartyNumber", "originalCalledPartyNumber".toLowerCase());
        conceptualToActualHeaderMap.put("lastRedirectDnPartition", "lastRedirectDnPartition".toLowerCase());
        conceptualToActualHeaderMap.put("lastRedirectDn", "lastRedirectDn".toLowerCase());
        conceptualToActualHeaderMap.put("destMobileDeviceName", "destMobileDeviceName".toLowerCase());
        conceptualToActualHeaderMap.put("finalMobileCalledPartyNumber", "finalMobileCalledPartyNumber".toLowerCase());
        conceptualToActualHeaderMap.put("lastRedirectRedirectReason", "lastRedirectRedirectReason".toLowerCase());
        conceptualToActualHeaderMap.put("dateTimeOrigination", "dateTimeOrigination".toLowerCase());
        conceptualToActualHeaderMap.put("dateTimeConnect", "dateTimeConnect".toLowerCase());
        conceptualToActualHeaderMap.put("dateTimeDisconnect", "dateTimeDisconnect".toLowerCase());
        conceptualToActualHeaderMap.put("origDeviceName", "origDeviceName".toLowerCase());
        conceptualToActualHeaderMap.put("destDeviceName", "destDeviceName".toLowerCase());
        conceptualToActualHeaderMap.put("origVideoCodec", "origVideoCap_Codec".toLowerCase());
        conceptualToActualHeaderMap.put("origVideoBandwidth", "origVideoCap_Bandwidth".toLowerCase());
        conceptualToActualHeaderMap.put("origVideoResolution", "origVideoCap_Resolution".toLowerCase());
        conceptualToActualHeaderMap.put("destVideoCodec", "destVideoCap_Codec".toLowerCase());
        conceptualToActualHeaderMap.put("destVideoBandwidth", "destVideoCap_Bandwidth".toLowerCase());
        conceptualToActualHeaderMap.put("destVideoResolution", "destVideoCap_Resolution".toLowerCase());
        conceptualToActualHeaderMap.put("joinOnBehalfOf", "joinOnBehalfOf".toLowerCase());
        conceptualToActualHeaderMap.put("destCallTerminationOnBehalfOf", "destCallTerminationOnBehalfOf".toLowerCase());
        conceptualToActualHeaderMap.put("destConversationId", "destConversationId".toLowerCase());
        conceptualToActualHeaderMap.put("globalCallIDCallId", "globalCallID_callId".toLowerCase());
        conceptualToActualHeaderMap.put("durationSeconds", "duration".toLowerCase());
        conceptualToActualHeaderMap.put("authCodeDescription", "authCodeDescription".toLowerCase());
        this.conferenceIdentifierActual = DEFAULT_CONFERENCE_IDENTIFIER_PREFIX.toUpperCase();
    }

    @Override
    public boolean isHeaderLine(String line) {
        if (line == null || line.isEmpty())
            return false;
        List<String> fields = CdrUtil.parseCsvLine(line, CDR_SEPARATOR);
        return !fields.isEmpty() && INTERNAL_CDR_RECORD_TYPE_HEADER_KEY.equalsIgnoreCase(fields.get(0));
    }

    @Override
    public Map<String, Integer> parseHeader(String headerLine) {
        Map<String, Integer> map = new HashMap<>();
        List<String> headers = CdrUtil.parseCsvLine(headerLine, CDR_SEPARATOR);
        int maxIndex = -1;
        for (int i = 0; i < headers.size(); i++) {
            String actualHeaderFromFile = headers.get(i).toLowerCase();
            map.put(actualHeaderFromFile, i);
            if (conceptualToActualHeaderMap.containsValue(actualHeaderFromFile)) {
                if (i > maxIndex)
                    maxIndex = i;
            }
        }
        map.put("_max_mapped_header_index_", maxIndex);
        log.debug("Parsed Cisco CM 6.0 headers. Mapped positions count: {}. Min expected fields: {}", map.size(),
                maxIndex + 1);
        return map;
    }

    private String getFieldValue(List<String> fields, String conceptualFieldName,
                                 Map<String, Integer> headerPositions) {
        String actualHeaderName = conceptualToActualHeaderMap.getOrDefault(conceptualFieldName,
                conceptualFieldName.toLowerCase());
        Integer position = headerPositions.get(actualHeaderName);
        if (position == null)
            position = headerPositions.get(conceptualFieldName.toLowerCase());

        if (position != null && position >= 0 && position < fields.size()) {
            String rawValue = fields.get(position);
            if (rawValue == null)
                return "";
            if (actualHeaderName.contains("ipaddr") || actualHeaderName.contains("address_ip")) {
                try {
                    if (!rawValue.isEmpty() && !rawValue.equals("0") && !rawValue.equals("-1")) {
                        return CdrUtil.decimalToIp(Long.parseLong(rawValue));
                    }
                    return rawValue;
                } catch (NumberFormatException e) {
                    log.debug("Failed to parse IP address from decimal: {} for header {}", rawValue, actualHeaderName);
                    return rawValue;
                }
            }
            return rawValue;
        }
        return "";
    }

    private LocalDateTime parseEpochToLocalDateTime(String epochSecondsStr) {
        if (epochSecondsStr == null || epochSecondsStr.isEmpty() || "0".equals(epochSecondsStr))
            return null;
        try {
            long epochSeconds = Long.parseLong(epochSecondsStr);
            return epochSeconds > 0 ? DateTimeUtil.epochSecondsToLocalDateTime(epochSeconds) : null;
        } catch (NumberFormatException e) {
            log.debug("Failed to parse epoch seconds: {}", epochSecondsStr, e);
            return null;
        }
    }

    private Integer parseIntField(String valueStr) {
        if (valueStr == null || valueStr.isEmpty())
            return 0;
        try {
            return Integer.parseInt(valueStr);
        } catch (NumberFormatException e) {
            log.trace("Failed to parse integer: {}", valueStr);
            return 0;
        }
    }

    private Long parseLongField(String valueStr) {
        if (valueStr == null || valueStr.isEmpty())
            return 0L;
        try {
            return Long.parseLong(valueStr);
        } catch (NumberFormatException e) {
            log.trace("Failed to parse long: {}", valueStr);
            return 0L;
        }
    }

    private boolean isPartitionPresent(String partition) {
        return partition != null && !partition.isEmpty();
    }

    private boolean setTransferCauseIfUnset(CdrData cdrData, TransferCause cause) {
        if (cdrData.getTransferCause() == null || cdrData.getTransferCause() == TransferCause.NONE) {
            cdrData.setTransferCause(cause);
            return true;
        }
        return cdrData.getTransferCause() == cause;
    }

    @Override
    public List<Long> getPlantTypeIdentifiers() {
        return PLANT_TYPE_IDENTIFIERS;
    }

    private boolean isConferenceIdentifier(String number) {
        if (number == null || number.isEmpty() || conferenceIdentifierActual == null
                || conferenceIdentifierActual.isEmpty()) {
            return false;
        }
        String prefix = conferenceIdentifierActual;
        String numUpper = number.toUpperCase();
        if (numUpper.startsWith(prefix)) {
            String rest = numUpper.substring(prefix.length());
            return !rest.isEmpty() && rest.matches("\\d+");
        }
        return false;
    }

    @Override
    public List<String> getIgnoredAuthCodeDescriptions() {
        return IGNORED_AUTH_CODES;
    }

    @Override
    public boolean probe(List<String> initialLines) {
        if (initialLines == null || initialLines.isEmpty()) {
            return false;
        }
        for (String line : initialLines) {
            if (isHeaderLine(line)) {
                List<String> headers = CdrUtil.parseCsvLine(line, CDR_SEPARATOR);

                // Reject if it contains CMR-specific fields
                boolean isCmr = headers.stream()
                        .anyMatch(h -> CMR_SPECIFIC_FIELDS.stream().anyMatch(cmrField -> cmrField.equalsIgnoreCase(h)));
                if (isCmr) {
                    log.warn(
                            "Detected CMR format based on presence of CMR-specific fields. This file will be rejected by this processor.");
                    return false; // This is a CMR file, reject it.
                }
                // If it's a header and not a CMR, it's a valid CDR file for this processor.
                return true;
            }
        }
        // No header line was found in the initial lines, so we cannot validate the
        // format.
        return false;
    }
}

============================================================
FILE: CleanPhoneNumberResult.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/CleanPhoneNumberResult.java
SIZE: 0.28 KB
MODIFIED: 2025-06-05 14:22:45
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class CleanPhoneNumberResult {
    private final String cleanedNumber;
    private final boolean pbxPrefixStripped;
}

============================================================
FILE: CommunicationLocationLookupService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/CommunicationLocationLookupService.java
SIZE: 11.23 KB
MODIFIED: 2026-02-25 10:33:50
============================================================
// File: com/infomedia/abacox/telephonypricing/component/cdrprocessing/CommunicationLocationLookupService.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.CommunicationLocation;
import jakarta.persistence.EntityManager;
import jakarta.persistence.NoResultException;
import jakarta.persistence.PersistenceContext;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
@Log4j2
public class CommunicationLocationLookupService {

    @PersistenceContext
    private EntityManager entityManager;

    @Transactional(readOnly = true)
    public Optional<CommunicationLocation> findById(Long commLocationId) {
        try {
            CommunicationLocation cl = entityManager.find(CommunicationLocation.class, commLocationId);
            return Optional.ofNullable(cl);
        } catch (NoResultException e) {
            return Optional.empty();
        }
    }

    /**
     * Determines the best CommunicationLocation for a CDR based on its identifying
     * fields.
     * This mimics parts of PHP's hc_cisco_cm.php (buscarExtensiones,
     * buscarPlantaDestino)
     * but scoped to a single client's CommunicationLocations.
     *
     * @param plantTypeId                     The plantType of the CDR source (e.g., Cisco CM 6.0)
     * @param callingPartyNumber              From CDR
     * @param callingPartyNumberPartition     From CDR
     * @param finalCalledPartyNumber          From CDR
     * @param finalCalledPartyNumberPartition From CDR
     * @param lastRedirectDn                  From CDR
     * @param lastRedirectDnPartition         From CDR
     * @param callDateTime                    For historical context evaluation
     * @return Optional<CommunicationLocation>
     */
    @Transactional(readOnly = true)
    public Optional<CommunicationLocation> findBestCommunicationLocation(
            Long plantTypeId,
            String callingPartyNumber, String callingPartyNumberPartition,
            String finalCalledPartyNumber, String finalCalledPartyNumberPartition,
            String lastRedirectDn, String lastRedirectDnPartition,
            LocalDateTime callDateTime) {

        log.debug("Finding best CommLocation for PlantType: {}, Calling: {}[{}], Final: {}[{}], Redirect: {}[{}]",
                plantTypeId, callingPartyNumber, callingPartyNumberPartition,
                finalCalledPartyNumber, finalCalledPartyNumberPartition,
                lastRedirectDn, lastRedirectDnPartition);

        // Priority:
        // 1. Calling Party (if it's a known extension in one of our CommLocations)
        // 2. Final Called Party (if it's a known extension)
        // 3. Last Redirect DN (if it's a known extension)

        Optional<CommunicationLocation> commLocationOpt;

        // Check Calling Party
        if (callingPartyNumber != null && !callingPartyNumber.isEmpty()) {
            commLocationOpt = findCommLocationByExtension(plantTypeId, callingPartyNumber, callingPartyNumberPartition,
                    callDateTime);
            if (commLocationOpt.isPresent()) {
                log.debug("Routed by CallingParty: {} -> CommLocation ID: {}", callingPartyNumber,
                        commLocationOpt.get().getId());
                return commLocationOpt;
            }
        }

        // Check Final Called Party
        if (finalCalledPartyNumber != null && !finalCalledPartyNumber.isEmpty()) {
            commLocationOpt = findCommLocationByExtension(plantTypeId, finalCalledPartyNumber,
                    finalCalledPartyNumberPartition, callDateTime);
            if (commLocationOpt.isPresent()) {
                log.debug("Routed by FinalCalledParty: {} -> CommLocation ID: {}", finalCalledPartyNumber,
                        commLocationOpt.get().getId());
                return commLocationOpt;
            }
        }

        // Check Last Redirect DN
        if (lastRedirectDn != null && !lastRedirectDn.isEmpty()) {
            commLocationOpt = findCommLocationByExtension(plantTypeId, lastRedirectDn, lastRedirectDnPartition,
                    callDateTime);
            if (commLocationOpt.isPresent()) {
                log.debug("Routed by LastRedirectDN: {} -> CommLocation ID: {}", lastRedirectDn,
                        commLocationOpt.get().getId());
                return commLocationOpt;
            }
        }

        // Fallback: If no specific match, and there's only ONE active
        // CommunicationLocation for this plantType, use it.
        // This mimics PHP's behavior where if a client has only one plant, CDRs might default to it.
        List<CommunicationLocation> activeCommLocationsForPlantType = findActiveCommLocationsByPlantType(plantTypeId);
        if (activeCommLocationsForPlantType.size() == 1) {
            log.debug(
                    "No specific extension match. Defaulting to the single active CommLocation ID: {} for PlantType: {}",
                    activeCommLocationsForPlantType.get(0).getId(), plantTypeId);
            return Optional.of(activeCommLocationsForPlantType.get(0));
        } else if (activeCommLocationsForPlantType.isEmpty()) {
            log.debug("No active CommunicationLocation found for PlantType ID: {}", plantTypeId);
        } else {
            log.debug(
                    "Multiple ({}) active CommunicationLocations found for PlantType ID: {} and no specific extension match. Cannot uniquely determine CommLocation.",
                    activeCommLocationsForPlantType.size(), plantTypeId);
        }

        return Optional.empty();
    }

    private Optional<CommunicationLocation> findCommLocationByExtension(
            Long plantTypeId, String extensionNumber, String partitionName, LocalDateTime callDateTime) {

        // PHP Fallback: if ($fecha_segundos <= 0) { $fecha_segundos = time(); }
        if (callDateTime == null) {
            callDateTime = LocalDateTime.now();
        }

        if (extensionNumber == null || extensionNumber.isEmpty()) {
            return Optional.empty();
        }
        String cleanedExtension = CdrUtil.cleanPhoneNumber(extensionNumber, null, false).getCleanedNumber();
        if (cleanedExtension.startsWith("+"))
            cleanedExtension = cleanedExtension.substring(1);

        // 1. Try direct Employee lookup by extension
        StringBuilder empQueryBuilder = new StringBuilder(
                "SELECT cl.* FROM communication_location cl " +
                        "JOIN employee e ON e.communication_location_id = cl.id " +
                        "WHERE cl.active = true AND cl.plant_type_id = :plantTypeId " +
                        "AND e.extension = :extension ");
        
        // Emulate PHP's ValidarFechasHistorico & Obtener_HistoricoHasta logic efficiently in SQL:
        // "Match where history_since <= callDate AND there is NO newer record in the same history_control_id group that is ALSO <= callDate"
        empQueryBuilder.append("AND (e.history_since IS NULL OR e.history_since <= :callDateTime) ");
        empQueryBuilder.append("AND (e.history_control_id IS NULL OR NOT EXISTS ( ");
        empQueryBuilder.append("    SELECT 1 FROM employee e2 ");
        empQueryBuilder.append("    WHERE e2.history_control_id = e.history_control_id ");
        empQueryBuilder.append("      AND e2.history_since > e.history_since ");
        empQueryBuilder.append("      AND e2.history_since <= :callDateTime ");
        empQueryBuilder.append(")) ");
        empQueryBuilder.append("ORDER BY e.history_since DESC NULLS LAST LIMIT 1");

        jakarta.persistence.Query empQuery = entityManager.createNativeQuery(empQueryBuilder.toString(),
                CommunicationLocation.class);
        empQuery.setParameter("plantTypeId", plantTypeId);
        empQuery.setParameter("extension", cleanedExtension);
        empQuery.setParameter("callDateTime", callDateTime);

        try {
            CommunicationLocation cl = (CommunicationLocation) empQuery.getSingleResult();
            log.debug("Found CommLocation ID {} via Employee extension {}", cl.getId(), cleanedExtension);
            return Optional.of(cl);
        } catch (NoResultException e) {
            // Not found via direct employee extension, try range
        }

        // 2. Try ExtensionRange lookup
        if (!cleanedExtension.matches("\\d+")) { // Ranges are numeric
            return Optional.empty();
        }
        long extNum;
        try {
            extNum = Long.parseLong(cleanedExtension);
        } catch (NumberFormatException e) {
            return Optional.empty();
        }

        StringBuilder rangeQueryBuilder = new StringBuilder(
                "SELECT cl.* FROM communication_location cl " +
                        "JOIN extension_range er ON er.comm_location_id = cl.id " +
                        "WHERE cl.active = true AND cl.plant_type_id = :plantTypeId " +
                        "AND er.range_start <= :extNum AND er.range_end >= :extNum ");
        
        // Replicate PHP historical limit validation for ranges
        rangeQueryBuilder.append("AND (er.history_since IS NULL OR er.history_since <= :callDateTime) ");
        rangeQueryBuilder.append("AND (er.history_control_id IS NULL OR NOT EXISTS ( ");
        rangeQueryBuilder.append("    SELECT 1 FROM extension_range er2 ");
        rangeQueryBuilder.append("    WHERE er2.history_control_id = er.history_control_id ");
        rangeQueryBuilder.append("      AND er2.history_since > er.history_since ");
        rangeQueryBuilder.append("      AND er2.history_since <= :callDateTime ");
        rangeQueryBuilder.append(")) ");
        rangeQueryBuilder.append("ORDER BY (er.range_end - er.range_start) ASC, er.history_since DESC NULLS LAST LIMIT 1");
        
        jakarta.persistence.Query rangeQuery = entityManager.createNativeQuery(rangeQueryBuilder.toString(),
                CommunicationLocation.class);
        rangeQuery.setParameter("plantTypeId", plantTypeId);
        rangeQuery.setParameter("extNum", extNum);
        rangeQuery.setParameter("callDateTime", callDateTime);

        try {
            CommunicationLocation cl = (CommunicationLocation) rangeQuery.getSingleResult();
            log.debug("Found CommLocation ID {} via ExtensionRange for extension {}", cl.getId(), cleanedExtension);
            return Optional.of(cl);
        } catch (NoResultException e) {
            log.debug("Extension {} not found in direct Employee lookup or ExtensionRange for plantType {}",
                    cleanedExtension, plantTypeId);
            return Optional.empty();
        }
    }

    @Transactional(readOnly = true)
    public List<CommunicationLocation> findActiveCommLocationsByPlantType(Long plantTypeId) {
        String queryStr = "SELECT cl.* FROM communication_location cl " +
                "WHERE cl.active = true AND cl.plant_type_id = :plantTypeId";
        return entityManager.createNativeQuery(queryStr, CommunicationLocation.class)
                .setParameter("plantTypeId", plantTypeId)
                .getResultList();
    }
}

============================================================
FILE: DateTimeUtil.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/DateTimeUtil.java
SIZE: 3.6 KB
MODIFIED: 2026-02-25 13:26:53
============================================================
// File: com/infomedia/abacox/telephonypricing/cdr/DateTimeUtil.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId; // Added
import java.time.ZoneOffset;
import java.time.ZonedDateTime; // Added
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import lombok.extern.log4j.Log4j2; // Added

@Log4j2 // Added
public class DateTimeUtil {

    private static final List<DateTimeFormatter> CME_DATE_FORMATTERS = Arrays.asList(
            DateTimeFormatter.ofPattern("HH:mm:ss.SSS zz E MMM dd yyyy", Locale.ENGLISH),
            DateTimeFormatter.ofPattern("HH:mm:ss.SSS z E MMM dd yyyy", Locale.ENGLISH),
            DateTimeFormatter.ofPattern("HH:mm:ss.SSS X E MMM dd yyyy", Locale.ENGLISH)
    );


    public static LocalDateTime epochSecondsToLocalDateTime(long epochSeconds) {
        // Converts the absolute UTC epoch into the pinned local timezone
        return LocalDateTime.ofInstant(Instant.ofEpochSecond(epochSeconds), ZoneId.systemDefault());
    }

    public static long localDateTimeToEpochSeconds(LocalDateTime ldt) {
        if (ldt == null) return 0L;
        // Converts the local time back to an absolute epoch
        return ldt.atZone(ZoneId.systemDefault()).toEpochSecond();
    }

    public static LocalDateTime parseCmeDateTime(String cmeDateTimeString) {
        if (cmeDateTimeString == null || cmeDateTimeString.trim().isEmpty()) {
            return null;
        }
        for (DateTimeFormatter formatter : CME_DATE_FORMATTERS) {
            try {
                String parsableString = cmeDateTimeString.replace(" CO ", " -0500 ");
                return LocalDateTime.parse(parsableString, formatter);
            } catch (DateTimeParseException e) {
                // Try next formatter
            }
        }
        try {
            long epochSeconds = Long.parseLong(cmeDateTimeString);
            return epochSecondsToLocalDateTime(epochSeconds);
        } catch (NumberFormatException nfe) {
            log.debug("Could not parse CME date-time string: {}", cmeDateTimeString);
        }
        return null;
    }

    public static LocalDateTime stringToLocalDateTime(String dateTimeStr) {
        if (dateTimeStr == null || dateTimeStr.isEmpty()) return null;
        try {
            return LocalDateTime.parse(dateTimeStr, DateTimeFormatter.ISO_LOCAL_DATE_TIME);
        } catch (DateTimeParseException e1) {
            try {
                return LocalDateTime.parse(dateTimeStr, DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
            } catch (DateTimeParseException e2) {
                try {
                    long epochSeconds = Long.parseLong(dateTimeStr);
                    return epochSecondsToLocalDateTime(epochSeconds);
                } catch (NumberFormatException e3) {
                    log.debug("Failed to parse date-time string: {}", dateTimeStr);
                    return null;
                }
            }
        }
    }

    // New method for timezone conversion
    public static LocalDateTime convertToZone(LocalDateTime utcDateTime, ZoneId targetZoneId) {
        if (utcDateTime == null || targetZoneId == null) {
            return utcDateTime; // Or handle error appropriately
        }
        ZonedDateTime zdtUtc = utcDateTime.atZone(ZoneOffset.UTC);
        ZonedDateTime zdtTarget = zdtUtc.withZoneSameInstant(targetZoneId);
        return zdtTarget.toLocalDateTime();
    }
}

============================================================
FILE: DestinationInfo.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/DestinationInfo.java
SIZE: 3.42 KB
MODIFIED: 2025-08-28 14:37:24
============================================================
// File: com/infomedia/abacox/telephonypricing/cdr/DestinationInfo.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.extern.log4j.Log4j2;

import java.math.BigInteger;

@AllArgsConstructor
@Data
@NoArgsConstructor
@Log4j2
public class DestinationInfo {
    public String matchedPhoneNumber; // The phone number part that was used for matching against series (NDC + subscriber)
    public Long indicatorId;
    public String ndc; // The NDC part from the database series record
    public String destinationDescription;
    public Long operatorId; // Operator ID from the Indicator record
    public Long prefixId; // Prefix ID from the calling function (PrefixInfo.prefixId)
    public Long bandId;
    public boolean isApproximateMatch;

    // Store the original series values for reference
    public Integer seriesInitial;
    public Integer seriesFinal;

    // Store the fully constructed and padded comparable values
    // These will be like "NDC" + "padded_series_initial_subscriber_part"
    private String comparableInitialValue;
    private String comparableFinalValue;

    public long getPaddedSeriesRangeSize() {
        if (comparableInitialValue == null || comparableFinalValue == null) {
            return Long.MAX_VALUE;
        }
        try {
            // Use BigInteger for safety with potentially long phone numbers
            // Ensure strings are purely numeric before BigInteger conversion
            if (!comparableInitialValue.matches("\\d*") || !comparableFinalValue.matches("\\d*")) {
                log.debug("Non-numeric comparableInitialValue ('{}') or comparableFinalValue ('{}') for range size calculation.", comparableInitialValue, comparableFinalValue);
                // Handle cases where NDC might be non-numeric (e.g. negative for approximate)
                // or padding resulted in non-numeric, though it shouldn't.
                // If they are not numeric, a simple length comparison or default max might be better.
                // For now, if non-numeric, assume largest range to push it down in sort.
                if (comparableInitialValue.isEmpty() && comparableFinalValue.isEmpty()) return 0; // Empty range
                return Long.MAX_VALUE;
            }
            if (comparableInitialValue.isEmpty() && !comparableFinalValue.isEmpty()) return Long.MAX_VALUE;
            if (!comparableInitialValue.isEmpty() && comparableFinalValue.isEmpty()) return Long.MAX_VALUE;
            if (comparableInitialValue.isEmpty() && comparableFinalValue.isEmpty()) return 0;


            BigInteger initial = new BigInteger(comparableInitialValue);
            BigInteger finalVal = new BigInteger(comparableFinalValue);
            return finalVal.subtract(initial).longValueExact();
        } catch (NumberFormatException e) {
            log.debug("NumberFormatException during getPaddedSeriesRangeSize for initial='{}', final='{}'. Returning MAX_VALUE.", comparableInitialValue, comparableFinalValue, e);
            return Long.MAX_VALUE;
        } catch (ArithmeticException e) {
            log.debug("ArithmeticException (likely longValueExact overflow) during getPaddedSeriesRangeSize for initial='{}', final='{}'. Returning MAX_VALUE.", comparableInitialValue, comparableFinalValue, e);
            return Long.MAX_VALUE;
        }
    }
}

============================================================
FILE: EmployeeLookupService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/EmployeeLookupService.java
SIZE: 22.61 KB
MODIFIED: 2026-02-25 13:25:15
============================================================
// File: com/infomedia/abacox/telephonypricing/component/cdrprocessing/EmployeeLookupService.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.CommunicationLocation;
import com.infomedia.abacox.telephonypricing.db.entity.Employee;
import com.infomedia.abacox.telephonypricing.db.entity.ExtensionRange;
import com.infomedia.abacox.telephonypricing.db.entity.HistoricalEntity;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.Query;
import jakarta.persistence.Tuple;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;

@Service
@Log4j2
@RequiredArgsConstructor
public class EmployeeLookupService {

     @PersistenceContext
    private EntityManager entityManager;
    private final CdrConfigService cdrConfigService;

    @FunctionalInterface
    private interface HistorySliceConsumer<T> {
        void accept(T entity, long fdesde, long fhasta);
    }

    @SuppressWarnings("unchecked")
    public HistoricalDataContainer prefetchHistoricalData(Set<String> extensions, Set<String> authCodes) {
        log.debug("Pre-fetching historical data for {} extensions and {} auth codes", extensions.size(), authCodes.size());

        HistoricalDataContainer container = new HistoricalDataContainer();
        boolean isGlobalExt = cdrConfigService.areExtensionsGlobal();
        boolean isGlobalAuth = cdrConfigService.areAuthCodesGlobal();

        Set<String> cleanedExtensions = extensions.stream()
                .filter(Objects::nonNull)
                .map(CdrUtil::cleanExtension)
                .collect(Collectors.toSet());

        Set<String> validAuthCodes = authCodes.stream()
                .filter(Objects::nonNull)
                .filter(ac -> !ac.trim().isEmpty())
                .collect(Collectors.toSet());

        // --- 1. Fetch Employees ---
        if (!cleanedExtensions.isEmpty() || !validAuthCodes.isEmpty()) {
            String fetchAllQuery = 
                "SELECT e.* FROM employee e " +
                "WHERE e.extension IN (:extensions) OR e.auth_code IN (:authCodes) " +
                "   OR (e.history_control_id IS NOT NULL AND e.history_control_id IN ( " +
                "       SELECT e2.history_control_id FROM employee e2 " +
                "       WHERE e2.extension IN (:extensions) OR e2.auth_code IN (:authCodes) " +
                "   )) " +
                "ORDER BY e.history_control_id, e.history_since DESC";
            jakarta.persistence.Query fetchQuery = entityManager.createNativeQuery(fetchAllQuery, Employee.class);
            fetchQuery.setParameter("extensions", cleanedExtensions.isEmpty() ? Collections.singleton("-1") : cleanedExtensions);
            fetchQuery.setParameter("authCodes", validAuthCodes.isEmpty() ? Collections.singleton("-1") : validAuthCodes);

            List<Employee> allVersions = fetchQuery.getResultList();

            processHistorySlices(allVersions, (emp, fdesde, fhasta) -> {
                if (emp.getExtension() != null && !emp.getExtension().isEmpty()) {
                    String ext = CdrUtil.cleanExtension(emp.getExtension());
                    container.addEmployeeExtensionSlice(ext, emp, fdesde, fhasta, isGlobalExt);
                }
                if (emp.getAuthCode() != null && !emp.getAuthCode().isEmpty()) {
                    container.addEmployeeAuthCodeSlice(emp.getAuthCode(), emp, fdesde, fhasta, isGlobalAuth);
                }
            });
        }

        // --- 2. Fetch Extension Ranges ---
        // Ensuring only active communication location ranges are prefetched.
        String fetchRangesQuery = "SELECT er.* FROM extension_range er " +
                                  "JOIN communication_location cl ON er.comm_location_id = cl.id " +
                                  "WHERE cl.active = true " +
                                  "ORDER BY er.history_since DESC";
        List<ExtensionRange> allRanges = entityManager.createNativeQuery(fetchRangesQuery, ExtensionRange.class).getResultList();

        processHistorySlices(allRanges, (range, fdesde, fhasta) -> {
            container.addRangeSlice(range.getCommLocationId(), range, fdesde, fhasta);
        });

        return container;
    }

    /**
     * Calculates the fhasta (end date) for historical groups just like PHP's Obtener_HistoricoHasta_Listado
     */
    private <T extends HistoricalEntity> void processHistorySlices(List<T> entities, HistorySliceConsumer<T> consumer) {
        // Group by history control id
        Map<Long, List<T>> grouped = entities.stream()
                .filter(e -> e.getHistoryControlId() != null)
                .collect(Collectors.groupingBy(HistoricalEntity::getHistoryControlId));

        // Process entities WITH history control ID
        for (List<T> group : grouped.values()) {
            group.sort(Comparator.comparing(HistoricalEntity::getHistorySince, Comparator.nullsLast(Comparator.reverseOrder())));
            long nextFdesde = -1;

            for (T entity : group) {
                long fdesde = entity.getHistorySince() != null ? 
                        entity.getHistorySince().truncatedTo(ChronoUnit.DAYS).atZone(ZoneId.systemDefault()).toEpochSecond() : 0;
                long fhasta = -1; // -1 means open/no limit

                if (nextFdesde != -1) {
                    fhasta = nextFdesde - 1;
                }

                consumer.accept(entity, fdesde, fhasta);
                nextFdesde = fdesde;
            }
        }

        // Process entities WITHOUT history control ID (Standalone records)
        entities.stream()
                .filter(e -> e.getHistoryControlId() == null)
                .forEach(e -> {
                    long fdesde = e.getHistorySince() != null ? 
                            e.getHistorySince().atZone(ZoneId.systemDefault()).toEpochSecond() : 0;
                    consumer.accept(e, fdesde, -1L);
                });
    }

    @Transactional
    public Optional<Employee> findEmployeeByExtensionOrAuthCode(String extension, String authCode,
            Long commLocationIdContext, List<String> ignoredAuthCodeDescriptions,
            Map<Long, List<ExtensionRange>> fallbackExtensionRanges, LocalDateTime callTimestamp,
            HistoricalDataContainer historicalData) {

        // --- 1. Preparation ---
        boolean hasAuthCode = authCode != null && !authCode.isEmpty();
        String cleanedExtension = (extension != null) ? CdrUtil.cleanPhoneNumber(extension, null, false).getCleanedNumber() : null;
        if (cleanedExtension != null && cleanedExtension.startsWith("+")) {
            cleanedExtension = cleanedExtension.substring(1);
        }
        boolean hasExtension = cleanedExtension != null && !cleanedExtension.isEmpty();

        boolean isAuthCodeIgnoredType = hasAuthCode && ignoredAuthCodeDescriptions.stream().anyMatch(ignored -> ignored.equalsIgnoreCase(authCode));
        String validAuthCode = (hasAuthCode && !isAuthCodeIgnoredType) ? authCode : null;

        // Ensure fallback defaults to the moment of evaluation if timestamp is absent.
        long callTimestampEpoch = callTimestamp != null ? 
                callTimestamp.atZone(ZoneId.systemDefault()).toEpochSecond() : 
                Instant.now().getEpochSecond();

        // --- 2. Lazy Load Historical Data (For Synchronous Processing) ---
        if (historicalData == null) {
            Set<String> extsToFetch = hasExtension ? Collections.singleton(cleanedExtension) : Collections.emptySet();
            Set<String> authsToFetch = validAuthCode != null ? Collections.singleton(validAuthCode) : Collections.emptySet();
            historicalData = prefetchHistoricalData(extsToFetch, authsToFetch);
        }

        // --- 3. Lookup Auth Code ---
        if (validAuthCode != null) {
            HistoricalDataContainer.ResolvedTimeline authTimeline = historicalData.getAuthCodeTimelines().get(validAuthCode);
            if (authTimeline != null) {
                Optional<Employee> match = authTimeline.findMatch(callTimestampEpoch, commLocationIdContext);
                if (match.isPresent()) {
                    log.debug("Found employee via AuthCode timeline: {}", match.get().getId());
                    return match;
                }
            }
        }

        // --- 4. Lookup Extension Fallback ---
        if (hasExtension) {
            HistoricalDataContainer.ResolvedTimeline extTimeline = historicalData.getExtensionTimelines().get(cleanedExtension);
            if (extTimeline != null) {
                Optional<Employee> match = extTimeline.findMatch(callTimestampEpoch, commLocationIdContext);
                if (match.isPresent()) {
                    log.debug("Found employee via Extension timeline: {}", match.get().getId());
                    return match;
                }
            }
        }

        // --- 5. Range Lookup (Conceptual Employee) ---
        boolean phpExtensionValida = hasExtension && (!cleanedExtension.startsWith("0") || cleanedExtension.equals("0")) && cleanedExtension.matches("^[0-9#*+]+$");

        if (phpExtensionValida) {
            Optional<Employee> conceptualEmployeeOpt = findEmployeeByExtensionRange(cleanedExtension, commLocationIdContext, fallbackExtensionRanges, callTimestamp, historicalData);
            if (conceptualEmployeeOpt.isPresent()) {
                Employee conceptualEmployee = conceptualEmployeeOpt.get();
                
                // Check if this extension is part of a managed history in the relevant context.
                // If it is (even if not valid for this specific timestamp in the timeline), 
                // we block auto-persistence to avoid creating orphan records outside the timeline.
                boolean isManagedExtension = false;
                HistoricalDataContainer.ResolvedTimeline extTimelineForCheck = historicalData.getExtensionTimelines().get(cleanedExtension);

                if (extTimelineForCheck != null) {
                    if (cdrConfigService.areExtensionsGlobal()) {
                        isManagedExtension = true;
                    } else {
                        // Only block auto-creation if the timeline actually belongs to this specific plant
                        isManagedExtension = extTimelineForCheck.getSlices().values().stream()
                                .anyMatch(slice -> Objects.equals(slice.getEmployee().getCommunicationLocationId(), commLocationIdContext));
                    }
                }

                if (conceptualEmployee.getId() == null && cdrConfigService.createEmployeesAutomaticallyFromRange()) {
                    
                    if (isManagedExtension) {
                        log.debug("Extension {} belongs to a managed history in this context. Blocking auto-creation/persistence.", cleanedExtension);
                        // Return the conceptual employee for pricing/assignment, but do NOT persist.
                        return Optional.of(conceptualEmployee);
                    }

                    log.debug("Persisting new employee for extension {} from range, CommLocation ID: {}", conceptualEmployee.getExtension(), conceptualEmployee.getCommunicationLocationId());
                    entityManager.persist(conceptualEmployee);
                    return Optional.of(conceptualEmployee);
                } else if (conceptualEmployee.getId() != null) {
                    return Optional.of(conceptualEmployee);
                }
            }
        }

        return Optional.empty();
    }

    @Transactional(readOnly = true)
    public Optional<Employee> findEmployeeByExtensionRange(String extension, Long commLocationId,
            Map<Long, List<ExtensionRange>> fallbackExtensionRanges, LocalDateTime callTimestamp,
            HistoricalDataContainer historicalData) {
            
        if (extension == null || !extension.matches("\\d+")) {
            return Optional.empty();
        }
        
        long extNum;
        try {
            extNum = Long.parseLong(extension);
        } catch (NumberFormatException e) {
            return Optional.empty();
        }


        long callTimestampEpoch = callTimestamp != null ? 
                callTimestamp.atZone(ZoneId.systemDefault()).toEpochSecond() : 
                Instant.now().getEpochSecond();

        boolean searchRangesGlobally = cdrConfigService.areExtensionsGlobal();
        
        // Lazy load for sync processing
        if (historicalData == null) {
            historicalData = prefetchHistoricalData(Collections.emptySet(), Collections.emptySet());
        }

        List<HistoricalDataContainer.RangeSlice> matchingSlices = new ArrayList<>();

        if (searchRangesGlobally) {
            // Search across all plants
            for (List<HistoricalDataContainer.RangeSlice> slices : historicalData.getRangeSlicesByCommId().values()) {
                for (HistoricalDataContainer.RangeSlice slice : slices) {
                    if (extNum >= slice.getRange().getRangeStart() && extNum <= slice.getRange().getRangeEnd()) {
                        if ((slice.getFdesde() <= 0 || slice.getFdesde() <= callTimestampEpoch) &&
                            (slice.getFhasta() <= 0 || slice.getFhasta() >= callTimestampEpoch)) {
                            matchingSlices.add(slice);
                        }
                    }
                }
            }
        } else {
            // Search strictly within the context plant
            List<HistoricalDataContainer.RangeSlice> slices = historicalData.getRangeSlicesByCommId().get(commLocationId);
            if (slices != null) {
                for (HistoricalDataContainer.RangeSlice slice : slices) {
                    if (extNum >= slice.getRange().getRangeStart() && extNum <= slice.getRange().getRangeEnd()) {
                        if ((slice.getFdesde() <= 0 || slice.getFdesde() <= callTimestampEpoch) &&
                            (slice.getFhasta() <= 0 || slice.getFhasta() >= callTimestampEpoch)) {
                            matchingSlices.add(slice);
                        }
                    }
                }
            }
        }

        if (!matchingSlices.isEmpty()) {
            // Prioritize: 1. Exact commLocation, 2. Smallest Range Size, 3. Newest
            matchingSlices.sort(Comparator
                    .comparing((HistoricalDataContainer.RangeSlice rs) -> !Objects.equals(rs.getRange().getCommLocationId(), commLocationId))
                    .thenComparingLong(rs -> rs.getRange().getRangeEnd() - rs.getRange().getRangeStart())
                    .thenComparing(rs -> rs.getRange().getCreatedDate(), Comparator.nullsLast(Comparator.reverseOrder())));

            ExtensionRange bestMatch = matchingSlices.get(0).getRange();
            log.debug("Extension {} matched range (historically): {}", extension, bestMatch.getId());
            
            Employee conceptualEmployee = createEmployeeFromRange(
                    extension,
                    bestMatch.getSubdivisionId(),
                    bestMatch.getCommLocationId(),
                    bestMatch.getPrefix()); 

            if (bestMatch.getCommLocationId() != null) {
                CommunicationLocation cl = entityManager.find(CommunicationLocation.class, bestMatch.getCommLocationId());
                conceptualEmployee.setCommunicationLocation(cl);
            }
            return Optional.of(conceptualEmployee);
        }

        return Optional.empty();
    }

    private Employee createEmployeeFromRange(String extension, Long subdivisionId, Long commLocationId, String namePrefix) {
        Employee newEmployee = new Employee();
        newEmployee.setExtension(extension);

        String prefixToUse = (namePrefix != null && !namePrefix.isEmpty()) ? namePrefix : cdrConfigService.getEmployeeNamePrefixFromRange();

        newEmployee.setName(prefixToUse + " " + extension);
        newEmployee.setSubdivisionId(subdivisionId);
        newEmployee.setCommunicationLocationId(commLocationId);
        newEmployee.setActive(true);
        newEmployee.setAuthCode("");
        newEmployee.setEmail("");
        newEmployee.setPhone("");
        newEmployee.setAddress("");
        newEmployee.setIdNumber("");
        log.debug("Conceptually created new employee object for extension {} from range.", extension);
        return newEmployee;
    }

    @SuppressWarnings("unchecked")
    @Transactional(readOnly = true)
    public Map<Long, ExtensionLimits> getExtensionLimits() {
        log.debug("Fetching all extension limits for all active Communication Locations using bulk operations.");

        String commLocationQuery = "SELECT cl FROM CommunicationLocation cl WHERE cl.active = true";
        List<CommunicationLocation> allCommLocations = entityManager
                .createQuery(commLocationQuery, CommunicationLocation.class).getResultList();
        Map<Long, ExtensionLimits> resultMap = allCommLocations.stream()
                .collect(Collectors.toMap(CommunicationLocation::getId, id -> new ExtensionLimits()));

        if (allCommLocations.isEmpty()) {
            return Collections.emptyMap();
        }

        String maxAllowedLenStr = String.valueOf(CdrConfigService.MAX_EXTENSION_LENGTH_FOR_INTERNAL_CHECK);
        int maxStandardExtLength = maxAllowedLenStr.length() - 1;
        if (maxStandardExtLength < 1) maxStandardExtLength = 1;

        // Bulk fetch Employee lengths
        String empLenQueryStr = "SELECT e.communication_location_id as comm_id, " +
                "  CAST(MIN(LENGTH(e.extension)) AS INTEGER) as min_len, " +
                "  CAST(MAX(LENGTH(e.extension)) AS INTEGER) as max_len " +
                "FROM employee e " +
                "JOIN communication_location cl ON e.communication_location_id = cl.id " +
                "WHERE cl.active = true " + 
                "  AND e.extension ~ '^[1-9][0-9]*$' " +
                "  AND LENGTH(e.extension) BETWEEN 1 AND :maxStandardExtLength " +
                "GROUP BY e.communication_location_id";
        Query empLenQuery = entityManager.createNativeQuery(empLenQueryStr, Tuple.class);
        empLenQuery.setParameter("maxStandardExtLength", maxStandardExtLength);
        List<Tuple> empLenResults = empLenQuery.getResultList();

        for (Tuple row : empLenResults) {
            Long commId = row.get("comm_id", Number.class).longValue();
            int minLen = row.get("min_len", Number.class).intValue();
            int maxLen = row.get("max_len", Number.class).intValue();
            resultMap.computeIfPresent(commId, (k, v) -> v.updateLengths(minLen, maxLen));
        }

        // Bulk fetch ExtensionRange lengths
        String rangeLenQueryStr = "SELECT er.comm_location_id as comm_id, " +
                "  CAST(MIN(LENGTH(er.range_start::text)) AS INTEGER) as min_len, " +
                "  CAST(MAX(LENGTH(er.range_end::text)) AS INTEGER) as max_len " +
                "FROM extension_range er " +
                "JOIN communication_location cl ON er.comm_location_id = cl.id " +
                "WHERE cl.active = true " + 
                "  AND er.range_start::text ~ '^[0-9]+$' AND er.range_end::text ~ '^[0-9]+$' " +
                "  AND LENGTH(er.range_start::text) BETWEEN 1 AND :maxStandardExtLength " +
                "  AND LENGTH(er.range_end::text) BETWEEN 1 AND :maxStandardExtLength " +
                "GROUP BY er.comm_location_id";
        Query rangeLenQuery = entityManager.createNativeQuery(rangeLenQueryStr, Tuple.class);
        rangeLenQuery.setParameter("maxStandardExtLength", maxStandardExtLength);
        List<Tuple> rangeLenResults = rangeLenQuery.getResultList();

        for (Tuple row : rangeLenResults) {
            Long commId = row.get("comm_id", Number.class).longValue();
            int minLen = row.get("min_len", Number.class).intValue();
            int maxLen = row.get("max_len", Number.class).intValue();
            resultMap.computeIfPresent(commId, (k, v) -> v.updateLengths(minLen, maxLen));
        }

        // Bulk fetch Special Extensions
        String specialExtQueryStr = "SELECT e.communication_location_id as comm_id, e.extension " +
                "FROM employee e " +
                "JOIN communication_location cl ON e.communication_location_id = cl.id " +
                "WHERE cl.active = true " + 
                "  AND e.extension NOT LIKE '%-%' " +
                "  AND (LENGTH(e.extension) >= :maxExtStandardLenForFullList OR e.extension LIKE '0%' OR e.extension LIKE '*%' OR e.extension LIKE '#%')";
        Query specialExtQuery = entityManager.createNativeQuery(specialExtQueryStr, Tuple.class);
        specialExtQuery.setParameter("maxExtStandardLenForFullList", maxAllowedLenStr.length());
        List<Tuple> specialExtResults = specialExtQuery.getResultList();

        Map<Long, List<String>> specialExtensionsByCommId = specialExtResults.stream()
                .collect(Collectors.groupingBy(
                        tuple -> tuple.get("comm_id", Number.class).longValue(),
                        Collectors.mapping(tuple -> tuple.get("extension", String.class), Collectors.toList())));

        specialExtensionsByCommId.forEach((commId, extensions) -> resultMap.computeIfPresent(commId, (k, v) -> {
            v.setSpecialFullExtensions(extensions);
            return v;
        }));

        resultMap.values().forEach(ExtensionLimits::calculateFinalMinMaxValues);
        return resultMap;
    }

    @SuppressWarnings("unchecked")
    @Transactional(readOnly = true)
    public Map<Long, List<ExtensionRange>> getExtensionRanges() {
        log.debug("Fetching all active extension ranges from the database (cache bypassed).");

        String queryStr = "SELECT er.* FROM extension_range er " +
                "JOIN communication_location cl ON er.comm_location_id = cl.id " +
                "WHERE cl.active = true " + 
                "ORDER BY (er.range_end - er.range_start) ASC, er.created_date DESC";

        Query nativeQuery = entityManager.createNativeQuery(queryStr, ExtensionRange.class);
        List<ExtensionRange> allRanges = nativeQuery.getResultList();

        return allRanges.stream().collect(Collectors.groupingBy(ExtensionRange::getCommLocationId));
    }
}

============================================================
FILE: ExtensionLimits.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/ExtensionLimits.java
SIZE: 2.21 KB
MODIFIED: 2026-02-26 11:04:30
============================================================
// File: com/infomedia/abacox/telephonypricing/component/cdrprocessing/ExtensionLimits.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;

@AllArgsConstructor
@NoArgsConstructor
@Data
public class ExtensionLimits {
    // Final numeric values
    private int minLength = 100;
    private int maxLength = CdrConfigService.MAX_EXTENSION_LENGTH_FOR_INTERNAL_CHECK;
    private List<String> specialFullExtensions = Collections.emptyList();

    // Internal trackers for length calculation
    private transient int minLengthTracker = Integer.MAX_VALUE;
    private transient int maxLengthTracker = 0;

    /**
     * Updates the internal length trackers with new min/max length values from a query.
     * @param min The minimum length found in a query group.
     * @param max The maximum length found in a query group.
     * @return The current object for chaining.
     */
    public ExtensionLimits updateLengths(int min, int max) {
        if (min > 0 && min < this.minLengthTracker) {
            this.minLengthTracker = min;
        }
        if (max > 0 && max > this.maxLengthTracker) {
            this.maxLengthTracker = max;
        }
        return this;
    }

    /**
     * Calculates the final numeric min/max values based on the tracked lengths.
     * This should be called after all length data has been processed.
     */
    public void calculateFinalMinMaxValues() {
        if (maxLengthTracker > 0) {
            this.maxLength = Integer.parseInt("9".repeat(maxLengthTracker));
        }
        if (minLengthTracker > 0 && minLengthTracker != Integer.MAX_VALUE) {
            this.minLength = Integer.parseInt("1" + "0".repeat(Math.max(0, minLengthTracker - 1)));
        }

        // PHP: if ($finalMinVal > $finalMaxVal && $finalMaxVal > 0 ...)
        // This ensures min is not greater than max if both were derived from data.
        if (this.minLength > this.maxLength && this.maxLength > 0 && this.minLengthTracker > 0 && this.maxLengthTracker > 0) {
            this.minLength = this.maxLength;
        }
    }
}

============================================================
FILE: FailedCallRecordPersistenceService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/FailedCallRecordPersistenceService.java
SIZE: 8.54 KB
MODIFIED: 2026-02-27 10:32:51
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.component.utils.CompressionZipUtil;
import com.infomedia.abacox.telephonypricing.db.entity.FailedCallRecord;
import jakarta.persistence.EntityManager;
import jakarta.persistence.NoResultException;
import jakarta.persistence.PersistenceContext;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.hibernate.exception.ConstraintViolationException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.support.TransactionTemplate;

import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.UUID;

@Service
@Log4j2
@RequiredArgsConstructor
public class FailedCallRecordPersistenceService {

    @PersistenceContext
    private EntityManager entityManager;

    // Inject TransactionManager to control boundaries manually
    private final PlatformTransactionManager transactionManager;

    /**
     * Batch lookup for existing failed records.
     * Used by BatchPersistenceWorker to determine Insert vs Update.
     */
    @Transactional(readOnly = true)
    public List<FailedCallRecord> findExistingRecordsByHashes(List<UUID> hashes) { // Changed Long to UUID
        if (hashes == null || hashes.isEmpty()) return Collections.emptyList();

        return entityManager.createQuery(
                        "SELECT fr FROM FailedCallRecord fr WHERE fr.ctlHash IN :hashes", FailedCallRecord.class)
                .setParameter("hashes", hashes)
                .getResultList();
    }

    /**
     * Creates a new FailedCallRecord entity in memory from the processing result.
     * Does NOT persist.
     */
    public FailedCallRecord createEntityFromDto(ProcessedCdrResult result) {
        CdrData cdrData = result.getCdrData();
        FailedCallRecord record = new FailedCallRecord();

        record.setCtlHash(cdrData.getCtlHash());

        record.setCommLocationId(cdrData.getCommLocationId());
        record.setEmployeeExtension(truncate(cdrData.getCallingPartyNumber(), 50));

        record.setOriginalCallRecordId(result.getOriginalCallRecordId());
        if (cdrData.getFileInfo() != null) {
            record.setFileInfoId(cdrData.getFileInfo().getId());
        }

        record.setErrorType(result.getErrorType() != null ? result.getErrorType().name() : "UNKNOWN");
        record.setErrorMessage(result.getErrorMessage());

        return record;
    }

    /**
     * Updates an existing entity instance with new error details from the processing result.
     * Does NOT merge/persist.
     */
    public void updateEntityFromDto(FailedCallRecord record, ProcessedCdrResult result) {
        record.setErrorType(result.getErrorType() != null ? result.getErrorType().name() : "UNKNOWN");
        record.setErrorMessage(result.getErrorMessage());

        CdrData cdrData = result.getCdrData();
        record.setEmployeeExtension(truncate(cdrData.getCallingPartyNumber(), 50));

        // REMOVED: Compression update logic

        if (result.getOriginalCallRecordId() != null) {
            record.setOriginalCallRecordId(result.getOriginalCallRecordId());
        }
    }

    /**
     * Synchronous quarantine method with concurrency protection.
     * <p>
     * NOTE: This method does NOT have @Transactional. It uses TransactionTemplate internally
     * to isolate the insert attempt. If the insert fails due to a Postgres Aborted Transaction (Duplicate Key),
     * we can safely exit that transaction block and start a NEW one to handle the update.
     */
    public FailedCallRecord quarantineRecord(CdrData cdrData,
                                             QuarantineErrorType errorType, String errorMessage,
                                             Long originalCallRecordId) {
        if (cdrData == null) {
            return null;
        }

        UUID ctlHash = cdrData.getCtlHash();

        // Configure a template for REQUIRES_NEW behavior
        TransactionTemplate txTemplate = new TransactionTemplate(transactionManager);
        txTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);

        try {
            // BLOCK A: Attempt Execution in an isolated transaction
            return txTemplate.execute(status -> {
                FailedCallRecord recordToSave = findByCtlHash(ctlHash);

                if (recordToSave != null) {
                    updateQuarantineDetails(recordToSave, cdrData, errorType, errorMessage, originalCallRecordId);
                    return entityManager.merge(recordToSave);
                } else {
                    recordToSave = new FailedCallRecord();
                    recordToSave.setCtlHash(ctlHash);

                    recordToSave.setCommLocationId(cdrData.getCommLocationId());
                    updateQuarantineDetails(recordToSave, cdrData, errorType, errorMessage, originalCallRecordId);

                    entityManager.persist(recordToSave);
                    entityManager.flush();
                    return recordToSave;
                }
            });

        } catch (Exception e) {
            // BLOCK C: Exception Handling OUTSIDE the aborted transaction
            if (isDuplicateKeyException(e)) {
                log.debug("Race condition detected for hash {}. Switching to Update in fresh transaction.", ctlHash);

                // BLOCK D: Recovery Transaction
                return txTemplate.execute(retryStatus -> {
                    // Fetch the winner of the race
                    FailedCallRecord record = findByCtlHash(ctlHash);
                    if (record != null) {
                        updateQuarantineDetails(record, cdrData, errorType, errorMessage, originalCallRecordId);
                        return entityManager.merge(record);
                    }
                    return null; 
                });
            } else {
                log.error("Failed to save quarantine record. Hash: {}", ctlHash, e);
                throw e; // Rethrow if it's not a duplicate key issue
            }
        }
    }

    private void updateQuarantineDetails(FailedCallRecord record, CdrData cdrData,
                                         QuarantineErrorType errorType, String errorMessage,
                                         Long originalCallRecordId) {
        record.setErrorType(errorType.name());
        record.setErrorMessage(errorMessage);
        record.setEmployeeExtension(truncate(cdrData.getCallingPartyNumber(), 50));

        if (originalCallRecordId != null) {
            record.setOriginalCallRecordId(originalCallRecordId);
        }
        if (cdrData.getFileInfo() != null && record.getFileInfoId() == null) {
            record.setFileInfoId(cdrData.getFileInfo().getId().longValue());
        }
    }

    private boolean isDuplicateKeyException(Exception e) {
        Throwable cause = e;
        while (cause != null) {
            if (cause instanceof ConstraintViolationException ||
                    (cause.getMessage() != null && cause.getMessage().toLowerCase().contains("duplicate key"))) {
                return true;
            }
            cause = cause.getCause();
        }
        return false;
    }

    @Transactional(readOnly = true)
    public FailedCallRecord findByCtlHash(UUID ctlHash) { // Changed Long to UUID
        try {
            return entityManager.createQuery("SELECT fr FROM FailedCallRecord fr WHERE fr.ctlHash = :hash", FailedCallRecord.class)
                    .setParameter("hash", ctlHash)
                    .getSingleResult();
        } catch (NoResultException e) {
            return null;
        }
    }

    @Transactional
    public int deleteByFileInfoId(Long fileInfoId) {
        if (fileInfoId == null) return 0;
        int deletedCount = entityManager.createQuery("DELETE FROM FailedCallRecord fr WHERE fr.fileInfoId = :fileInfoId")
                .setParameter("fileInfoId", fileInfoId)
                .executeUpdate();
        log.debug("Deleted {} FailedCallRecord(s) for FileInfo ID: {}", deletedCount, fileInfoId);
        return deletedCount;
    }

    private String truncate(String input, int limit) {
        if (input == null) return null;
        return input.length() > limit ? input.substring(0, limit) : input;
    }
}

============================================================
FILE: FileInfoData.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/FileInfoData.java
SIZE: 0.18 KB
MODIFIED: 2025-11-25 09:35:34
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import java.io.InputStream;

public record FileInfoData(String filename, InputStream content, long length) {
}

============================================================
FILE: FileInfoPersistenceService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/FileInfoPersistenceService.java
SIZE: 11.86 KB
MODIFIED: 2026-02-27 12:22:03
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.component.configmanager.StorageKey;
import com.infomedia.abacox.telephonypricing.component.utils.XXHash128Util;
import com.infomedia.abacox.telephonypricing.db.entity.FileInfo;
import com.infomedia.abacox.telephonypricing.multitenancy.TenantContext;
import com.infomedia.abacox.telephonypricing.service.MinioStorageService;
import jakarta.persistence.EntityManager;
import jakarta.persistence.LockModeType;
import jakarta.persistence.NoResultException;
import jakarta.persistence.PersistenceContext;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StreamUtils;

// CHANGED: Standard Java ZIP imports
import java.util.UUID;
import java.util.zip.Deflater;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

import java.io.*;
import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

@Service
@Log4j2
@RequiredArgsConstructor
public class FileInfoPersistenceService {

    @PersistenceContext
    private EntityManager entityManager;

    // Inject the new MinIO service
    private final MinioStorageService minioStorageService;

    @Getter
    @AllArgsConstructor
    public static class FileInfoCreationResult {
        private final FileInfo fileInfo;
        private final boolean isNew;
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public FileInfoCreationResult createOrGetFileInfo(String filename, Long plantTypeId, File file)
            throws IOException {

        // 1. Calculate Hash
        UUID checksum;
        try (InputStream fileInputStream = new FileInputStream(file)) {
            checksum = XXHash128Util.hash(fileInputStream);
        }

        // 2. Check DB
        FileInfo fileInfo = findByChecksumInternal(checksum);
        boolean isNew = false;

        if (fileInfo == null) {
            isNew = true;
            String tenantId = TenantContext.getTenant();
            String objectKey = checksum.toString();

            // 3. Compress to Temp
            File tempCompressedFile = File.createTempFile("minio_up_", ".gz");
            try (InputStream in = new FileInputStream(file);
                    OutputStream out = new FileOutputStream(tempCompressedFile)) {
                compressStream(in, out);
            }

            // 4. Upload & CAPTURE RESULT
            MinioStorageService.MinioUploadResult uploadResult;
            try (InputStream uploadStream = new FileInputStream(tempCompressedFile)) {
                uploadResult = minioStorageService.uploadFile(
                        tenantId,
                        StorageKey.CDR,
                        objectKey,
                        uploadStream,
                        tempCompressedFile.length(),
                        "application/gzip");
            } catch (Exception e) {
                tempCompressedFile.delete();
                throw new IOException("Failed to upload to MinIO", e);
            }

            // 5. Save DB Record using returned metadata
            fileInfo = new FileInfo();
            fileInfo.setFilename(filename.length() > 255 ? filename.substring(0, 255) : filename);
            fileInfo.setPlantTypeId(plantTypeId != null ? plantTypeId.intValue() : 0);
            fileInfo.setDate(LocalDateTime.now());
            fileInfo.setChecksum(checksum);
            fileInfo.setSize((int) file.length());
            fileInfo.setProcessingStatus(FileInfo.ProcessingStatus.PENDING);

            // SET STORAGE DATA FROM RESULT
            fileInfo.setStorageBucket(uploadResult.bucketName());
            fileInfo.setStorageObjectName(uploadResult.objectName());

            entityManager.persist(fileInfo);
            entityManager.flush();

            tempCompressedFile.delete();
        }

        return new FileInfoCreationResult(fileInfo, isNew);
    }

    /**
     * Compresses data from an InputStream to an OutputStream using GZIP with
     * maximum compression.
     * The GZIPOutputStream is closed automatically, which writes the trailer and
     * finishes compression.
     */
    public static void compressStream(InputStream inputStream, OutputStream outputStream) throws IOException {
        // CHANGED: Use GZIPOutputStream with anonymous subclass to set Best Compression
        // (Level 9)
        try (GZIPOutputStream gzipOutputStream = new GZIPOutputStream(outputStream) {
            {
                def.setLevel(Deflater.BEST_COMPRESSION);
            }
        }) {
            byte[] buffer = new byte[8192];
            int bytesRead;

            while ((bytesRead = inputStream.read(buffer)) != -1) {
                gzipOutputStream.write(buffer, 0, bytesRead);
            }
            // gzipOutputStream.close() is called automatically here via try-with-resources
        }
    }

    private FileInfo findByChecksumInternal(UUID checksum) { // Changed Long to UUID
        try {
            return entityManager.createQuery("SELECT fi FROM FileInfo fi WHERE fi.checksum = :checksum", FileInfo.class)
                    .setParameter("checksum", checksum)
                    .getSingleResult();
        } catch (NoResultException e) {
            return null;
        }
    }

    @Transactional(readOnly = true)
    public FileInfo findById(Long fileInfoId) {
        if (fileInfoId == null)
            return null;
        return entityManager.find(FileInfo.class, fileInfoId.intValue());
    }

    /**
     * Optimized batch fetch: Locks and returns up to 'limit' pending files at once.
     */
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public List<FileInfo> findAndLockPendingFiles(int limit) {
        try {
            List<FileInfo> files = entityManager.createQuery(
                    "SELECT fi FROM FileInfo fi WHERE fi.processingStatus = :status ORDER BY fi.date ASC",
                    FileInfo.class)
                    .setParameter("status", FileInfo.ProcessingStatus.PENDING)
                    .setMaxResults(limit)
                    .setLockMode(LockModeType.PESSIMISTIC_WRITE)
                    .setHint("jakarta.persistence.lock.timeout", 0) // SKIP LOCKED behavior
                    .getResultList();

            for (FileInfo fi : files) {
                fi.setProcessingStatus(FileInfo.ProcessingStatus.IN_PROGRESS);
                entityManager.merge(fi);
            }

            return files;
        } catch (Exception e) {
            log.error("Error locking pending files", e);
            return Collections.emptyList();
        }
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public int resetInProgressToPending() {
        int updatedCount = entityManager.createQuery(
                "UPDATE FileInfo fi SET fi.processingStatus = :pendingStatus WHERE fi.processingStatus = :inProgressStatus")
                .setParameter("pendingStatus", FileInfo.ProcessingStatus.PENDING)
                .setParameter("inProgressStatus", FileInfo.ProcessingStatus.IN_PROGRESS)
                .executeUpdate();
        if (updatedCount > 0) {
            log.info("Reset {} files from IN_PROGRESS to PENDING status on startup.", updatedCount);
        }
        return updatedCount;
    }

    @Transactional(readOnly = true)
    public Optional<FileInfoData> getOriginalFileData(Long fileInfoId) {
        FileInfo fileInfo = findById(fileInfoId);
        if (fileInfo == null || fileInfo.getStorageObjectName() == null) {
            return Optional.empty();
        }

        try {
            // Use stored bucket name directly
            InputStream compressedStream = minioStorageService.downloadFile(
                    fileInfo.getStorageBucket(),
                    fileInfo.getStorageObjectName());

            InputStream decompressedStream = new GZIPInputStream(compressedStream);

            return Optional.of(new FileInfoData(
                    fileInfo.getFilename(),
                    decompressedStream,
                    fileInfo.getSize()));

        } catch (Exception e) {
            log.error("Failed to retrieve file from MinIO for ID: {}", fileInfoId, e);
            return Optional.empty();
        }
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void updateStatus(Long fileInfoId, FileInfo.ProcessingStatus status) {
        FileInfo fileInfo = findById(fileInfoId);
        if (fileInfo != null) {
            fileInfo.setProcessingStatus(status);
            entityManager.merge(fileInfo);
        }
    }

    @Transactional(readOnly = true)
    public FileInfoMetadata getFileMetadata(Long fileInfoId) {
        FileInfo fileInfo = findById(fileInfoId);
        if (fileInfo == null) {
            return null;
        }
        // Handle potential nulls safely to prevent unboxing NPEs
        String safeFilename = fileInfo.getFilename() != null ? fileInfo.getFilename() : "unknown_file_" + fileInfoId;
        long safeSize = fileInfo.getSize() != null ? fileInfo.getSize() : 0L;

        return new FileInfoMetadata(safeFilename, safeSize);
    }

    /**
     * Streams the content directly to the provided OutputStream within a
     * Transaction.
     * This keeps the PostgreSQL Large Object descriptor open while reading.
     */
    @Transactional(readOnly = true, propagation = Propagation.REQUIRED)
    public void streamFileContent(Long fileInfoId, OutputStream outputStream) {
        FileInfo fileInfo = findById(fileInfoId);
        if (fileInfo == null) {
            throw new RuntimeException("File info not found for ID: " + fileInfoId);
        }

        try {
            // Use stored bucket details directly if available.
            // This avoids relying on TenantContext which might not be propagated to this
            // async thread.
            InputStream minioStream;
            if (fileInfo.getStorageBucket() != null && !fileInfo.getStorageBucket().isEmpty()) {
                minioStream = minioStorageService.downloadFile(fileInfo.getStorageBucket(),
                        fileInfo.getStorageObjectName());
            } else {
                // Fallback for legacy records
                String tenantId = TenantContext.getTenant();
                if (tenantId == null) {
                    // Start of fallback if tenant is missing in async context (could default or
                    // error)
                    log.warn(
                            "TenantContext is null in async streamFileContent. Attempting to proceed but this may fail if bucket needs resolution.");
                }
                minioStream = minioStorageService.downloadFile(tenantId, StorageKey.CDR,
                        fileInfo.getStorageObjectName());
            }

            // Decompress and copy to HTTP output
            try (InputStream gzipStream = new GZIPInputStream(minioStream)) {
                StreamUtils.copy(gzipStream, outputStream);
                outputStream.flush();
            }
            // minioStream closed by try-with-resources of gzipStream (usually)
            // or explicitly close minioStream if GZIPInputStream doesn't close inner stream
            // (it does in standard Java).

        } catch (Exception e) {
            log.error("Error streaming content for file ID: {}", fileInfoId, e);
            throw new RuntimeException("Failed to stream file content", e);
        }
    }

    // Helper record for metadata
    public record FileInfoMetadata(String filename, long size) {
    }
}

============================================================
FILE: FileProcessingTrackerService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/FileProcessingTrackerService.java
SIZE: 5.03 KB
MODIFIED: 2026-02-19 11:27:30
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.FileInfo;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

@Service
@Log4j2
@RequiredArgsConstructor
public class FileProcessingTrackerService {

    private final FileInfoPersistenceService fileInfoPersistenceService;

    // Maps FileInfoID -> Number of records currently in Queue or Processing
    // (In-Flight)
    private final Map<Long, AtomicInteger> pendingRecords = new ConcurrentHashMap<>();

    // Maps FileInfoID -> Boolean indicating if the InputStream has been fully read
    // by the router
    private final Map<Long, Boolean> fileParsingFinished = new ConcurrentHashMap<>();

    // Files that were abandoned mid-flight (CDR disabled). checkCompletion will
    // reset
    // them to PENDING instead of COMPLETED so they are reprocessed when re-enabled.
    private final Set<Long> discardedFiles = ConcurrentHashMap.newKeySet();

    /**
     * Initializes tracking for a new file. Called before routing starts.
     */
    public void initFile(Long fileInfoId) {
        pendingRecords.put(fileInfoId, new AtomicInteger(0));
        fileParsingFinished.put(fileInfoId, false);
        discardedFiles.remove(fileInfoId); // clear any stale discard marker
    }

    /**
     * Increments the pending count. Called by the Producer (CdrProcessorService)
     * before submitting to queue.
     */
    public void incrementPendingCount(Long fileInfoId, int delta) {
        if (fileInfoId == null)
            return;
        pendingRecords.computeIfAbsent(fileInfoId, k -> new AtomicInteger(0))
                .addAndGet(delta);
    }

    /**
     * Decrements the pending count. Called by the Consumer (BatchPersistenceWorker)
     * after DB flush.
     */
    public void decrementPendingCount(Long fileInfoId, int delta) {
        if (fileInfoId == null)
            return;

        AtomicInteger counter = pendingRecords.get(fileInfoId);
        if (counter != null) {
            int current = counter.addAndGet(-delta);
            checkCompletion(fileInfoId, current);
        }
    }

    /**
     * Marks that the file stream has been fully read and all batches submitted.
     */
    public void markParsingComplete(Long fileInfoId) {
        fileParsingFinished.put(fileInfoId, true);

        // Check immediately. If the file was empty or very small, or processing was
        // faster than routing,
        // the count might already be 0.
        AtomicInteger counter = pendingRecords.get(fileInfoId);
        int current = (counter != null) ? counter.get() : 0;

        checkCompletion(fileInfoId, current);
    }

    /**
     * Marks a file as discarded (CDR disabled mid-flight) and triggers completion
     * so that
     * checkCompletion can reset it to PENDING instead of COMPLETED.
     * Called by BatchPersistenceWorker when it discards a batch for a disabled
     * tenant.
     */
    public void abandonFile(Long fileInfoId, int delta) {
        if (fileInfoId == null)
            return;
        discardedFiles.add(fileInfoId);
        decrementPendingCount(fileInfoId, delta);
    }

    /**
     * Checks if processing is fully complete for a file.
     */
    private void checkCompletion(Long fileInfoId, int pendingCount) {
        boolean isParsingDone = fileParsingFinished.getOrDefault(fileInfoId, false);

        // If parser is done AND no records are left in the queue/processing pipeline
        if (isParsingDone && pendingCount <= 0) {
            // Clean up memory maps
            pendingRecords.remove(fileInfoId);
            fileParsingFinished.remove(fileInfoId);

            if (discardedFiles.remove(fileInfoId)) {
                // File was abandoned because CDR was disabled  reset to PENDING so it
                // gets reprocessed when CDR is re-enabled.
                log.info("File ID {} was discarded (CDR disabled). Resetting to PENDING.", fileInfoId);
                try {
                    fileInfoPersistenceService.updateStatus(fileInfoId, FileInfo.ProcessingStatus.PENDING);
                } catch (Exception e) {
                    log.error("Failed to reset status to PENDING for discarded file {}", fileInfoId, e);
                }
            } else {
                log.info("File processing finished. All records persisted. Marking File ID {} as COMPLETED.",
                        fileInfoId);
                // Update Database Status
                try {
                    fileInfoPersistenceService.updateStatus(fileInfoId, FileInfo.ProcessingStatus.COMPLETED);
                } catch (Exception e) {
                    log.error("Failed to update status to COMPLETED for file {}", fileInfoId, e);
                }
            }
        }
    }
}


============================================================
FILE: HistoricalDataContainer.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/HistoricalDataContainer.java
SIZE: 5.53 KB
MODIFIED: 2026-02-25 12:24:08
============================================================
// File: com/infomedia/abacox/telephonypricing/component/cdrprocessing/HistoricalDataContainer.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.Employee;
import com.infomedia.abacox.telephonypricing.db.entity.ExtensionRange;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import lombok.extern.log4j.Log4j2;

import java.util.*;

@Getter
@Log4j2
public class HistoricalDataContainer {

    private final Map<String, ResolvedTimeline> extensionTimelines = new HashMap<>();
    private final Map<String, ResolvedTimeline> authCodeTimelines = new HashMap<>();
    private final Map<Long, List<RangeSlice>> rangeSlicesByCommId = new HashMap<>();

    public void addEmployeeExtensionSlice(String extension, Employee emp, long fdesde, long fhasta, boolean isGlobal) {
        extensionTimelines.computeIfAbsent(extension, k -> new ResolvedTimeline()).addSlice(emp, fdesde, fhasta, isGlobal);
    }

    public void addEmployeeAuthCodeSlice(String authCode, Employee emp, long fdesde, long fhasta, boolean isGlobal) {
        authCodeTimelines.computeIfAbsent(authCode, k -> new ResolvedTimeline()).addSlice(emp, fdesde, fhasta, isGlobal);
    }

    public void addRangeSlice(Long commLocationId, ExtensionRange range, long fdesde, long fhasta) {
        rangeSlicesByCommId.computeIfAbsent(commLocationId, k -> new ArrayList<>()).add(new RangeSlice(range, fdesde, fhasta));
    }

    @Data
    @AllArgsConstructor
    public static class EmployeeSlice {
        private Employee employee;
        private long fdesde;
        private long fhasta;
    }

    @Data
    @AllArgsConstructor
    public static class RangeSlice {
        private ExtensionRange range;
        private long fdesde;
        private long fhasta;
    }

    @Getter
    public static class ResolvedTimeline {
        private final Map<String, EmployeeSlice> slices = new HashMap<>();

        /**
         * Matches PHP's AsignarHistoricosFuncionarios logic to resolve overlapping 
         * timelines for the same identifier across different history control groups.
         */
        public void addSlice(Employee emp, long fdesde, long fhasta, boolean isGlobal) {
            String llave = isGlobal ? "" : String.valueOf(emp.getCommunicationLocationId());
            long currentFdesde = fdesde;
            EmployeeSlice currentSlice = new EmployeeSlice(emp, currentFdesde, fhasta);

            int maxInteractions = 200;
            while (slices.containsKey(currentFdesde + llave) && maxInteractions > 0) {
                maxInteractions--;
                EmployeeSlice existing = slices.get(currentFdesde + llave);
                long fhastaUps = existing.getFhasta();
                long currentFhasta = currentSlice.getFhasta();

                if (fhastaUps > 0 && fhastaUps < currentFhasta) {
                    // Existing ends before new ends: push new one's start date
                    currentFdesde = fhastaUps + 1;
                    currentSlice.setFdesde(currentFdesde);
                } else if ((fhastaUps <= 0 && currentFhasta > 0) || fhastaUps > currentFhasta) {
                    // Existing end date is open or > new end date: Swap them
                    EmployeeSlice temp = existing;
                    slices.put(currentFdesde + llave, currentSlice);
                    currentSlice = temp;
                    currentFdesde = currentFhasta + 1;
                    currentSlice.setFdesde(currentFdesde);
                } else {
                    // Exact same start and end? Differentiate by plant if not global
                    if (!llave.equals(String.valueOf(currentSlice.getEmployee().getCommunicationLocationId()))) {
                        llave = String.valueOf(currentSlice.getEmployee().getCommunicationLocationId());
                    } else {
                        break;
                    }
                }
            }
            if (maxInteractions <= 0) {
                log.error("Historical timeline collision resolution maxed out for Employee ID {}! Possible dirty overlapping data.", emp.getId());
            }
            slices.put(currentFdesde + llave, currentSlice);
        }

        public Optional<Employee> findMatch(long callTimestampEpoch, Long commLocationIdContext) {
            List<EmployeeSlice> sortedSlices = new ArrayList<>(slices.values());
            // Sort by fdesde DESC to find the most recent valid timeline
            sortedSlices.sort((a, b) -> Long.compare(b.getFdesde(), a.getFdesde()));

            Employee bestMatch = null;
            Employee fallbackGlobalMatch = null;

            for (EmployeeSlice slice : sortedSlices) {
                if ((slice.getFdesde() <= 0 || slice.getFdesde() <= callTimestampEpoch) &&
                    (slice.getFhasta() <= 0 || slice.getFhasta() >= callTimestampEpoch)) {

                    Long sliceCommId = slice.getEmployee().getCommunicationLocationId();

                    if (commLocationIdContext == null || Objects.equals(sliceCommId, commLocationIdContext)) {
                        bestMatch = slice.getEmployee();
                        break;
                    } else if (fallbackGlobalMatch == null) {
                        fallbackGlobalMatch = slice.getEmployee();
                    }
                }
            }

            if (bestMatch != null) return Optional.of(bestMatch);
            return Optional.ofNullable(fallbackGlobalMatch);
        }
    }
}

============================================================
FILE: IncomingCallOriginInfo.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/IncomingCallOriginInfo.java
SIZE: 0.5 KB
MODIFIED: 2025-06-04 13:40:58
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import lombok.Data;

@Data
public class IncomingCallOriginInfo {
    private String effectiveNumber; // Number after transformations by buscarOrigen
    private Long telephonyTypeId;
    private String telephonyTypeName;
    private Long operatorId;
    private String operatorName;
    private Long indicatorId; // Source indicator for incoming call
    private String destinationDescription; // Description of the source
}

============================================================
FILE: IncomingCallProcessorService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/IncomingCallProcessorService.java
SIZE: 5.33 KB
MODIFIED: 2025-08-28 14:36:42
============================================================
// File: com/infomedia/abacox/telephonypricing/cdr/IncomingCallProcessorService.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.CommunicationLocation;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service
@Log4j2
@RequiredArgsConstructor
public class IncomingCallProcessorService {

    private final PbxSpecialRuleLookupService pbxSpecialRuleLookupService;
    private final PhoneNumberTransformationService phoneNumberTransformationService;
    private final CallOriginDeterminationService callOriginDeterminationService;
    private final TariffCalculationService tariffCalculationService;
    private final TelephonyTypeLookupService telephonyTypeLookupService;

    /**
     * PHP equivalent: procesaEntrante
     */
    public void processIncoming(CdrData cdrData, LineProcessingContext processingContext) {
        CommunicationLocation commLocation = processingContext.getCommLocation();
        log.debug("Processing INCOMING logic for CDR: {}", cdrData.getCtlHash());

        String externalCallerId = cdrData.getFinalCalledPartyNumber();
        String ourExtension = cdrData.getCallingPartyNumber();
        log.debug("Incoming call. External Caller ID (from parser swap): {}, Our Extension: {}", externalCallerId, ourExtension);

        Optional<String> pbxTransformedCaller = pbxSpecialRuleLookupService.applyPbxSpecialRule(
                externalCallerId, commLocation.getDirectory(), PbxRuleDirection.INCOMING.getValue()
        );
        if (pbxTransformedCaller.isPresent()) {
            log.debug("External Caller ID '{}' transformed by PBX incoming rule to '{}'", externalCallerId, pbxTransformedCaller.get());
            cdrData.setOriginalDialNumberBeforePbxIncoming(externalCallerId);
            externalCallerId = pbxTransformedCaller.get();
            cdrData.setPbxSpecialRuleAppliedInfo("PBX Incoming Rule: " + cdrData.getFinalCalledPartyNumber() + " -> " + externalCallerId);
        }

        TransformationResult transformedIncomingCME = phoneNumberTransformationService.transformIncomingNumberCME(
                externalCallerId, commLocation.getIndicator().getOriginCountryId()
        );
        Long hintedTelephonyTypeId = null; // Initialize hint
        if (transformedIncomingCME.isTransformed()) {
            log.debug("External Caller ID '{}' transformed by CME rule to '{}'", externalCallerId, transformedIncomingCME.getTransformedNumber());
            cdrData.setOriginalCallerIdBeforeCMETransform(externalCallerId);
            externalCallerId = transformedIncomingCME.getTransformedNumber();
            if (transformedIncomingCME.getNewTelephonyTypeId() != null) {
                hintedTelephonyTypeId = transformedIncomingCME.getNewTelephonyTypeId(); // Capture the hint
                cdrData.setHintedTelephonyTypeIdFromTransform(hintedTelephonyTypeId);
            }
        }

        if (transformedIncomingCME.isTransformed()) {
            log.debug("External Caller ID '{}' transformed by CME rule to '{}'", externalCallerId, transformedIncomingCME.getTransformedNumber());
            cdrData.setOriginalCallerIdBeforeCMETransform(externalCallerId);
            externalCallerId = transformedIncomingCME.getTransformedNumber();
        }
        // Always check for a hint, regardless of whether the number string itself was modified
        if (transformedIncomingCME.getNewTelephonyTypeId() != null) {
            hintedTelephonyTypeId = transformedIncomingCME.getNewTelephonyTypeId();
            cdrData.setHintedTelephonyTypeIdFromTransform(hintedTelephonyTypeId);
            log.debug("Captured TelephonyType hint from transformation: {}", hintedTelephonyTypeId);
        }

        IncomingCallOriginInfo originInfo = callOriginDeterminationService.determineIncomingCallOrigin(
            externalCallerId,
            hintedTelephonyTypeId, // Pass the hint
            commLocation
        );
        log.debug("Determined incoming call origin info: {}", originInfo);

        cdrData.setTelephonyTypeId(originInfo.getTelephonyTypeId());
        cdrData.setTelephonyTypeName(originInfo.getTelephonyTypeName());
        cdrData.setOperatorId(originInfo.getOperatorId());
        cdrData.setOperatorName(originInfo.getOperatorName());
        cdrData.setIndicatorId(originInfo.getIndicatorId());
        cdrData.setDestinationCityName(originInfo.getDestinationDescription());
        cdrData.setEffectiveDestinationNumber(originInfo.getEffectiveNumber());
        cdrData.setFinalCalledPartyNumber(originInfo.getEffectiveNumber());

        if (cdrData.getTelephonyTypeId() == null || cdrData.getTelephonyTypeId().equals(TelephonyTypeEnum.ERRORS.getValue())) {
             log.debug("Incoming call origin determination resulted in UNKNOWN telephony type. Defaulting to LOCAL.");
             cdrData.setTelephonyTypeId(TelephonyTypeEnum.LOCAL.getValue());
             cdrData.setTelephonyTypeName(telephonyTypeLookupService.getTelephonyTypeName(TelephonyTypeEnum.LOCAL.getValue()) + " (Default Incoming)");
        }

        tariffCalculationService.calculateTariffsForIncoming(cdrData, commLocation);
        log.debug("Finished processing INCOMING logic. CDR Data: {}", cdrData);
    }
}

============================================================
FILE: IncomingTelephonyTypePriority.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/IncomingTelephonyTypePriority.java
SIZE: 0.87 KB
MODIFIED: 2025-06-04 13:40:58
============================================================
// File: com/infomedia/abacox/telephonypricing/cdr/IncomingTelephonyTypePriority.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class IncomingTelephonyTypePriority {
    private Long telephonyTypeId;
    private String telephonyTypeName;
    private int minSubscriberLength; // Minimum length of the number *after* any operator prefix is removed
    private int maxSubscriberLength; // Maximum length of the number *after* any operator prefix is removed
    private int minTotalLength; // From TelephonyTypeConfig.minValue (NDC + Subscriber)
    private int maxTotalLength; // From TelephonyTypeConfig.maxValue (NDC + Subscriber)
    private String orderKey; // Derived from minTotalLength for sorting
}

============================================================
FILE: IndicatorConfig.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/IndicatorConfig.java
SIZE: 0.45 KB
MODIFIED: 2025-06-04 13:40:58
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import lombok.AllArgsConstructor;
import lombok.Data;

@AllArgsConstructor
@Data
public class IndicatorConfig {
    public int minNdcLength;
    public int maxNdcLength;
    public int seriesNumberLength;

    public IndicatorConfig() { // Default constructor
        this.minNdcLength = 0;
        this.maxNdcLength = 0;
        this.seriesNumberLength = 0;
    }
}


============================================================
FILE: IndicatorLookupService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/IndicatorLookupService.java
SIZE: 20.88 KB
MODIFIED: 2025-11-21 13:31:46
============================================================
// File: com/infomedia/abacox/telephonypricing/component/cdrprocessing/IndicatorLookupService.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import jakarta.persistence.EntityManager;
import jakarta.persistence.NoResultException;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.Tuple;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigInteger;
import java.util.*;
import java.util.stream.Collectors;

@Service
@Log4j2
public class IndicatorLookupService {

    @PersistenceContext
    private EntityManager entityManager;

    /**
     * Finds a destination indicator and series that matches the given phone number.
     * This method perfectly replicates the logic of PHP's `buscarDestino` function.
     *
     * @param phoneNumberToMatch The phone number to find a destination for.
     * @param telephonyTypeId The telephony type context.
     * @param minTotalLengthForType The minimum length required for this telephony type.
     * @param originIndicatorIdForBandContext The origin indicator for band context.
     * @param prefixId The ID of the prefix record being tested. This is crucial for filtering.
     * @param originCountryId The country of origin.
     * @param prefixHasAssociatedBands Whether the prefix has bands, affecting the query.
     * @param isOperatorPrefixAlreadyStripped If the operator prefix was already removed.
     * @param operatorPrefixToStripIfPresent The operator prefix to strip if not already done.
     * @return An Optional containing the best matching DestinationInfo.
     */
    @Transactional(readOnly = true)
    public Optional<DestinationInfo> findDestinationIndicator(
            String phoneNumberToMatch, Long telephonyTypeId, int minTotalLengthForType,
            Long originIndicatorIdForBandContext, Long prefixId, Long originCountryId,
            boolean prefixHasAssociatedBands, boolean isOperatorPrefixAlreadyStripped, String operatorPrefixToStripIfPresent) {

        log.debug("Finding destination indicator. Input: phoneNumberToMatch='{}', telephonyTypeId={}, minTotalLengthForType={}, originIndForBand={}, prefixId={}, originCountryId={}, prefixHasBands={}, opPrefixStripped={}, opPrefixToStrip='{}'",
                phoneNumberToMatch, telephonyTypeId, minTotalLengthForType, originIndicatorIdForBandContext, prefixId, originCountryId, prefixHasAssociatedBands, isOperatorPrefixAlreadyStripped, operatorPrefixToStripIfPresent);

        if (phoneNumberToMatch == null || phoneNumberToMatch.isEmpty()) {
            return Optional.empty();
        }

        String numberForProcessing = phoneNumberToMatch;
        if (numberForProcessing.startsWith("+")) {
            numberForProcessing = numberForProcessing.substring(1);
        }

        if (!isOperatorPrefixAlreadyStripped && operatorPrefixToStripIfPresent != null && !operatorPrefixToStripIfPresent.isEmpty() &&
            numberForProcessing.startsWith(operatorPrefixToStripIfPresent)) {
            numberForProcessing = numberForProcessing.substring(operatorPrefixToStripIfPresent.length());
        }
        String finalNumberUsedForMatching = numberForProcessing;

        Long effectiveTelephonyTypeId = telephonyTypeId;
        Long effectivePrefixId = prefixId;

        if (isLocalType(telephonyTypeId)) {
            String localNdc = findLocalNdcForIndicator(originIndicatorIdForBandContext);
            if (localNdc != null && !localNdc.isEmpty() && !finalNumberUsedForMatching.startsWith(localNdc)) {
                finalNumberUsedForMatching = localNdc + finalNumberUsedForMatching;
                effectiveTelephonyTypeId = TelephonyTypeEnum.NATIONAL.getValue();
                effectivePrefixId = null;
                log.debug("Local call type detected. Transformed number to '{}', search type to NATIONAL, and cleared prefixId for lookup.", finalNumberUsedForMatching);
            }
        }

        IndicatorConfig config = getIndicatorConfigForTelephonyType(effectiveTelephonyTypeId, originCountryId);
        if (config.maxNdcLength == 0 && !isLocalType(effectiveTelephonyTypeId) && !isInternationalOrSatellite(effectiveTelephonyTypeId)) {
            log.debug("No indicator configuration (NDC lengths) found for non-local/non-international type {}. Cannot proceed with lookup.", effectiveTelephonyTypeId);
            return Optional.empty();
        }

        List<String> ndcCandidates = new ArrayList<>();
        int phoneLenForNdcSeries = finalNumberUsedForMatching.length();
        for (int i = config.minNdcLength; i <= config.maxNdcLength; i++) {
            if (i > 0 && phoneLenForNdcSeries >= i) {
                if (phoneLenForNdcSeries >= minTotalLengthForType) {
                    String candidateNdc = finalNumberUsedForMatching.substring(0, i);
                    if (candidateNdc.matches("-?\\d+")) {
                        ndcCandidates.add(candidateNdc);
                    }
                }
            }
        }
        if (isLocalType(effectiveTelephonyTypeId) && phoneLenForNdcSeries >= minTotalLengthForType) {
             if (config.minNdcLength == 0 && config.maxNdcLength == 0 && !ndcCandidates.contains("0")) {
                 ndcCandidates.add("0");
             }
        }
        if (ndcCandidates.isEmpty()) {
             log.debug("No valid NDC candidates could be extracted from number '{}' for type {}.", finalNumberUsedForMatching, effectiveTelephonyTypeId);
             return Optional.empty();
        }

        StringBuilder queryBuilder = new StringBuilder(
            "SELECT i.id as indicator_id, i.operator_id as indicator_operator_id, s.ndc as ndc_val, i.department_country, i.city_name, s.initial_number, s.final_number, b.id as band_id " +
            "FROM series s JOIN indicator i ON s.indicator_id = i.id ");

        StringJoiner whereClauses = new StringJoiner(" AND ");
        whereClauses.add("i.active = true");
        whereClauses.add("s.active = true");
        whereClauses.add("i.telephony_type_id = :effectiveTelephonyTypeId");

        List<Integer> ndcIntCandidates = ndcCandidates.stream()
                                                      .filter(sVal -> !sVal.isEmpty() && sVal.matches("-?\\d+"))
                                                      .map(Integer::parseInt)
                                                      .collect(Collectors.toList());
        if (!ndcIntCandidates.isEmpty()) {
            whereClauses.add("s.ndc IN (:ndcCandidatesInt)");
        } else {
             return Optional.empty();
        }

        // This clause is now correctly bypassed when effectivePrefixId is nullified during transformation.
        if (effectivePrefixId != null) {
            whereClauses.add("(i.operator_id = 0 OR i.operator_id = (SELECT p.operator_id FROM prefix p WHERE p.id = :prefixIdFunc AND p.active = true))");
        }

        if (prefixHasAssociatedBands && effectivePrefixId != null) {
            queryBuilder.append("LEFT JOIN band b ON b.prefix_id = :prefixIdFunc AND b.active = true ");
            queryBuilder.append("LEFT JOIN band_indicator bi ON bi.band_id = b.id AND bi.indicator_id = i.id ");
            whereClauses.add("(b.origin_indicator_id = 0 OR b.origin_indicator_id IS NULL OR b.origin_indicator_id = :originIndicatorIdForBandContext)");
        } else {
            queryBuilder.append("LEFT JOIN band b ON 1=0 ");
        }

        if (!isInternationalOrSatellite(effectiveTelephonyTypeId)) {
            whereClauses.add("i.origin_country_id = :originCountryId");
        }
        queryBuilder.append("WHERE ").append(whereClauses.toString());

        String orderBy = "";
        if (prefixHasAssociatedBands) {
            orderBy += "b.origin_indicator_id DESC NULLS LAST, ";
        }
        orderBy += "s.ndc DESC, s.initial_number ASC, s.final_number ASC";
        queryBuilder.append(" ORDER BY ").append(orderBy);

        jakarta.persistence.Query nativeQuery = entityManager.createNativeQuery(queryBuilder.toString(), Tuple.class);
        nativeQuery.setParameter("effectiveTelephonyTypeId", effectiveTelephonyTypeId);
        if (!ndcIntCandidates.isEmpty()) {
            nativeQuery.setParameter("ndcCandidatesInt", ndcIntCandidates);
        }
        if (effectivePrefixId != null) {
            nativeQuery.setParameter("prefixIdFunc", effectivePrefixId);
        }
        if (prefixHasAssociatedBands && effectivePrefixId != null) {
            nativeQuery.setParameter("originIndicatorIdForBandContext", originIndicatorIdForBandContext);
        }
        if (!isInternationalOrSatellite(effectiveTelephonyTypeId)) {
            nativeQuery.setParameter("originCountryId", originCountryId);
        }

        List<Tuple> results = nativeQuery.getResultList();
        log.debug("Destination indicator query returned {} results.", results.size());

        List<DestinationInfo> validMatches = new ArrayList<>();
        DestinationInfo approximateMatch = null;

        for (Tuple row : results) {
            String dbNdcStr = String.valueOf(row.get("ndc_val", Number.class).intValue());
            String subscriberPartOfEffectiveNumber;
            if (finalNumberUsedForMatching.startsWith(dbNdcStr)) {
                 subscriberPartOfEffectiveNumber = finalNumberUsedForMatching.substring(dbNdcStr.length());
            } else if ((dbNdcStr.equals("0") || dbNdcStr.isEmpty()) && isLocalType(effectiveTelephonyTypeId)) {
                subscriberPartOfEffectiveNumber = finalNumberUsedForMatching;
            } else {
                continue;
            }
            if (!subscriberPartOfEffectiveNumber.matches("\\d*")) {
                continue;
            }
            Integer seriesInitialInt = row.get("initial_number", Integer.class);
            Integer seriesFinalInt = row.get("final_number", Integer.class);

            if (Integer.parseInt(dbNdcStr) < 0) {
                if (approximateMatch == null) {
                    approximateMatch = new DestinationInfo();
                    PaddedSeriesResult paddedApprox = padSeries(subscriberPartOfEffectiveNumber, seriesInitialInt.toString(), seriesFinalInt.toString());
                    String approxComparableInitial = dbNdcStr + paddedApprox.getPaddedInitial();
                    String approxComparableFinal = dbNdcStr + paddedApprox.getPaddedFinal();
                    fillDestinationInfo(approximateMatch, row, dbNdcStr, finalNumberUsedForMatching, effectivePrefixId, true, seriesInitialInt, seriesFinalInt, approxComparableInitial, approxComparableFinal);
                }
                continue;
            }
            PaddedSeriesResult paddedSeries = padSeries(subscriberPartOfEffectiveNumber, seriesInitialInt.toString(), seriesFinalInt.toString());
            String fullComparableSeriesInitial = dbNdcStr + paddedSeries.getPaddedInitial();
            String fullComparableSeriesFinal = dbNdcStr + paddedSeries.getPaddedFinal();
            String numberToCompareAgainstSeries = finalNumberUsedForMatching;
            BigInteger numToCompareBI;
            BigInteger seriesInitialBI;
            BigInteger seriesFinalBI;
            try {
                if (!numberToCompareAgainstSeries.matches("\\d+") || !fullComparableSeriesInitial.matches("\\d+") || !fullComparableSeriesFinal.matches("\\d+")) {
                     continue;
                }
                numToCompareBI = new BigInteger(numberToCompareAgainstSeries);
                seriesInitialBI = new BigInteger(fullComparableSeriesInitial);
                seriesFinalBI = new BigInteger(fullComparableSeriesFinal);
            } catch (NumberFormatException e) {
                continue;
            }
            if (numToCompareBI.compareTo(seriesInitialBI) >= 0 &&
                numToCompareBI.compareTo(seriesFinalBI) <= 0) {
                addMatch(validMatches, row, dbNdcStr, finalNumberUsedForMatching, effectivePrefixId, false, seriesInitialInt, seriesFinalInt, fullComparableSeriesInitial, fullComparableSeriesFinal);
            }
        }

        if (!validMatches.isEmpty()) {
            validMatches.sort(Comparator.comparingLong(DestinationInfo::getPaddedSeriesRangeSize));
            return Optional.of(validMatches.get(0));
        } else if (approximateMatch != null) {
            return Optional.of(approximateMatch);
        }

        return Optional.empty();
    }

    private void addMatch(List<DestinationInfo> matches, Tuple row, String ndc, String originalPhoneNumberUsedForMatch, Long prefixId, boolean isApprox, Integer seriesInitial, Integer seriesFinal, String comparableInitial, String comparableFinal) {
        DestinationInfo di = new DestinationInfo();
        fillDestinationInfo(di, row, ndc, originalPhoneNumberUsedForMatch, prefixId, isApprox, seriesInitial, seriesFinal, comparableInitial, comparableFinal);
        matches.add(di);
    }

    private void fillDestinationInfo(DestinationInfo di, Tuple row, String ndc, String originalPhoneNumberUsedForMatch, Long prefixId, boolean isApprox, Integer seriesInitial, Integer seriesFinal, String comparableInitial, String comparableFinal) {
        di.setIndicatorId(row.get("indicator_id", Number.class).longValue());
        Number indicatorOpIdNum = row.get("indicator_operator_id", Number.class);
        di.setOperatorId(indicatorOpIdNum != null ? indicatorOpIdNum.longValue() : null);
        di.setNdc(ndc);
        di.setDestinationDescription(formatDestinationDescription(row.get("city_name", String.class), row.get("department_country", String.class)));
        di.setMatchedPhoneNumber(originalPhoneNumberUsedForMatch);
        di.setPrefixId(prefixId);
        Number bandIdNum = row.get("band_id", Number.class);
        di.setBandId(bandIdNum != null ? bandIdNum.longValue() : null);
        di.setApproximateMatch(isApprox);
        di.setSeriesInitial(seriesInitial);
        di.setSeriesFinal(seriesFinal);
        di.setComparableInitialValue(comparableInitial);
        di.setComparableFinalValue(comparableFinal);
        if (isApprox) {
            di.setDestinationDescription(di.getDestinationDescription() + " (aprox)");
        }
    }

    private String formatDestinationDescription(String city, String deptCountry) {
        StringBuilder sb = new StringBuilder();
        if (city != null && !city.isEmpty()) sb.append(city);
        if (deptCountry != null && !deptCountry.isEmpty()) {
            if (sb.length() > 0) sb.append(", ");
            sb.append(deptCountry);
        }
        return sb.toString();
    }

    private PaddedSeriesResult padSeries(String inputSubscriberPart, String dbSeriesInitial, String dbSeriesFinal) {
        String safeDbSeriesInitial = dbSeriesInitial != null ? dbSeriesInitial : "0";
        String safeDbSeriesFinal = dbSeriesFinal != null ? dbSeriesFinal : "0";
        int lenInitialDb = safeDbSeriesInitial.length();
        int lenFinalDb = safeDbSeriesFinal.length();
        String equalizedDbInitial = safeDbSeriesInitial;
        String equalizedDbFinal = safeDbSeriesFinal;
        if (lenInitialDb < lenFinalDb) {
            equalizedDbInitial = String.format("%0" + lenFinalDb + "d", Long.parseLong(safeDbSeriesInitial));
        } else if (lenFinalDb < lenInitialDb) {
            equalizedDbFinal = String.format("%-" + lenInitialDb + "s", safeDbSeriesFinal).replace(' ', '9');
        }
        int inputSubLen = inputSubscriberPart.length();
        int currentEqualizedSeriesLen = equalizedDbInitial.length();
        String finalPaddedInitial = equalizedDbInitial;
        String finalPaddedFinal = equalizedDbFinal;
        if (inputSubLen != currentEqualizedSeriesLen) {
            if (inputSubLen == 0) {
                finalPaddedInitial = "";
                finalPaddedFinal = "";
            } else {
                 finalPaddedInitial = String.format("%-" + inputSubLen + "s", equalizedDbInitial).replace(' ', '0');
                 finalPaddedFinal = String.format("%-" + inputSubLen + "s", equalizedDbFinal).replace(' ', '9');
            }
        }
        return new PaddedSeriesResult(finalPaddedInitial, finalPaddedFinal);
    }

    @Transactional(readOnly = true)
    public IndicatorConfig getIndicatorConfigForTelephonyType(Long telephonyTypeId, Long originCountryId) {
        String queryStr = "SELECT " +
                          "COALESCE(MIN(LENGTH(s.ndc::text)), 0) as min_ndc_len, " +
                          "COALESCE(MAX(LENGTH(s.ndc::text)), 0) as max_ndc_len, " +
                          "(SELECT LENGTH(s2.initial_number::text) FROM series s2 JOIN indicator i2 ON s2.indicator_id = i2.id WHERE i2.telephony_type_id = :telephonyTypeId " +
                          (isInternationalOrSatellite(telephonyTypeId) ? "" : "AND i2.origin_country_id = :originCountryId ") +
                          "AND s2.active = true AND i2.active = true AND s2.initial_number >= 0 GROUP BY LENGTH(s2.initial_number::text) ORDER BY COUNT(*) DESC LIMIT 1) as common_series_len " +
                          "FROM series s JOIN indicator i ON s.indicator_id = i.id " +
                          "WHERE i.telephony_type_id = :telephonyTypeId " +
                          (isInternationalOrSatellite(telephonyTypeId) ? "" : "AND i.origin_country_id = :originCountryId ") +
                          "AND s.active = true AND i.active = true AND s.initial_number >= 0";
        jakarta.persistence.Query nativeQuery = entityManager.createNativeQuery(queryStr, Tuple.class);
        nativeQuery.setParameter("telephonyTypeId", telephonyTypeId);
        if (!isInternationalOrSatellite(telephonyTypeId)) {
            nativeQuery.setParameter("originCountryId", originCountryId);
        }
        IndicatorConfig config = new IndicatorConfig();
        try {
            Tuple result = (Tuple) nativeQuery.getSingleResult();
            config.minNdcLength = result.get("min_ndc_len", Number.class).intValue();
            config.maxNdcLength = result.get("max_ndc_len", Number.class).intValue();
            Number commonSeriesLenNum = result.get("common_series_len", Number.class);
            config.seriesNumberLength = (commonSeriesLenNum != null) ? commonSeriesLenNum.intValue() : 0;
            if (isInternationalOrSatellite(telephonyTypeId) && config.minNdcLength == 0 && config.maxNdcLength == 0) {
                config.minNdcLength = 1;
                config.maxNdcLength = 4;
            }
        } catch (NoResultException e) {
             if (isInternationalOrSatellite(telephonyTypeId)) {
                config.minNdcLength = 1;
                config.maxNdcLength = 4;
            }
        }
        return config;
    }

    @Transactional(readOnly = true)
    public String findLocalNdcForIndicator(Long indicatorId) {
        if (indicatorId == null) return "";
        String queryStr = "SELECT s.ndc FROM series s WHERE s.indicator_id = :indicatorId AND s.active = true " +
                          "GROUP BY s.ndc ORDER BY COUNT(*) DESC, s.ndc ASC LIMIT 1";
        jakarta.persistence.Query nativeQuery = entityManager.createNativeQuery(queryStr);
        nativeQuery.setParameter("indicatorId", indicatorId);
        try {
            Object result = nativeQuery.getSingleResult();
            return result != null ? String.valueOf(((Number)result).intValue()) : "";
        } catch (NoResultException e) {
            return "";
        }
    }

    @Transactional(readOnly = true)
    public boolean isLocalExtended(String destinationNdc, Long localOriginIndicatorId, Long destinationIndicatorId) {
        if (Objects.equals(localOriginIndicatorId, destinationIndicatorId) || destinationIndicatorId == null || localOriginIndicatorId == null || destinationIndicatorId <= 0 || localOriginIndicatorId <= 0 || destinationNdc == null) {
            return false;
        }
        String ndcsForLocalOriginQuery = "SELECT DISTINCT s.ndc FROM series s WHERE s.indicator_id = :localOriginIndicatorId AND s.active = true";
        List<Number> localNdcsNum = entityManager.createNativeQuery(ndcsForLocalOriginQuery)
                                    .setParameter("localOriginIndicatorId", localOriginIndicatorId)
                                    .getResultList();
        List<String> localNdcs = localNdcsNum.stream().map(n -> String.valueOf(n.intValue())).collect(Collectors.toList());
        return localNdcs.contains(destinationNdc);
    }

    private boolean isLocalType(Long telephonyTypeId) {
        return telephonyTypeId != null &&
                (telephonyTypeId.equals(TelephonyTypeEnum.LOCAL.getValue()) ||
                 telephonyTypeId.equals(TelephonyTypeEnum.LOCAL_EXTENDED.getValue()));
    }

    private boolean isInternationalOrSatellite(Long telephonyTypeId) {
        return telephonyTypeId != null &&
               (telephonyTypeId.equals(TelephonyTypeEnum.INTERNATIONAL.getValue()) ||
                telephonyTypeId.equals(TelephonyTypeEnum.SATELLITE.getValue()));
    }
}

============================================================
FILE: InternalCallProcessorService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/InternalCallProcessorService.java
SIZE: 15.69 KB
MODIFIED: 2026-02-27 10:55:54
============================================================
// File: com/infomedia/abacox/telephonypricing/component/cdrprocessing/InternalCallProcessorService.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.CommunicationLocation;
import com.infomedia.abacox.telephonypricing.db.entity.Employee;
import com.infomedia.abacox.telephonypricing.db.entity.Indicator;
import com.infomedia.abacox.telephonypricing.db.entity.Subdivision;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@Service
@Log4j2
@RequiredArgsConstructor
public class InternalCallProcessorService {

    private final EmployeeLookupService employeeLookupService;
    private final TariffCalculationService tariffCalculationService;
    private final CdrConfigService appConfigService;
    private final TelephonyTypeLookupService telephonyTypeLookupService;
    private final PrefixLookupService prefixLookupService;

    public void processInternal(CdrData cdrData, LineProcessingContext processingContext,
                                boolean pbxSpecialRuleAppliedRecursively) {
        CommunicationLocation commLocation = processingContext.getCommLocation();
        log.debug("Processing INTERNAL call logic for CDR: {}. Recursive PBX applied: {}", cdrData.getCtlHash(),
                pbxSpecialRuleAppliedRecursively);

        List<String> prefixesToClean = Collections.emptyList();
        boolean stripOnlyIfPrefixMatchesAndFound = false;
        if (pbxSpecialRuleAppliedRecursively && commLocation.getPbxPrefix() != null
                && !commLocation.getPbxPrefix().isEmpty()) {
            prefixesToClean = Arrays.asList(commLocation.getPbxPrefix().split(","));
            stripOnlyIfPrefixMatchesAndFound = true;
        }

        String cleanedDestination = CdrUtil.cleanPhoneNumber(
                cdrData.getEffectiveDestinationNumber(),
                prefixesToClean,
                stripOnlyIfPrefixMatchesAndFound).getCleanedNumber();
        cdrData.setEffectiveDestinationNumber(cleanedDestination);
        log.debug("Cleaned internal destination: {}", cleanedDestination);

        if (cdrData.getCallingPartyNumber() != null && !cdrData.getCallingPartyNumber().trim().isEmpty() &&
                Objects.equals(cdrData.getCallingPartyNumber().trim(), cleanedDestination.trim())) {
            log.debug("Internal call to self (Origin: {}, Destination: {}). Marking for quarantine.",
                    cdrData.getCallingPartyNumber(), cleanedDestination);
            cdrData.setTelephonyTypeId(TelephonyTypeEnum.ERRORS.getValue());
            cdrData.setTelephonyTypeName("Internal Self-Call (Ignored)");
            cdrData.setMarkedForQuarantine(true);
            cdrData.setQuarantineReason("Internal call to self (PHP: IGUALDESTINO)");
            cdrData.setQuarantineStep(QuarantineErrorType.INTERNAL_SELF_CALL.name());
            return;
        }

        InternalCallTypeInfo internalTypeInfo = determineSpecificInternalCallType(cdrData, processingContext);
        log.debug("Determined specific internal call type info: {}", internalTypeInfo);

        if (internalTypeInfo.isIgnoreCall()) {
            log.debug("Internal call marked to be ignored. Reason: {}", internalTypeInfo.getAdditionalInfo());
            cdrData.setTelephonyTypeId(TelephonyTypeEnum.ERRORS.getValue());
            cdrData.setTelephonyTypeName(
                    "Internal Call Ignored (Policy: " + internalTypeInfo.getAdditionalInfo() + ")");
            cdrData.setMarkedForQuarantine(true);
            cdrData.setQuarantineReason(
                    internalTypeInfo.getAdditionalInfo() != null ? internalTypeInfo.getAdditionalInfo()
                            : "Internal call ignore policy");

            // Apply specific error type mapped in determination phase
            cdrData.setQuarantineStep(internalTypeInfo.getErrorType() != null
                    ? internalTypeInfo.getErrorType().name()
                    : QuarantineErrorType.INTERNAL_POLICY_IGNORE.name());
            return;
        }

        // PHP: procesaInterna -> InvertirLlamada if origin not found but destination is.
        if (internalTypeInfo.isEffectivelyIncoming() && cdrData.getCallDirection() == CallDirection.OUTGOING) {
            log.debug("Internal call determined to be effectively incoming. Inverting parties and trunks. CDR: {}",
                    cdrData.getCtlHash());
            CdrUtil.swapFull(cdrData, true); // Full swap including trunks
            cdrData.setCallDirection(CallDirection.INCOMING);

            cdrData.setEmployee(internalTypeInfo.getDestinationEmployee());
            cdrData.setEmployeeId(internalTypeInfo.getDestinationEmployee() != null
                    ? internalTypeInfo.getDestinationEmployee().getId() : null);

            cdrData.setDestinationEmployee(internalTypeInfo.getOriginEmployee());
            cdrData.setDestinationEmployeeId(
                    internalTypeInfo.getOriginEmployee() != null ? internalTypeInfo.getOriginEmployee().getId() : null);

            cdrData.setIndicatorId(internalTypeInfo.getDestinationIndicatorId());
        } else {
            // Standard assignment if not inverted
            cdrData.setEmployee(internalTypeInfo.getOriginEmployee());
            cdrData.setEmployeeId(
                    internalTypeInfo.getOriginEmployee() != null ? internalTypeInfo.getOriginEmployee().getId() : null);
            cdrData.setDestinationEmployee(internalTypeInfo.getDestinationEmployee());
            cdrData.setDestinationEmployeeId(internalTypeInfo.getDestinationEmployee() != null
                    ? internalTypeInfo.getDestinationEmployee().getId() : null);
            cdrData.setIndicatorId(internalTypeInfo.getDestinationIndicatorId());
        }

        cdrData.setTelephonyTypeId(internalTypeInfo.getTelephonyTypeId());
        cdrData.setTelephonyTypeName(internalTypeInfo.getTelephonyTypeName());
        if (internalTypeInfo.getAdditionalInfo() != null && !internalTypeInfo.getAdditionalInfo().isEmpty()) {
            cdrData.setTelephonyTypeName(cdrData.getTelephonyTypeName() + " " + internalTypeInfo.getAdditionalInfo());
        }

        if (cdrData.getTelephonyTypeId() != null && commLocation.getIndicator() != null) {
            OperatorInfo internalOp = telephonyTypeLookupService.getInternalOperatorInfo(
                    cdrData.getTelephonyTypeId(), commLocation.getIndicator().getOriginCountryId());
            cdrData.setOperatorId(internalOp.getId());
            cdrData.setOperatorName(internalOp.getName());
        }

        tariffCalculationService.calculateTariffsForInternal(cdrData, commLocation);
        log.debug("Finished processing INTERNAL call logic. CDR Data: {}", cdrData);
    }

    private InternalCallTypeInfo determineSpecificInternalCallType(CdrData cdrData,
                                                                   LineProcessingContext processingContext) {
        CommunicationLocation currentCommLocation = processingContext.getCommLocation();
        List<String> ignoredAuthCodes = processingContext.getCdrProcessor().getIgnoredAuthCodeDescriptions();
        log.debug("Determining specific internal call type for Calling: {}, Destination: {}",
                cdrData.getCallingPartyNumber(), cdrData.getEffectiveDestinationNumber());

        InternalCallTypeInfo result = new InternalCallTypeInfo();
        result.setTelephonyTypeId(appConfigService.getDefaultTelephonyTypeForUnresolvedInternalCalls());
        result.setTelephonyTypeName(telephonyTypeLookupService.getTelephonyTypeName(result.getTelephonyTypeId()));
        result.setDestinationIndicatorId(currentCommLocation.getIndicatorId());
        result.setOriginIndicatorId(currentCommLocation.getIndicatorId());

        ExtensionLimits limits = processingContext.getCommLocationExtensionLimits();

        Optional<Employee> originEmpOpt = employeeLookupService.findEmployeeByExtensionOrAuthCode(
                cdrData.getCallingPartyNumber(), null,
                currentCommLocation.getId(), ignoredAuthCodes, processingContext.getExtensionRanges(),
                cdrData.getDateTimeOrigination(), processingContext.getHistoricalData());
        if (originEmpOpt.isEmpty() && CdrUtil.isPossibleExtension(cdrData.getCallingPartyNumber(), limits)) {
            originEmpOpt = employeeLookupService.findEmployeeByExtensionRange(cdrData.getCallingPartyNumber(),
                    currentCommLocation.getId(), processingContext.getExtensionRanges(),
                    cdrData.getDateTimeOrigination(), processingContext.getHistoricalData());
        }
        result.setOriginEmployee(originEmpOpt.orElse(null));

        Optional<Employee> destEmpOpt = employeeLookupService.findEmployeeByExtensionOrAuthCode(
                cdrData.getEffectiveDestinationNumber(), null,
                null, ignoredAuthCodes, processingContext.getExtensionRanges(),
                cdrData.getDateTimeOrigination(), processingContext.getHistoricalData());
        if (destEmpOpt.isEmpty() && CdrUtil.isPossibleExtension(cdrData.getEffectiveDestinationNumber(), limits)) {
            destEmpOpt = employeeLookupService.findEmployeeByExtensionRange(cdrData.getEffectiveDestinationNumber(),
                    null, processingContext.getExtensionRanges(),
                    cdrData.getDateTimeOrigination(), processingContext.getHistoricalData());
        }
        result.setDestinationEmployee(destEmpOpt.orElse(null));

        CommunicationLocation originCommLoc = originEmpOpt.map(Employee::getCommunicationLocation)
                .orElse(currentCommLocation);
        CommunicationLocation destCommLoc = destEmpOpt.map(Employee::getCommunicationLocation).orElse(null);

        if (originCommLoc != null && destCommLoc == null && originEmpOpt.isPresent()) {
            destCommLoc = currentCommLocation;
            log.debug("Destination employee not found for internal call; assuming destination is within current commLocation: {}",
                    currentCommLocation.getDirectory());
        }

        boolean extGlobales = appConfigService.areExtensionsGlobal();
        if (extGlobales && originCommLoc != null && destCommLoc != null &&
                (!Objects.equals(currentCommLocation.getId(), originCommLoc.getId())
                        || !Objects.equals(currentCommLocation.getId(), destCommLoc.getId()))) {
            if (!Objects.equals(currentCommLocation.getId(), originCommLoc.getId())
                    && Objects.equals(currentCommLocation.getId(), destCommLoc.getId())) {
                result.setIgnoreCall(true);
                result.setErrorType(QuarantineErrorType.GLOBAL_EXTENSION_IGNORE); // Specifically apply GLOBAL_EXTENSION_IGNORE
                result.setAdditionalInfo("Global Extension - Incoming internal from another plant");
                return result;
            } else if (!Objects.equals(currentCommLocation.getId(), originCommLoc.getId())
                    && !Objects.equals(currentCommLocation.getId(), destCommLoc.getId())) {
                result.setIgnoreCall(true);
                result.setErrorType(QuarantineErrorType.GLOBAL_EXTENSION_IGNORE); // Specifically apply GLOBAL_EXTENSION_IGNORE
                result.setAdditionalInfo("Global Extension - Internal call between two other plants");
                return result;
            }
        }

        if (destEmpOpt.isEmpty()) {
            Map<String, Long> internalPrefixes = prefixLookupService.getInternalTelephonyTypePrefixes(
                    currentCommLocation.getIndicator().getOriginCountryId());
            boolean prefixMatched = false;
            for (Map.Entry<String, Long> entry : internalPrefixes.entrySet()) {
                if (cdrData.getEffectiveDestinationNumber().startsWith(entry.getKey())) {
                    result.setTelephonyTypeId(entry.getValue());
                    result.setTelephonyTypeName(telephonyTypeLookupService.getTelephonyTypeName(entry.getValue()));
                    result.setAdditionalInfo(appConfigService.getPrefixText());
                    prefixMatched = true;
                    break;
                }
            }
            if (!prefixMatched) {
                Long defaultUnresolvedType = appConfigService.getDefaultTelephonyTypeForUnresolvedInternalCalls();
                result.setTelephonyTypeId(defaultUnresolvedType);
                result.setTelephonyTypeName(
                        telephonyTypeLookupService.getTelephonyTypeName(result.getTelephonyTypeId()));
                result.setAdditionalInfo(appConfigService.getAssumedText());
            }
        } else if (originCommLoc != null && destCommLoc != null && originCommLoc.getIndicator() != null
                && destCommLoc.getIndicator() != null) {
            Indicator originIndicator = originCommLoc.getIndicator();
            Indicator destIndicator = destCommLoc.getIndicator();
            result.setOriginIndicatorId(originIndicator.getId());
            result.setDestinationIndicatorId(destIndicator.getId());

            Subdivision originSubdivision = originEmpOpt.map(Employee::getSubdivision).orElse(null);
            Long originOfficeId = originSubdivision != null ? originSubdivision.getId() : null;
            Subdivision destSubdivision = destEmpOpt.map(Employee::getSubdivision).orElse(null);
            Long destOfficeId = destSubdivision != null ? destSubdivision.getId() : null;

            if (!Objects.equals(originIndicator.getOriginCountryId(), destIndicator.getOriginCountryId())) {
                result.setTelephonyTypeId(TelephonyTypeEnum.INTERNAL_INTERNATIONAL_IP.getValue());
            } else if (!Objects.equals(originIndicator.getId(), destIndicator.getId())) {
                result.setTelephonyTypeId(TelephonyTypeEnum.NATIONAL_IP.getValue());
            } else if (originOfficeId != null && destOfficeId != null
                    && !Objects.equals(originOfficeId, destOfficeId)) {
                result.setTelephonyTypeId(TelephonyTypeEnum.LOCAL_IP.getValue());
            } else {
                result.setTelephonyTypeId(TelephonyTypeEnum.INTERNAL_SIMPLE.getValue());
            }
            result.setTelephonyTypeName(telephonyTypeLookupService.getTelephonyTypeName(result.getTelephonyTypeId()));
            if (originEmpOpt.isEmpty()) {
                result.setAdditionalInfo(appConfigService.getAssumedText() + "/" + appConfigService.getOriginText());
            }
        } else {
            result.setTelephonyTypeId(appConfigService.getDefaultTelephonyTypeForUnresolvedInternalCalls());
            result.setTelephonyTypeName(telephonyTypeLookupService.getTelephonyTypeName(result.getTelephonyTypeId()));
            result.setAdditionalInfo(appConfigService.getAssumedText());
            if (originCommLoc != null && originCommLoc.getIndicator() != null)
                result.setOriginIndicatorId(originCommLoc.getIndicator().getId());
            if (destCommLoc != null && destCommLoc.getIndicator() != null)
                result.setDestinationIndicatorId(destCommLoc.getIndicator().getId());
        }

        if (originEmpOpt.isEmpty() && destEmpOpt.isPresent() &&
                cdrData.getCallDirection() == CallDirection.OUTGOING &&
                destCommLoc != null && Objects.equals(destCommLoc.getId(), currentCommLocation.getId())) {

            boolean isBridge = cdrData.getConferenceIdentifierUsed() != null;
            if (!isBridge) {
                result.setEffectivelyIncoming(true);
            }
        }
        return result;
    }
}

============================================================
FILE: InternalCallTypeInfo.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/InternalCallTypeInfo.java
SIZE: 0.78 KB
MODIFIED: 2026-02-27 10:55:24
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.Employee;
import lombok.Data;

@Data
public class InternalCallTypeInfo {
    private Long telephonyTypeId;
    private String telephonyTypeName;
    private Long destinationIndicatorId; // Indicator of the destination employee
    private Long originIndicatorId;    // Indicator of the origin employee
    private String additionalInfo;
    private boolean ignoreCall = false;
    private QuarantineErrorType errorType; // Holds the specific reason if ignored
    private boolean effectivelyIncoming = false; // If the call should be treated as incoming despite initial parsing
    private Employee originEmployee;
    private Employee destinationEmployee;
}

============================================================
FILE: LineProcessingContext.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/LineProcessingContext.java
SIZE: 1.53 KB
MODIFIED: 2026-02-24 23:41:41
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.CommunicationLocation;
import com.infomedia.abacox.telephonypricing.db.entity.ExtensionRange;
import com.infomedia.abacox.telephonypricing.db.entity.FileInfo;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;

import java.util.List;
import java.util.Map;

@Data
@AllArgsConstructor
@Builder
public class LineProcessingContext {
    private String cdrLine;
    private CommunicationLocation commLocation;
    private CdrProcessor cdrProcessor;
    private Map<Long, List<ExtensionRange>> extensionRanges;
    private Map<Long, ExtensionLimits> extensionLimits;
    private FileInfo fileInfo;
    private HistoricalDataContainer historicalData;

    // Added: Holds the CSV column mapping for the specific file being processed
    private Map<String, Integer> headerPositions;

    public ExtensionLimits getCommLocationExtensionLimits() {
        return extensionLimits.get(commLocation.getId());
    }

    public List<ExtensionRange> getCommLocationExtensionRanges() {
        return extensionRanges.get(commLocation.getId());
    }

    public Long getFileInfoId() {
        return fileInfo != null ? fileInfo.getId() : null;
    }

    public Long getCommLocationId() {
        return commLocation != null ? commLocation.getId() : null;
    }

    public List<String> getIgnoredAuthCodes() {
        return cdrProcessor.getIgnoredAuthCodeDescriptions();
    }
}

============================================================
FILE: OperatorInfo.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/OperatorInfo.java
SIZE: 0.26 KB
MODIFIED: 2025-06-04 13:40:58
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;

@Getter
@AllArgsConstructor
@Data
public class OperatorInfo {
    private Long id;
    private String name;
}

============================================================
FILE: OperatorLookupService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/OperatorLookupService.java
SIZE: 4.44 KB
MODIFIED: 2025-08-28 14:36:42
============================================================
// File: com/infomedia/abacox/telephonypricing/cdr/OperatorLookupService.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.Operator;
import jakarta.persistence.EntityManager;
import jakarta.persistence.NoResultException;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.Tuple;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

@Service
@Log4j2
public class OperatorLookupService {

    @PersistenceContext
    private EntityManager entityManager;

    @Transactional(readOnly = true)
    public Optional<OperatorInfo> findOperatorById(Long operatorId) {
        if (operatorId == null || operatorId == 0L) {
            return Optional.empty();
        }
        try {
            Operator operator = entityManager.find(Operator.class, operatorId);
            if (operator != null && operator.isActive()) {
                return Optional.of(new OperatorInfo(operator.getId(), operator.getName()));
            }
            return Optional.empty();
        } catch (Exception e) {
            log.debug("Could not find operator for ID: {}", operatorId, e);
            return Optional.empty();
        }
    }

    /**
     * Finds an operator for an incoming cellular call based on the destination indicator's bands.
     * This replicates the specific PHP logic:
     * $sql_op = "SELECT PREFIJO_OPERADOR_ID FROM banda, bandaindica, prefijo
     * WHERE BANDAINDICA_INDICATIVO_ID = ".$indicativo_destino."
     * AND BANDA_ID = BANDAINDICA_BANDA_ID AND PREFIJO_ID = BANDA_PREFIJO_ID";
     *
     * @param destinationIndicatorId The indicator ID of the (incoming) cellular number.
     * @return Optional<OperatorInfo>
     */
    @Transactional(readOnly = true)
    public Optional<OperatorInfo> findOperatorForIncomingCellularByIndicatorBands(Long destinationIndicatorId) {
        if (destinationIndicatorId == null || destinationIndicatorId <= 0) {
            return Optional.empty();
        }

        String queryStr = "SELECT DISTINCT p.operator_id as operator_id, op.name as operator_name " +
                          "FROM band b " +
                          "JOIN band_indicator bi ON b.id = bi.band_id " +
                          "JOIN prefix p ON b.prefix_id = p.id " +
                          "JOIN operator op ON p.operator_id = op.id " +
                          "WHERE bi.indicator_id = :destinationIndicatorId " +
                          "AND b.active = true AND p.active = true AND op.active = true " +
                          "AND p.telephony_type_id = :cellularTelephonyTypeId " + // Ensure the prefix is for cellular
                          "LIMIT 1"; // PHP takes the first one found

        jakarta.persistence.Query nativeQuery = entityManager.createNativeQuery(queryStr, Tuple.class);
        nativeQuery.setParameter("destinationIndicatorId", destinationIndicatorId);
        nativeQuery.setParameter("cellularTelephonyTypeId", TelephonyTypeEnum.CELLULAR.getValue());

        try {
            Tuple result = (Tuple) nativeQuery.getSingleResult();
            Long operatorId = result.get("operator_id", Number.class).longValue();
            String operatorName = result.get("operator_name", String.class);
            if (operatorId > 0) {
                log.debug("Found operator {} ({}) for incoming cellular via indicator {} bands.",
                        operatorName, operatorId, destinationIndicatorId);
                return Optional.of(new OperatorInfo(operatorId, operatorName));
            }
        } catch (NoResultException e) {
            log.debug("No operator found for incoming cellular via indicator {} bands.", destinationIndicatorId);
        }
        return Optional.empty();
    }


    @Transactional(readOnly = true)
    public String findOperatorNameById(Long operatorId) {
        if (operatorId == null || operatorId == 0L) {
            return "Unknown Operator";
        }
        try {
            Operator operator = entityManager.find(Operator.class, operatorId);
            return operator != null ? operator.getName() : "OperatorID:" + operatorId;
        } catch (Exception e) {
            log.debug("Could not find operator name for ID: {}", operatorId, e);
            return "OperatorID:" + operatorId;
        }
    }
}

============================================================
FILE: OutgoingCallProcessorService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/OutgoingCallProcessorService.java
SIZE: 5.39 KB
MODIFIED: 2025-08-28 14:31:58
============================================================
// File: com/infomedia/abacox/telephonypricing/component/cdrprocessing/OutgoingCallProcessorService.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.CommunicationLocation;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

@Service
@Log4j2
@RequiredArgsConstructor
public class OutgoingCallProcessorService {

    private final SpecialServiceLookupService specialServiceLookupService;
    private final PbxSpecialRuleLookupService pbxSpecialRuleLookupService;
    private final TariffCalculationService tariffCalculationService;
    private final PhoneNumberTransformationService phoneNumberTransformationService;

    /**
     * PHP equivalent: procesaSaliente
     */
    public void processOutgoing(CdrData cdrData, LineProcessingContext processingContext, boolean pbxSpecialRuleAppliedRecursively) {
        CommunicationLocation commLocation = processingContext.getCommLocation();
        log.debug("Processing OUTGOING logic for CDR: {}. Recursive PBX applied: {}", cdrData.getCtlHash(), pbxSpecialRuleAppliedRecursively);

        TransformationResult transformedOutgoingCME = phoneNumberTransformationService.transformOutgoingNumberCME(
                cdrData.getFinalCalledPartyNumber(), commLocation.getIndicator().getOriginCountryId()
        );
        if (transformedOutgoingCME.isTransformed()) {
            log.debug("Outgoing number '{}' transformed by CME rule to '{}'", cdrData.getFinalCalledPartyNumber(), transformedOutgoingCME.getTransformedNumber());
            cdrData.setOriginalDialNumberBeforeCMETransform(cdrData.getFinalCalledPartyNumber());
            cdrData.setFinalCalledPartyNumber(transformedOutgoingCME.getTransformedNumber());
        }
        cdrData.setEffectiveDestinationNumber(cdrData.getFinalCalledPartyNumber());

        if (!pbxSpecialRuleAppliedRecursively) { // This check is now sufficient, no need for !isInternalCall
            List<String> pbxPrefixes = commLocation.getPbxPrefix() != null ? Arrays.asList(commLocation.getPbxPrefix().split(",")) : Collections.emptyList();
            String numToCheckSpecial = CdrUtil.cleanPhoneNumber(
                    cdrData.getEffectiveDestinationNumber(),
                    pbxPrefixes,
                    true
            ).getCleanedNumber();
            if (numToCheckSpecial != null && !numToCheckSpecial.isEmpty()) {
                log.debug("Checking for special service with number: {}", numToCheckSpecial);
                Optional<SpecialServiceInfo> specialServiceInfoOpt =
                        specialServiceLookupService.findSpecialService(
                                numToCheckSpecial,
                                commLocation.getIndicatorId(),
                                commLocation.getIndicator().getOriginCountryId()
                        );
                if (specialServiceInfoOpt.isPresent()) {
                    SpecialServiceInfo ssi = specialServiceInfoOpt.get();
                    log.debug("Call to special service '{}' identified.", ssi.description);
                    cdrData.setTelephonyTypeId(TelephonyTypeEnum.SPECIAL_SERVICES.getValue());
                    cdrData.setTelephonyTypeName(ssi.description);
                    cdrData.setOperatorId(ssi.operatorId);
                    cdrData.setOperatorName(ssi.operatorName);
                    cdrData.setIndicatorId(commLocation.getIndicatorId());
                    cdrData.setEffectiveDestinationNumber(numToCheckSpecial);
                    cdrData.setSpecialServiceTariff(ssi);
                    tariffCalculationService.calculateTariffsForSpecialService(cdrData);
                    return;
                }
            }
        }

        if (!pbxSpecialRuleAppliedRecursively) {
            Optional<String> pbxTransformedDest = pbxSpecialRuleLookupService.applyPbxSpecialRule(
                    cdrData.getEffectiveDestinationNumber(), commLocation.getDirectory(), PbxRuleDirection.OUTGOING.getValue()
            );
            if (pbxTransformedDest.isPresent() && !Objects.equals(pbxTransformedDest.get(), cdrData.getEffectiveDestinationNumber())) {
                String originalDest = cdrData.getEffectiveDestinationNumber();
                log.debug("Outgoing number '{}' transformed by PBX rule to '{}'. Reprocessing.", originalDest, pbxTransformedDest.get());
                cdrData.setOriginalDialNumberBeforePbxOutgoing(originalDest);
                cdrData.setFinalCalledPartyNumber(pbxTransformedDest.get());
                cdrData.setEffectiveDestinationNumber(pbxTransformedDest.get());
                cdrData.setPbxSpecialRuleAppliedInfo("PBX Outgoing Rule: " + originalDest + " -> " + pbxTransformedDest.get());
                processOutgoing(cdrData, processingContext, true);
                return;
            }
        }

        log.debug("Proceeding to standard outgoing tariff calculation for destination: {}", cdrData.getEffectiveDestinationNumber());
        tariffCalculationService.calculateTariffsForOutgoing(cdrData, commLocation, processingContext.getCommLocationExtensionLimits());
        log.debug("Finished processing OUTGOING logic. CDR Data: {}", cdrData);
    }
}

============================================================
FILE: PaddedSeriesResult.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/PaddedSeriesResult.java
SIZE: 0.22 KB
MODIFIED: 2025-06-04 13:42:59
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import lombok.Data;

@Data
public class PaddedSeriesResult {
    private final String paddedInitial;
    private final String paddedFinal;
}


============================================================
FILE: PbxRuleDirection.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/PbxRuleDirection.java
SIZE: 0.35 KB
MODIFIED: 2025-06-04 13:40:58
============================================================

package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import lombok.Getter;

@Getter
public enum PbxRuleDirection {
    BOTH(0),    // Applies to incoming and outgoing
    INCOMING(1),
    OUTGOING(2),
    INTERNAL(3);

    private final int value;

    PbxRuleDirection(int value) {
        this.value = value;
    }
}

============================================================
FILE: PbxSpecialRuleLookupService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/PbxSpecialRuleLookupService.java
SIZE: 3.13 KB
MODIFIED: 2025-06-11 16:13:10
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.PbxSpecialRule;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
@Log4j2
public class PbxSpecialRuleLookupService {

    @PersistenceContext
    private EntityManager entityManager;

    @Transactional(readOnly = true)
    public Optional<String> applyPbxSpecialRule(String dialedNumber, String commDirectory, int callDirectionType) {
        // PHP's evaluarPBXEspecial
        // The clientBdName part is tricky as it's not directly in PbxSpecialRule.
        // Assuming comm_location_id on PbxSpecialRule links to a CommunicationLocation which then links to a Client.
        // For now, we'll use commDirectory if PbxSpecialRule.comm_location_id is set.

        String queryStr = "SELECT p.* FROM pbx_special_rule p " +
                          "LEFT JOIN communication_location cl ON p.comm_location_id = cl.id " +
                          "WHERE p.active = true " +
                          "AND (p.comm_location_id IS NULL OR cl.directory = :commDirectory) " + // Applies to all or specific directory
                          "AND (p.direction = 0 OR p.direction = :callDirectionType) " + // 0=both, 1=in, 2=out, 3=internal
                          "ORDER BY p.comm_location_id DESC NULLS LAST, LENGTH(p.search_pattern) DESC"; // Prefer specific, then longer patterns

        jakarta.persistence.Query nativeQuery = entityManager.createNativeQuery(queryStr, PbxSpecialRule.class);
        nativeQuery.setParameter("commDirectory", commDirectory);
        nativeQuery.setParameter("callDirectionType", callDirectionType);

        List<PbxSpecialRule> rules = nativeQuery.getResultList();

        for (PbxSpecialRule rule : rules) {
            if (dialedNumber.startsWith(rule.getSearchPattern())) {
                if (rule.getMinLength() != null && dialedNumber.length() < rule.getMinLength()) {
                    continue;
                }
                boolean ignore = false;
                if (rule.getIgnorePattern() != null && !rule.getIgnorePattern().isEmpty()) {
                    String[] ignorePatterns = rule.getIgnorePattern().split(",");
                    for (String ignorePat : ignorePatterns) {
                        if (dialedNumber.startsWith(ignorePat.trim())) {
                            ignore = true;
                            break;
                        }
                    }
                }
                if (!ignore) {
                    String transformedNumber = rule.getReplacement() + dialedNumber.substring(rule.getSearchPattern().length());
                    log.debug("Applied PBX rule '{}': {} -> {}", rule.getName(), dialedNumber, transformedNumber);
                    return Optional.of(transformedNumber);
                }
            }
        }
        return Optional.empty();
    }
}

============================================================
FILE: PhoneNumberTransformationService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/PhoneNumberTransformationService.java
SIZE: 14.73 KB
MODIFIED: 2025-08-28 14:36:42
============================================================
// File: com/infomedia/abacox/telephonypricing/component/cdrprocessing/PhoneNumberTransformationService.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.CommunicationLocation;
import com.infomedia.abacox.telephonypricing.db.entity.Indicator;
import jakarta.persistence.EntityManager;
import jakarta.persistence.NoResultException;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.Tuple;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Objects;

@Service
@Log4j2
@RequiredArgsConstructor
public class PhoneNumberTransformationService {

    @PersistenceContext
    private EntityManager entityManager;

    /**
     * Transforms an incoming phone number based on CME (Colombia) rules.
     * PHP equivalent: _esEntrante_60
     *
     * @param phoneNumber     The incoming phone number.
     * @param originCountryId The ID of the origin country for context.
     * @return A TransformationResult containing the potentially modified number and a hint for the telephony type.
     */
    public TransformationResult transformIncomingNumberCME(String phoneNumber, Long originCountryId) {
        if (phoneNumber == null) return new TransformationResult(null, false, null);
        String originalPhoneNumber = phoneNumber;
        String transformedNumber = phoneNumber;
        Long newTelephonyTypeId = null;
        log.debug("Transforming incoming CME number: '{}', countryId: {}", phoneNumber, originCountryId);

        if (originCountryId != null && originCountryId == 1L) { // Colombia MPORIGEN_ID = 1
            int len = phoneNumber.length();
            String p2 = len >= 2 ? phoneNumber.substring(0, 2) : "";
            String p3 = len >= 3 ? phoneNumber.substring(0, 3) : "";
            String p4 = len >= 4 ? phoneNumber.substring(0, 4) : "";

            if (len == 12) {
                if ("573".equals(p3) || "603".equals(p3)) { // Mobile with country code or new fixed prefix
                    transformedNumber = phoneNumber.substring(len - 10); // Last 10 digits
                    newTelephonyTypeId = TelephonyTypeEnum.CELLULAR.getValue();
                } else if ("6060".equals(p4) || "5760".equals(p4)) { // Fixed line with new prefix + old city prefix
                    transformedNumber = phoneNumber.substring(len - 8); // Last 8 digits (city code + number)
                }
            } else if (len == 11) {
                if ("604".equals(p3)) { // Specific fixed line prefix (e.g., Antioquia "4" + 7 digits)
                    transformedNumber = phoneNumber.substring(len - 8); // "4" + 7 digits
                } else if ("03".equals(p2)) { // Potential mobile starting with 03...
                    String n3_digits_after_0 = (len > 3) ? phoneNumber.substring(1, 4) : "";
                    try {
                        if (!n3_digits_after_0.isEmpty()) {
                            int n3val = Integer.parseInt(n3_digits_after_0);
                            if (n3val >= 300 && n3val <= 350) { // Mobile prefixes 300-350
                                transformedNumber = phoneNumber.substring(len - 10); // Get last 10 digits
                                newTelephonyTypeId = TelephonyTypeEnum.CELLULAR.getValue();
                            }
                        }
                    } catch (NumberFormatException | StringIndexOutOfBoundsException ignored) {
                        log.trace("NFE/SIOBE for 11-digit '03' number: {}", phoneNumber);
                    }
                }
            } else if (len == 10) {
                if ("60".equals(p2) || "57".equals(p2)) { // National fixed line with country/new prefix (e.g., 60XNNNNNNN or 57XNNNNNNN)
                    transformedNumber = phoneNumber.substring(len - 8); // XNNNNNNN (city code + number)
                } else if (phoneNumber.startsWith("3")) { // Mobile number (e.g. 3XXXXXXXXX)
                    try {
                        int n3val = Integer.parseInt(phoneNumber.substring(0, 3));
                        if (n3val >= 300 && n3val <= 350) {
                            newTelephonyTypeId = TelephonyTypeEnum.CELLULAR.getValue();
                            // transformedNumber remains the same 10-digit mobile number
                        }
                    } catch (NumberFormatException | StringIndexOutOfBoundsException ignored) {
                        log.trace("NFE/SIOBE for 10-digit '3' number: {}", phoneNumber);
                    }
                }
            } else if (len == 9) {
                // PHP: if($len == 9){//Nacional con 9 digitos if($p60 == 60 ){ $telefono = substr($telefono, -7); } }
                // This implies a 7-digit subscriber number after "60" + single digit city code (e.g. 60XNNNNNN)
                if ("60".equals(p2)) {
                    transformedNumber = phoneNumber.substring(len - 7); // NNNNNNN (subscriber number)
                }
            }
        }
        boolean transformed = !transformedNumber.equals(originalPhoneNumber);
        log.debug("Incoming CME number transformation result: original='{}', transformed='{}', newTypeHint={}, transformed={}",
                originalPhoneNumber, transformedNumber, newTelephonyTypeId, transformed);
        return new TransformationResult(transformedNumber, transformed, newTelephonyTypeId);
    }

    /**
     * Transforms an outgoing phone number based on CME (Colombia) rules.
     * PHP equivalent: _es_Saliente
     *
     * @param phoneNumber     The outgoing phone number.
     * @param originCountryId The ID of the origin country for context.
     * @return A TransformationResult containing the potentially modified number.
     */
    public TransformationResult transformOutgoingNumberCME(String phoneNumber, Long originCountryId) {
        if (phoneNumber == null) return new TransformationResult(null, false, null);
        String originalPhoneNumber = phoneNumber;
        String transformedNumber = phoneNumber;
        log.debug("Transforming outgoing CME number: '{}', countryId: {}", phoneNumber, originCountryId);

        if (originCountryId != null && originCountryId == 1L) { // Colombia
            int len = phoneNumber.length();
            if (len == 11 && phoneNumber.startsWith("03")) {
                try {
                    String sn3_digits_after_0 = phoneNumber.substring(1, 4);
                    int n3val = Integer.parseInt(sn3_digits_after_0);
                    if (n3val >= 300 && n3val <= 350) { // Mobile prefix
                        transformedNumber = phoneNumber.substring(len - 10); // Get last 10 digits
                    }
                } catch (NumberFormatException | StringIndexOutOfBoundsException ignored) {
                    log.trace("NFE/SIOBE for 11-digit outgoing '03' number: {}", phoneNumber);
                }
            }
        }
        boolean transformed = !transformedNumber.equals(originalPhoneNumber);
        log.debug("Outgoing CME number transformation result: original='{}', transformed='{}', transformed={}",
                originalPhoneNumber, transformedNumber, transformed);
        return new TransformationResult(transformedNumber, transformed, null);
    }

    /**
     * Transforms a number for the purpose of prefix lookup, mimicking the logic
     * of prepending prefixes for cellular or determining if a fixed-line call is local.
     * PHP equivalent: _esCelular_fijo
     *
     * @param phoneNumber    The phone number to transform.
     * @param commLocation   The communication location context.
     * @return A TransformationResult with the transformed number and a potential telephony type hint.
     */
    @Transactional(readOnly = true)
    public TransformationResult transformForPrefixLookup(String phoneNumber, CommunicationLocation commLocation) {
        if (phoneNumber == null || commLocation == null || commLocation.getIndicator() == null ||
                commLocation.getIndicator().getOriginCountryId() == null) {
            return new TransformationResult(phoneNumber, false, null);
        }
        log.debug("Transforming for prefix lookup: number='{}', commLocationDir='{}'", phoneNumber, commLocation.getDirectory());

        String originalPhoneNumber = phoneNumber;
        String transformedNumber = phoneNumber;
        Long newTelephonyTypeId = null;

        if (commLocation.getIndicator().getOriginCountryId() == 1L) { // Colombia
            int len = phoneNumber.length();
            if (len == 10) {
                if (phoneNumber.startsWith("3")) { // Cellular 3xx xxx xxxx
                    transformedNumber = "03" + phoneNumber; // PHP prepends "03"
                    newTelephonyTypeId = TelephonyTypeEnum.CELLULAR.getValue();
                    log.debug("10-digit cellular '{}' transformed to '{}', type hint: CELLULAR", originalPhoneNumber, transformedNumber);
                }
                else if (phoneNumber.startsWith("60")) { // New fixed line format 60X NNN NNNN
                    String ndcPart = phoneNumber.substring(2, 3); // X
                    String subscriberPart = phoneNumber.substring(3); // NNN NNNN
                    log.debug("10-digit fixed '60...' number. NDC part: '{}', Subscriber part: '{}'", ndcPart, subscriberPart);

                    String seriesLookupQuery = "SELECT i.department_country, i.city_name, s.company " +
                            "FROM series s JOIN indicator i ON s.indicator_id = i.id " +
                            "WHERE i.telephony_type_id = :nationalType AND s.ndc = :ndcPartInt " +
                            "  AND s.active = true AND i.active = true " +
                            "  AND s.initial_number <= :subscriberNum AND s.final_number >= :subscriberNum " +
                            "  AND i.origin_country_id = 1 " + // Hardcoded for Colombia logic
                            "LIMIT 1";
                    jakarta.persistence.Query nativeQuery = entityManager.createNativeQuery(seriesLookupQuery, Tuple.class);
                    nativeQuery.setParameter("nationalType", TelephonyTypeEnum.NATIONAL.getValue());
                    try {
                        nativeQuery.setParameter("ndcPartInt", Integer.parseInt(ndcPart));
                        nativeQuery.setParameter("subscriberNum", Integer.parseInt(subscriberPart));
                    } catch (NumberFormatException e) {
                        log.debug("NDC part {} or Subscriber part {} is not a number for _esCelular_fijo logic", ndcPart, subscriberPart);
                        return new TransformationResult(originalPhoneNumber, false, null);
                    }

                    try {
                        Tuple seriesData = (Tuple) nativeQuery.getSingleResult();
                        String dbDept = seriesData.get("department_country", String.class);
                        String dbCity = seriesData.get("city_name", String.class);
                        String dbCompany = seriesData.get("company", String.class);
                        log.debug("Series lookup result: Dept='{}', City='{}', Company='{}'", dbDept, dbCity, dbCompany);

                        Indicator plantIndicator = commLocation.getIndicator();
                        if (Objects.equals(dbDept, plantIndicator.getDepartmentCountry()) &&
                                Objects.equals(dbCity, plantIndicator.getCityName())) {
                            transformedNumber = subscriberPart; // Becomes local number
                            newTelephonyTypeId = TelephonyTypeEnum.LOCAL.getValue();
                            log.debug("Matched plant's city/dept. Transformed to local: '{}', type hint: LOCAL", transformedNumber);
                        }
                        else if (Objects.equals(dbDept, plantIndicator.getDepartmentCountry())) {
                            transformedNumber = subscriberPart; // Becomes local extended number
                            newTelephonyTypeId = TelephonyTypeEnum.LOCAL_EXTENDED.getValue();
                            log.debug("Matched plant's dept. Transformed to local extended: '{}', type hint: LOCAL_EXTENDED", transformedNumber);
                        }
                        else { // National
                            String operatorPrefix = mapCompanyToOperatorPrefix(dbCompany);
                            if (!operatorPrefix.isEmpty()) {
                                transformedNumber = operatorPrefix + phoneNumber.substring(2); // operator_prefix + XNNNNNNN
                            } else {
                                transformedNumber = "09" + phoneNumber.substring(2); // Default "09" + XNNNNNNN
                            }
                            newTelephonyTypeId = TelephonyTypeEnum.NATIONAL.getValue();
                            log.debug("No local/extended match. Transformed to national: '{}' (prefix: '{}'), type hint: NATIONAL", transformedNumber, operatorPrefix.isEmpty() ? "09" : operatorPrefix);
                        }
                    } catch (NoResultException e) {
                        // PHP: $numero = substr($numero, 2); $g_numero = $numero = '09'.$numero;
                        transformedNumber = "09" + phoneNumber.substring(2); // Default to "09" + XNNNNNNN
                        newTelephonyTypeId = TelephonyTypeEnum.NATIONAL.getValue();
                        log.debug("No series match for '60...' number. Defaulting to national: '{}', type hint: NATIONAL", transformedNumber);
                    }
                }
            }
        }
        boolean transformed = !transformedNumber.equals(originalPhoneNumber);
        log.debug("Prefix lookup transformation result: original='{}', transformed='{}', newTypeHint={}, transformed={}",
                originalPhoneNumber, transformedNumber, newTelephonyTypeId, transformed);
        return new TransformationResult(transformedNumber, transformed, newTelephonyTypeId);
    }

    private String mapCompanyToOperatorPrefix(String companyName) {
        if (companyName == null) return "";
        String upperCompany = companyName.toUpperCase();
        // These mappings are from PHP's _esNacional
        if (upperCompany.contains("TELMEX")) return "0456"; // CLARO HOGAR FIJO
        if (upperCompany.contains("COLOMBIA TELECOMUNICACIONES S.A. ESP")) return "09"; // MOVISTAR FIJO
        if (upperCompany.contains("UNE EPM TELECOMUNICACIONES S.A. E.S.P.") || upperCompany.contains("UNE EPM TELCO S.A.")) return "05"; // TIGO-UNE FIJO
        if (upperCompany.contains("EMPRESA DE TELECOMUNICACIONES DE BOGOT S.A. ESP.") || upperCompany.contains("ETB")) return "07"; // ETB FIJO
        return "";
    }
}

============================================================
FILE: PrefixInfo.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/PrefixInfo.java
SIZE: 1.66 KB
MODIFIED: 2025-06-11 16:13:11
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.Prefix;
import com.infomedia.abacox.telephonypricing.db.entity.TelephonyTypeConfig;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class PrefixInfo { // DTO to mimic PHP's $prefijo['datos'][$prefijoid]
    public Long prefixId;
    public String prefixCode;
    public Long telephonyTypeId;
    public String telephonyTypeName;
    public Long operatorId;
    public String operatorName;
    public Integer telephonyTypeMinLength;
    public Integer telephonyTypeMaxLength;
    public boolean bandOk; // From PREFIJO_BANDAOK
    public int bandsAssociatedCount; // Count from BANDA table

    public PrefixInfo(Prefix p, TelephonyTypeConfig cfg, int bandsCount) {
        this.prefixId = p.getId();
        this.prefixCode = p.getCode();
        this.telephonyTypeId = p.getTelephonyTypeId();
        if (p.getTelephonyType() != null) this.telephonyTypeName = p.getTelephonyType().getName();
        this.operatorId = p.getOperatorId();
        if (p.getOperator() != null) this.operatorName = p.getOperator().getName();
        if (cfg != null) {
            this.telephonyTypeMinLength = cfg.getMinValue();
            this.telephonyTypeMaxLength = cfg.getMaxValue();
        } else { // Fallback if no specific config for country
            this.telephonyTypeMinLength = 0;
            this.telephonyTypeMaxLength = 99; // A large number
        }
        this.bandOk = p.isBandOk();
        this.bandsAssociatedCount = bandsCount;
    }
}

============================================================
FILE: PrefixLookupService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/PrefixLookupService.java
SIZE: 10.01 KB
MODIFIED: 2025-11-21 14:15:53
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.CommunicationLocation;
import com.infomedia.abacox.telephonypricing.db.entity.Prefix;
import com.infomedia.abacox.telephonypricing.db.entity.TelephonyTypeConfig;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.Tuple;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

@Service
@Log4j2
@RequiredArgsConstructor
public class PrefixLookupService {

    @PersistenceContext
    private EntityManager entityManager;
    private final PhoneNumberTransformationService phoneNumberTransformationService;
    private final TelephonyTypeLookupService telephonyTypeLookupService;

    // CACHE: CountryID -> List of all Prefixes
    private final Map<Long, List<PrefixInfo>> prefixCache = new ConcurrentHashMap<>();
    private final Map<Long, Instant> cacheLastUpdated = new ConcurrentHashMap<>();
    private static final long CACHE_TTL_SECONDS = 1800; // 30 Minutes

    @Transactional(readOnly = true)
    public List<PrefixInfo> findMatchingPrefixes(String dialedNumber,
                                                 CommunicationLocation commLocation,
                                                 boolean isTrunkCall,
                                                 List<Long> trunkTelephonyTypeIds) {
        
        // 1. Transform Number
        String numberForLookup = dialedNumber;
        Long hintedTelephonyTypeId = null;
        
        if (commLocation != null && commLocation.getIndicator() != null &&
            commLocation.getIndicator().getOriginCountryId() != null) {
            TransformationResult res = phoneNumberTransformationService.transformForPrefixLookup(dialedNumber, commLocation);
            if (res.isTransformed()) {
                numberForLookup = res.getTransformedNumber();
                hintedTelephonyTypeId = res.getNewTelephonyTypeId();
            }
        }
        final String finalNumber = numberForLookup;
        Long countryId = commLocation.getIndicator().getOriginCountryId();

        // 2. Get All Prefixes for Country from Cache (or load DB)
        List<PrefixInfo> countryPrefixes = getPrefixesForCountry(countryId);

        // 3. In-Memory Matching
        List<PrefixInfo> matchedPrefixes = new ArrayList<>();
        
        if (isTrunkCall && trunkTelephonyTypeIds != null && !trunkTelephonyTypeIds.isEmpty()) {
             // Trunk Call: Filter by Allowed Trunk Types, ignore code matching strictness
             matchedPrefixes = countryPrefixes.stream()
                 .filter(p -> trunkTelephonyTypeIds.contains(p.getTelephonyTypeId()))
                 .collect(Collectors.toList());
        } else {
             // Standard Call: Match using startsWith
             String bestMatchPrefixCode = null;
             
             // Since list is sorted by Length DESC in loader, the first match is the longest match
             for (PrefixInfo pi : countryPrefixes) {
                 if (pi.getPrefixCode() != null && !pi.getPrefixCode().isEmpty() && finalNumber.startsWith(pi.getPrefixCode())) {
                     bestMatchPrefixCode = pi.getPrefixCode();
                     break;
                 }
             }
             
             if (bestMatchPrefixCode != null) {
                 final String match = bestMatchPrefixCode;
                 matchedPrefixes = countryPrefixes.stream()
                     .filter(pi -> match.equals(pi.getPrefixCode()))
                     .collect(Collectors.toList());
             }
        }

        // 4. Fallback Logic: Add Local if not present and length is valid
        if (!isTrunkCall) {
            boolean hasLocal = matchedPrefixes.stream()
                .anyMatch(pi -> pi.getTelephonyTypeId().equals(TelephonyTypeEnum.LOCAL.getValue()));
            
            if (!hasLocal) {
                List<PrefixInfo> finalMatchedPrefixes = matchedPrefixes;
                countryPrefixes.stream()
                    .filter(pi -> pi.getTelephonyTypeId().equals(TelephonyTypeEnum.LOCAL.getValue()) &&
                                 (pi.getPrefixCode() == null || pi.getPrefixCode().isEmpty() || finalNumber.startsWith(pi.getPrefixCode())) &&
                                 finalNumber.length() >= (pi.getTelephonyTypeMinLength() != null ? pi.getTelephonyTypeMinLength() : 0))
                    .forEach(pi -> {
                        if (finalMatchedPrefixes.stream().noneMatch(mp -> mp.getPrefixId().equals(pi.getPrefixId()))) {
                            finalMatchedPrefixes.add(pi);
                        }
                    });
            }
        }

        // 5. Hint Optimization
        if (hintedTelephonyTypeId != null && !matchedPrefixes.isEmpty()) {
            Long hint = hintedTelephonyTypeId;
            List<PrefixInfo> hintedMatches = matchedPrefixes.stream()
                .filter(pi -> pi.getTelephonyTypeId().equals(hint))
                .collect(Collectors.toList());
            if (!hintedMatches.isEmpty()) matchedPrefixes = hintedMatches;
        }

        // 6. Sort results for logic priority
        matchedPrefixes.sort(Comparator
                .comparing((PrefixInfo pi) -> pi.getPrefixCode() != null ? pi.getPrefixCode().length() : 0, Comparator.reverseOrder())
                .thenComparing((PrefixInfo pi) -> pi.getTelephonyTypeMinLength() != null ? pi.getTelephonyTypeMinLength() : 0));

        return matchedPrefixes;
    }

    private List<PrefixInfo> getPrefixesForCountry(Long countryId) {
        Instant lastUpdate = cacheLastUpdated.get(countryId);
        if (lastUpdate == null || lastUpdate.isBefore(Instant.now().minusSeconds(CACHE_TTL_SECONDS))) {
            synchronized (prefixCache) {
                // Double check locking
                lastUpdate = cacheLastUpdated.get(countryId);
                if (lastUpdate == null || lastUpdate.isBefore(Instant.now().minusSeconds(CACHE_TTL_SECONDS))) {
                    log.debug("Reloading Prefix Cache for Country ID: {}", countryId);
                    List<PrefixInfo> loaded = loadPrefixesFromDb(countryId);
                    prefixCache.put(countryId, loaded);
                    cacheLastUpdated.put(countryId, Instant.now());
                }
            }
        }
        return prefixCache.getOrDefault(countryId, Collections.emptyList());
    }

    private List<PrefixInfo> loadPrefixesFromDb(Long originCountryId) {
        String queryStr = "SELECT p.*, ttc.min_value as ttc_min, ttc.max_value as ttc_max, " +
                "(SELECT COUNT(*) FROM band b WHERE b.prefix_id = p.id AND b.active = true) as bands_count " +
                "FROM prefix p " +
                "JOIN operator o ON p.operator_id = o.id " +
                "JOIN telephony_type tt ON p.telephony_type_id = tt.id " +
                "LEFT JOIN telephony_type_config ttc ON tt.id = ttc.telephony_type_id AND ttc.origin_country_id = :originCountryId AND ttc.active = true " +
                "WHERE p.active = true AND o.active = true AND tt.active = true AND o.origin_country_id = :originCountryId " +
                "AND p.telephony_type_id != :specialServicesTypeId " +
                "ORDER BY LENGTH(p.code) DESC, ttc.min_value DESC, p.telephony_type_id";

        jakarta.persistence.Query nativeQuery = entityManager.createNativeQuery(queryStr, Tuple.class);
        nativeQuery.setParameter("originCountryId", originCountryId);
        nativeQuery.setParameter("specialServicesTypeId", TelephonyTypeEnum.SPECIAL_SERVICES.getValue());

        List<Tuple> results = nativeQuery.getResultList();
        return results.stream().map(tuple -> {
            Prefix p = entityManager.find(Prefix.class, tuple.get("id", Number.class).longValue());
            TelephonyTypeConfig cfg = new TelephonyTypeConfig();
            cfg.setMinValue(tuple.get("ttc_min", Number.class) != null ? tuple.get("ttc_min", Number.class).intValue() : 0);
            cfg.setMaxValue(tuple.get("ttc_max", Number.class) != null ? tuple.get("ttc_max", Number.class).intValue() : 99);
            int bandsCount = tuple.get("bands_count", Number.class).intValue();
            return new PrefixInfo(p, cfg, bandsCount);
        }).collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public Map<String, Long> getInternalTelephonyTypePrefixes(Long originCountryId) {
        // Caching this simple map is also recommended, but for now reusing the DB structure. 
        // Can be added similarly if needed.
        List<Long> internalTypeIds = telephonyTypeLookupService.getInternalTypeIds();
        if (internalTypeIds.isEmpty()) return Collections.emptyMap();

        String queryStr = "SELECT p.code, p.telephony_type_id " +
                          "FROM prefix p JOIN operator o ON p.operator_id = o.id " +
                          "WHERE p.active = true AND o.active = true AND o.origin_country_id = :originCountryId " +
                          "AND p.telephony_type_id IN (:internalTypeIds) AND p.code IS NOT NULL AND p.code != '' " +
                          "ORDER BY LENGTH(p.code) DESC, p.code DESC";

        jakarta.persistence.Query nativeQuery = entityManager.createNativeQuery(queryStr, Tuple.class);
        nativeQuery.setParameter("originCountryId", originCountryId);
        nativeQuery.setParameter("internalTypeIds", internalTypeIds);

        List<Tuple> results = nativeQuery.getResultList();
        Map<String, Long> internalPrefixMap = new TreeMap<>(Collections.reverseOrder());

        for (Tuple row : results) {
            internalPrefixMap.put(row.get("code", String.class), row.get("telephony_type_id", Number.class).longValue());
        }
        return internalPrefixMap;
    }
}

============================================================
FILE: ProcessedCdrResult.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/ProcessedCdrResult.java
SIZE: 0.74 KB
MODIFIED: 2026-01-22 12:20:41
============================================================
// E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/ProcessedCdrResult.java

package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.CommunicationLocation;
import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class ProcessedCdrResult {
    private String tenantId; // <-- ADD THIS FIELD
    private CdrData cdrData;
    private CommunicationLocation commLocation;
    private ProcessingOutcome outcome;
    
    // For quarantined records
    private QuarantineErrorType errorType;
    private String errorMessage;
    private String errorStep;
    private Long originalCallRecordId;
}

============================================================
FILE: ProcessingOutcome.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/ProcessingOutcome.java
SIZE: 0.15 KB
MODIFIED: 2025-09-01 11:21:51
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

public enum ProcessingOutcome {
    SUCCESS,
    QUARANTINED,
    SKIPPED
}

============================================================
FILE: QuarantineErrorType.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/QuarantineErrorType.java
SIZE: 3.68 KB
MODIFIED: 2026-02-27 10:41:57
============================================================
// File: com/infomedia/abacox/telephonypricing/component/cdrprocessing/QuarantineErrorType.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import lombok.Getter;

@Getter
public enum QuarantineErrorType {
    // From PHP's ReportarErrores $tipo
    INITIAL_VALIDATION_ERROR("CDRNOVAL", "Initial CDR data validation failed"), // PHP: CDRNOVAL
    INITIAL_VALIDATION_WARNING("CRNPREV", "Preventive quarantine due to validation warning"), // PHP: CRNPREV
    GLOBAL_EXTENSION_IGNORE("IGNORAGLOBAL", "Ignored due to global extension/plant routing rules"),
    DB_INSERT_FAILED("NOINSERTA", "Failed to insert into main call record table"),
    DUPLICATE_RECORD("REGDUPLICADO", "Duplicate record found during main table insertion"),
    CUSTOM_IGNORE("IGNORAPROPIOS", "Ignored by custom processing rules"),
    PENDING_ASSOCIATION("PENDIENTES", "CDR could not be associated with a target (e.g., in HACHA)"),
    INTERNAL_SELF_CALL("IGUALDESTINO", "Internal call where origin and destination are the same"),

    // Additional types for Java context
    INVALID_DATE("FECHANOVAL", "Origination date is missing, before minimum allowed, or too far in the future"),
    INVALID_DURATION("TIEMPONOVAL", "Call duration is negative, less than minimum, or exceeds maximum allowed"),
    INVALID_NUMBER_FORMAT("NUMNOVAL", "Calling or called party number contains invalid characters or spaces"),
    INTERNAL_POLICY_IGNORE("IGNORAINTERNA", "Ignored due to specific internal call routing/policy rules"),
    INSUFFICIENT_FIELDS("CAMPOSINSUF", "CDR line has fewer fields than the required minimum based on the header"),
    PARSER_ERROR("PARSER_ERROR", "Error during CDR line parsing"),
    ENRICHMENT_ERROR("ENRICHMENT_ERROR", "Error during CDR data enrichment"),
    ENRICHMENT_WARNING("ENRICHMENT_WARNING", "Warning during CDR data enrichment leading to quarantine"),
    UNHANDLED_EXCEPTION("UNHANDLED_EXCEPTION", "An unexpected error occurred during processing"),
    MISSING_HEADER("MISSING_HEADER", "CDR data encountered before header was processed"),
    IO_EXCEPTION("IO_EXCEPTION", "Error reading CDR input stream"),
    PARSER_QUARANTINE("PARSER_QUARANTINE", "Marked for quarantine by the CDR parser directly");

    private final String phpEquivalent;
    private final String description;

    QuarantineErrorType(String phpEquivalent, String description) {
        this.phpEquivalent = phpEquivalent;
        this.description = description;
    }

    public static QuarantineErrorType fromPhpType(String phpType) {
        for (QuarantineErrorType type : values()) {
            if (type.getPhpEquivalent().equalsIgnoreCase(phpType)) {
                return type;
            }
        }
        // Fallback or throw exception if not found
        switch (phpType.toUpperCase()) {
            case "CDRNOVAL": return INITIAL_VALIDATION_ERROR;
            case "CRNPREV": return INITIAL_VALIDATION_WARNING;
            case "IGNORAGLOBAL": return GLOBAL_EXTENSION_IGNORE;
            case "NOINSERTA": return DB_INSERT_FAILED;
            case "REGDUPLICADO": return DUPLICATE_RECORD;
            case "IGNORAPROPIOS": return CUSTOM_IGNORE;
            case "PENDIENTES": return PENDING_ASSOCIATION;
            case "IGUALDESTINO": return INTERNAL_SELF_CALL;
            case "FECHANOVAL": return INVALID_DATE;
            case "TIEMPONOVAL": return INVALID_DURATION;
            case "NUMNOVAL": return INVALID_NUMBER_FORMAT;
            case "IGNORAINTERNA": return INTERNAL_POLICY_IGNORE;
            case "CAMPOSINSUF": return INSUFFICIENT_FIELDS;
            default:
                return UNHANDLED_EXCEPTION; // Or a more generic "UNKNOWN_PHP_TYPE"
        }
    }
}

============================================================
FILE: SpecialRateInfo.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/SpecialRateInfo.java
SIZE: 0.51 KB
MODIFIED: 2025-06-04 13:40:58
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class SpecialRateInfo {
    public BigDecimal rateValue;
    public boolean includesVat;
    public BigDecimal vatRate; // VAT rate from the prefix associated with the special rate's telephony type/operator
    public int valueType; // 0 = absolute, 1 = percentage
}

============================================================
FILE: SpecialRateValueLookupService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/SpecialRateValueLookupService.java
SIZE: 6.18 KB
MODIFIED: 2025-11-21 13:33:26
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.Tuple;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.DayOfWeek;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@Log4j2
@RequiredArgsConstructor
public class SpecialRateValueLookupService {

    @PersistenceContext
    private EntityManager entityManager;
    // HolidayLookupService would be needed for isHoliday check
    // private final HolidayLookupService holidayLookupService;

    @Transactional(readOnly = true)
    public Optional<SpecialRateInfo> getApplicableSpecialRate(LocalDateTime callDateTime, Long originIndicatorId,
                                                              Long telephonyTypeId, Long operatorId, Long bandId) {
        // PHP's Obtener_ValorEspecial
        if (telephonyTypeId == null || telephonyTypeId <= 0 || callDateTime == null) {
            return Optional.empty();
        }

        DayOfWeek dayOfWeek = callDateTime.getDayOfWeek();
        LocalTime callTime = callDateTime.toLocalTime();
        // boolean isHoliday = holidayLookupService.isHoliday(callDateTime.toLocalDate(), originCountryId); // Needs HolidayService
        boolean isHoliday = false; // Placeholder

        String dayColumn;
        switch (dayOfWeek) {
            case SUNDAY: dayColumn = "sunday_enabled"; break;
            case MONDAY: dayColumn = "monday_enabled"; break;
            case TUESDAY: dayColumn = "tuesday_enabled"; break;
            case WEDNESDAY: dayColumn = "wednesday_enabled"; break;
            case THURSDAY: dayColumn = "thursday_enabled"; break;
            case FRIDAY: dayColumn = "friday_enabled"; break;
            case SATURDAY: dayColumn = "saturday_enabled"; break;
            default: return Optional.empty();
        }

        String queryStr = "SELECT sr.rate_value, sr.includes_vat, sr.value_type, sr.hours_specification, " +
                          "COALESCE(p.vat_value, 0) as prefix_vat_rate " + // Get VAT from associated prefix
                          "FROM special_rate_value sr " +
                          "LEFT JOIN prefix p ON sr.telephony_type_id = p.telephony_type_id AND sr.operator_id = p.operator_id AND p.active = true " +
                          // LEFT JOIN operator o ON p.operator_id = o.id AND o.origin_country_id = :originCountryId ... (if prefix VAT depends on country)
                          "WHERE sr.active = true " +
                          "AND (sr.valid_from IS NULL OR sr.valid_from <= :callDateTime) " +
                          "AND (sr.valid_to IS NULL OR sr.valid_to >= :callDateTime) " +
                          "AND (" + dayColumn + " = true " + (isHoliday ? "OR sr.holiday_enabled = true" : "") + ") " +
                          "AND (sr.origin_indicator_id = 0 OR sr.origin_indicator_id IS NULL OR sr.origin_indicator_id = :originIndicatorId) " +
                          "AND (sr.telephony_type_id = 0 OR sr.telephony_type_id = :telephonyTypeId) " + // 0 for all types
                          "AND (sr.operator_id = 0 OR sr.operator_id = :operatorId) " + // 0 for all operators
                          "AND (sr.band_id = 0 OR sr.band_id = :bandId) " + // 0 for all bands
                          "ORDER BY sr.origin_indicator_id DESC, sr.telephony_type_id DESC, sr.operator_id DESC, sr.band_id DESC"; // Prefer more specific rules

        jakarta.persistence.Query nativeQuery = entityManager.createNativeQuery(queryStr, Tuple.class);
        nativeQuery.setParameter("callDateTime", callDateTime);
        nativeQuery.setParameter("originIndicatorId", originIndicatorId);
        nativeQuery.setParameter("telephonyTypeId", telephonyTypeId);
        nativeQuery.setParameter("operatorId", operatorId == null ? 0L : operatorId); // Default to 0 if null
        nativeQuery.setParameter("bandId", bandId == null ? 0L : bandId); // Default to 0 if null

        List<Tuple> results = nativeQuery.getResultList();

        for (Tuple row : results) {
            String hoursSpec = row.get("hours_specification", String.class);
            if (isTimeApplicable(callTime, hoursSpec)) {
                SpecialRateInfo sri = new SpecialRateInfo();
                sri.rateValue = row.get("rate_value", BigDecimal.class);
                sri.includesVat = row.get("includes_vat", Boolean.class);
                sri.valueType = row.get("value_type", Integer.class);
                sri.vatRate = row.get("prefix_vat_rate", BigDecimal.class);
                log.debug("Applicable special rate found for call at {}", callDateTime);
                return Optional.of(sri);
            }
        }
        return Optional.empty();
    }

    private boolean isTimeApplicable(LocalTime callTime, String hoursSpecification) {
        // PHP's ArregloHoras logic
        if (hoursSpecification == null || hoursSpecification.trim().isEmpty()) {
            return true; // No hour restriction
        }
        // Example format: "0-6,18-23" or "8,9,10"
        List<Integer> applicableHours = Arrays.stream(hoursSpecification.split(","))
            .flatMap(part -> {
                if (part.contains("-")) {
                    String[] range = part.split("-");
                    int start = Integer.parseInt(range[0].trim());
                    int end = Integer.parseInt(range[1].trim());
                    List<Integer> hoursInRange = new ArrayList<>();
                    for (int h = start; h <= end; h++) hoursInRange.add(h);
                    return hoursInRange.stream();
                } else {
                    return Arrays.asList(Integer.parseInt(part.trim())).stream();
                }
            })
            .collect(Collectors.toList());
        
        return applicableHours.contains(callTime.getHour());
    }
}

============================================================
FILE: SpecialServiceInfo.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/SpecialServiceInfo.java
SIZE: 0.52 KB
MODIFIED: 2025-06-04 13:40:58
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@AllArgsConstructor
@NoArgsConstructor
@Data
public class SpecialServiceInfo {
    public String phoneNumber;
    public BigDecimal value;
    public BigDecimal vatRate;
    public boolean vatIncluded;
    public String description;
    public Long operatorId; // From PHP's operador_interno
    public String operatorName;
}


============================================================
FILE: SpecialServiceLookupService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/SpecialServiceLookupService.java
SIZE: 2.67 KB
MODIFIED: 2025-06-11 16:13:10
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.SpecialService;
import jakarta.persistence.EntityManager;
import jakarta.persistence.NoResultException;
import jakarta.persistence.PersistenceContext;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;


@Service
@Log4j2
@RequiredArgsConstructor
public class SpecialServiceLookupService {

    @PersistenceContext
    private EntityManager entityManager;
    private final TelephonyTypeLookupService telephonyTypeLookupService;

    @Transactional(readOnly = true)
    public Optional<SpecialServiceInfo> findSpecialService(String phoneNumber, Long indicatorId, Long originCountryId) {
        // PHP's buscar_NumeroEspecial and CargarServEspeciales
        String queryStr = "SELECT ss.* FROM special_service ss " +
                          "WHERE ss.active = true AND ss.phone_number = :phoneNumber " +
                          "AND (ss.indicator_id = 0 OR ss.indicator_id = :indicatorId) " + // 0 for global special numbers
                          "AND ss.origin_country_id = :originCountryId " +
                          "ORDER BY ss.indicator_id DESC LIMIT 1"; // Prefer specific indicator over global

        jakarta.persistence.Query nativeQuery = entityManager.createNativeQuery(queryStr, SpecialService.class);
        nativeQuery.setParameter("phoneNumber", phoneNumber);
        nativeQuery.setParameter("indicatorId", indicatorId);
        nativeQuery.setParameter("originCountryId", originCountryId);

        try {
            SpecialService ss = (SpecialService) nativeQuery.getSingleResult();
            SpecialServiceInfo ssi = new SpecialServiceInfo();
            ssi.phoneNumber = ss.getPhoneNumber();
            ssi.value = ss.getValue();
            ssi.vatRate = ss.getVatAmount(); // PHP uses SERVESPECIAL_IVA, which seems to be the rate not amount
            ssi.vatIncluded = ss.getVatIncluded();
            ssi.description = ss.getDescription();
            
            // PHP's operador_interno logic for _TIPOTELE_ESPECIALES
            OperatorInfo internalOp = telephonyTypeLookupService.getInternalOperatorInfo(
                TelephonyTypeEnum.SPECIAL_SERVICES.getValue(), originCountryId
            );
            ssi.operatorId = internalOp.getId();
            ssi.operatorName = internalOp.getName();

            return Optional.of(ssi);
        } catch (NoResultException e) {
            return Optional.empty();
        }
    }
}

============================================================
FILE: TariffCalculationService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/TariffCalculationService.java
SIZE: 32.32 KB
MODIFIED: 2026-02-17 17:57:07
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.CommunicationLocation;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

@Service
@Log4j2
@RequiredArgsConstructor
public class TariffCalculationService {
    private final PrefixLookupService prefixLookupService;
    private final IndicatorLookupService indicatorLookupService;
    private final TrunkLookupService trunkLookupService;
    private final SpecialRateValueLookupService specialRateValueLookupService;
    private final TrunkRuleLookupService trunkRuleLookupService;
    private final CdrConfigService appConfigService;
    private final TelephonyTypeLookupService telephonyTypeLookupService;
    private final OperatorLookupService operatorLookupService;
    private final CdrConfigService cdrConfigService;

    /**
     * PHP equivalent: procesaSaliente_Complementar and parts of evaluarDestino
     */
    public void calculateTariffsForOutgoing(CdrData cdrData, CommunicationLocation commLocation,
            ExtensionLimits extensionLimits) {
        log.debug("Calculating tariffs for OUTGOING/EXTERNAL CDR: {}, CommLocation: {}", cdrData.getCtlHash(),
                commLocation.getDirectory());

        Optional<TrunkInfo> trunkInfoOpt = Optional.empty();
        if (cdrData.getDestDeviceName() != null && !cdrData.getDestDeviceName().isEmpty()) {
            trunkInfoOpt = trunkLookupService.findTrunkByName(cdrData.getDestDeviceName(), commLocation.getId());
            log.debug("Trunk lookup for '{}': {}", cdrData.getDestDeviceName(),
                    trunkInfoOpt.isPresent() ? "Found" : "Not Found");
        }

        String numberForTariffing = cdrData.getEffectiveDestinationNumber();
        log.debug("Number for tariffing (effectiveDestinationNumber): {}", numberForTariffing);

        List<String> pbxPrefixes = commLocation.getPbxPrefix() != null
                ? Arrays.asList(commLocation.getPbxPrefix().split(","))
                : Collections.emptyList();

        String initialNumberForPrefixLookup = numberForTariffing;
        if (trunkInfoOpt.isEmpty()) {
            initialNumberForPrefixLookup = CdrUtil.cleanPhoneNumber(numberForTariffing, pbxPrefixes, true)
                    .getCleanedNumber();
            log.debug("Non-trunk call. Number for prefix lookup (after PBX clean): {}", initialNumberForPrefixLookup);
        } else {
            log.debug("Trunk call. Initial number for prefix lookup (before trunk-specific PBX clean): {}",
                    initialNumberForPrefixLookup);
        }

        TariffingAttemptResult attempt1 = attemptTariffing(initialNumberForPrefixLookup, commLocation, trunkInfoOpt,
                false);

        if (trunkInfoOpt.isPresent() && isTariffResultInvalidOrAssumed(attempt1)
                && !cdrData.isNormalizedTariffApplied()) {
            log.debug("Trunk call tariffing attempt 1 resulted in invalid/assumed. Attempting normalization for: {}",
                    numberForTariffing);

            List<String> pbxPrefixesForNormalization = pbxPrefixes;
            if (trunkInfoOpt.get().noPbxPrefix != null && trunkInfoOpt.get().noPbxPrefix) {
                pbxPrefixesForNormalization = Collections.emptyList();
            }
            String normalizedNumberForLookup = CdrUtil
                    .cleanPhoneNumber(numberForTariffing, pbxPrefixesForNormalization, true).getCleanedNumber();
            log.debug("Normalized number for lookup (treated as non-trunk): {}", normalizedNumberForLookup);

            TariffingAttemptResult attempt2 = attemptTariffing(normalizedNumberForLookup, commLocation,
                    Optional.empty(), true);

            if (attempt2.bestPrefixInfo != null && attempt2.bestPrefixInfo.telephonyTypeId > 0 &&
                    attempt2.bestPrefixInfo.telephonyTypeId != TelephonyTypeEnum.ERRORS.getValue() &&
                    attempt2.bestDestInfo != null && attempt2.bestDestInfo.getIndicatorId() != null
                    && attempt2.bestDestInfo.getIndicatorId() > 0) {

                boolean useNormalized = true;
                if (attempt1.bestPrefixInfo != null && attempt1.bestDestInfo != null) {
                    if (Objects.equals(attempt1.bestPrefixInfo.telephonyTypeId, attempt2.bestPrefixInfo.telephonyTypeId)
                            &&
                            Objects.equals(attempt1.bestDestInfo.getIndicatorId(),
                                    attempt2.bestDestInfo.getIndicatorId())) {
                        useNormalized = false;
                        log.debug(
                                "Normalized result is same type/indicator as initial assumed result. Preferring initial.");
                    }
                }
                if (useNormalized) {
                    log.debug("Using normalized tariffing result for trunk call. Original number: {}",
                            numberForTariffing);
                    applyTariffingResult(cdrData, attempt2, commLocation, Optional.empty(), extensionLimits);
                    cdrData.setNormalizedTariffApplied(true);
                } else {
                    applyTariffingResult(cdrData, attempt1, commLocation, trunkInfoOpt, extensionLimits);
                }
            } else {
                log.debug("Normalization did not yield a valid result. Sticking with initial attempt.");
                applyTariffingResult(cdrData, attempt1, commLocation, trunkInfoOpt, extensionLimits);
            }
        } else {
            applyTariffingResult(cdrData, attempt1, commLocation, trunkInfoOpt, extensionLimits);
        }
        log.debug("Final tariff calculation for OUTGOING/EXTERNAL CDR: {}. Billed Amount: {}, Price/Min: {}, Type: {}",
                cdrData.getCtlHash(), cdrData.getBilledAmount(), cdrData.getPricePerMinute(),
                cdrData.getTelephonyTypeName());
    }

    public void calculateTariffsForIncoming(CdrData cdrData, CommunicationLocation commLocation) {
        log.debug("Calculating tariffs for INCOMING CDR: {}", cdrData.getCtlHash());
        // For incoming, the type/operator/indicator are of the *source*.
        // Base tariffing for incoming is typically zero unless specific rules apply.
        cdrData.setPricePerMinute(BigDecimal.ZERO);
        cdrData.setInitialPricePerMinute(BigDecimal.ZERO);
        cdrData.setPriceIncludesVat(false);
        cdrData.setInitialPriceIncludesVat(false);
        cdrData.setVatRate(BigDecimal.ZERO);

        applySpecialRatesAndRules(cdrData, commLocation, null, null); // No destInfo/trunkInfo for incoming source
                                                                      // tariffing

        cdrData.setBilledAmount(calculateFinalBilledAmount(cdrData));
        log.debug("Final tariff for INCOMING CDR: {}. Billed Amount: {}, Price/Min: {}, Type: {}",
                cdrData.getCtlHash(), cdrData.getBilledAmount(), cdrData.getPricePerMinute(),
                cdrData.getTelephonyTypeName());
    }

    public void calculateTariffsForInternal(CdrData cdrData, CommunicationLocation commLocation) {
        log.debug("Calculating tariffs for INTERNAL CDR: {}, Type: {}", cdrData.getCtlHash(),
                cdrData.getTelephonyTypeId());
        TariffValue internalTariff = telephonyTypeLookupService.getInternalTariffValue(
                cdrData.getTelephonyTypeId(), commLocation.getIndicator().getOriginCountryId());
        cdrData.setPricePerMinute(internalTariff.getRateValue());
        // Initial price remains 0 unless modified by specific rules (which don't
        // usually apply to internal, but if they did, they'd set it)
        cdrData.setPriceIncludesVat(internalTariff.isIncludesVat());
        cdrData.setVatRate(internalTariff.getVatRate());

        // Internal calls typically don't have special rates or trunk rules in the same
        // way,
        // but if needed, applySpecialRatesAndRules could be called here with
        // appropriate context.
        // For now, assume internal tariffs are final.

        cdrData.setBilledAmount(calculateFinalBilledAmount(cdrData));
        log.debug("Final tariff for INTERNAL CDR: {}. Billed Amount: {}, Price/Min: {}, Type: {}",
                cdrData.getCtlHash(), cdrData.getBilledAmount(), cdrData.getPricePerMinute(),
                cdrData.getTelephonyTypeName());
    }

    public void calculateTariffsForSpecialService(CdrData cdrData) {
        SpecialServiceInfo ssi = cdrData.getSpecialServiceTariff();
        if (ssi != null) {
            log.debug("Applying special service tariff: {}", ssi);
            cdrData.setPricePerMinute(ssi.value);
            // Initial price remains 0 as this is the base rate/only rate.
            cdrData.setPriceIncludesVat(ssi.vatIncluded);
            cdrData.setVatRate(ssi.vatRate != null ? ssi.vatRate : BigDecimal.ZERO);
            cdrData.setBilledAmount(calculateFinalBilledAmount(cdrData));
            log.debug("Final tariff for SPECIAL SERVICE CDR: {}. Billed Amount: {}, Price/Min: {}, Type: {}",
                    cdrData.getCtlHash(), cdrData.getBilledAmount(), cdrData.getPricePerMinute(),
                    cdrData.getTelephonyTypeName());
        } else {
            log.debug(
                    "TelephonyType is SPECIAL_SERVICES but no SpecialServiceInfo found for CDR: {}. Setting tariff to 0.",
                    cdrData.getCtlHash());
            cdrData.setBilledAmount(BigDecimal.ZERO);
            cdrData.setPricePerMinute(BigDecimal.ZERO);
            cdrData.setInitialPricePerMinute(BigDecimal.ZERO);
        }
    }

    private TariffingAttemptResult attemptTariffing(String numberForLookup, CommunicationLocation commLocation,
            Optional<TrunkInfo> trunkInfoOpt, boolean isNormalizationAttempt) {
        log.debug("Attempting tariffing for number: '{}', isTrunk: {}, isNormalization: {}", numberForLookup,
                trunkInfoOpt.isPresent(), isNormalizationAttempt);
        TariffingAttemptResult result = new TariffingAttemptResult();
        result.setWasNormalizedAttempt(isNormalizationAttempt);

        List<Long> trunkTelephonyTypeIds = null;
        if (trunkInfoOpt.isPresent() && !isNormalizationAttempt) {
            trunkTelephonyTypeIds = trunkInfoOpt.get().getAllowedTelephonyTypeIds();
        }

        List<PrefixInfo> prefixes = prefixLookupService.findMatchingPrefixes(
                numberForLookup,
                commLocation,
                trunkInfoOpt.isPresent() && !isNormalizationAttempt,
                trunkTelephonyTypeIds);
        log.debug("Found {} potential prefixes for number '{}'", prefixes.size(), numberForLookup);

        for (PrefixInfo prefixInfo : prefixes) {
            log.trace("Evaluating prefix: {}", prefixInfo.getPrefixCode());
            String numberAfterOperatorPrefixStrip = numberForLookup;
            String operatorPrefixToPassToFindDest = prefixInfo.getPrefixCode();

            boolean stripOperatorPrefixForDestLookup = false;
            if (trunkInfoOpt.isPresent() && !isNormalizationAttempt) {
                TrunkInfo ti = trunkInfoOpt.get();
                Optional<TrunkRateDetails> rateDetails = trunkLookupService.getRateDetailsForTrunk(
                        ti.id, prefixInfo.telephonyTypeId, prefixInfo.operatorId);
                if (rateDetails.isPresent() && rateDetails.get().noPrefix != null) {
                    stripOperatorPrefixForDestLookup = rateDetails.get().noPrefix;
                }
            } else {
                stripOperatorPrefixForDestLookup = true;
            }

            if (stripOperatorPrefixForDestLookup && prefixInfo.getPrefixCode() != null
                    && !prefixInfo.getPrefixCode().isEmpty()
                    && numberForLookup.startsWith(prefixInfo.getPrefixCode())) {
                numberAfterOperatorPrefixStrip = numberForLookup.substring(prefixInfo.getPrefixCode().length());
                operatorPrefixToPassToFindDest = null;
                log.trace("Stripped operator prefix '{}'. Number for dest lookup: {}", prefixInfo.getPrefixCode(),
                        numberAfterOperatorPrefixStrip);
            }

            String numberForDestLookup = numberAfterOperatorPrefixStrip;
            if (prefixInfo.getTelephonyTypeMaxLength() != null
                    && numberForDestLookup.length() > prefixInfo.getTelephonyTypeMaxLength()) {
                numberForDestLookup = numberForDestLookup.substring(0, prefixInfo.getTelephonyTypeMaxLength());
                log.debug("Number truncated to max length ({}) for type {}. New number for dest lookup: {}",
                        prefixInfo.getTelephonyTypeMaxLength(), prefixInfo.getTelephonyTypeId(), numberForDestLookup);
            }

            Optional<DestinationInfo> destInfoOpt = indicatorLookupService.findDestinationIndicator(
                    numberForDestLookup, // Use the potentially truncated number
                    prefixInfo.telephonyTypeId,
                    prefixInfo.telephonyTypeMinLength != null ? prefixInfo.telephonyTypeMinLength : 0,
                    commLocation.getIndicatorId(),
                    prefixInfo.prefixId,
                    commLocation.getIndicator().getOriginCountryId(),
                    prefixInfo.bandsAssociatedCount > 0,
                    (operatorPrefixToPassToFindDest == null),
                    operatorPrefixToPassToFindDest);
            log.trace("Destination lookup for '{}' (type {}): {}", numberForDestLookup, prefixInfo.telephonyTypeId,
                    destInfoOpt.isPresent() ? destInfoOpt.get() : "Not Found");

            if (destInfoOpt.isPresent()) {
                DestinationInfo currentDestInfo = destInfoOpt.get();
                if (result.bestDestInfo == null ||
                        (currentDestInfo.isApproximateMatch() == result.bestDestInfo.isApproximateMatch()
                                && currentDestInfo.getPaddedSeriesRangeSize() < result.bestDestInfo
                                        .getPaddedSeriesRangeSize())
                        ||
                        (!currentDestInfo.isApproximateMatch() && result.bestDestInfo.isApproximateMatch())) {
                    result.bestDestInfo = currentDestInfo;
                    result.bestPrefixInfo = prefixInfo;
                    result.matchedNumber = numberForDestLookup;
                    log.debug("New best destination match for attempt: {}, with prefix: {}", result.bestDestInfo,
                            result.bestPrefixInfo.getPrefixCode());
                }
                if (result.bestDestInfo != null && !result.bestDestInfo.isApproximateMatch()) {
                    log.debug("Exact destination match found for attempt. Stopping prefix iteration.");
                    break;
                }
            }
        }
        result.finalNumberUsedForDestLookup = numberForLookup;
        if (result.bestDestInfo != null) {
            result.finalNumberUsedForDestLookup = result.bestDestInfo.getMatchedPhoneNumber();
        }
        return result;
    }

    private void applyTariffingResult(CdrData cdrData, TariffingAttemptResult result,
            CommunicationLocation commLocation, Optional<TrunkInfo> trunkInfoOpt, ExtensionLimits extensionLimits) {
        if (result.bestDestInfo != null && result.bestPrefixInfo != null) {
            log.debug("Applying tariffing result. Destination: {}, Prefix: {}",
                    result.bestDestInfo.getDestinationDescription(), result.bestPrefixInfo.getPrefixCode());

            cdrData.setEffectiveDestinationNumber(result.getMatchedNumber());
            log.debug("CDR effective destination number updated to matched/truncated value: {}",
                    cdrData.getEffectiveDestinationNumber());

            cdrData.setTelephonyTypeId(result.bestPrefixInfo.telephonyTypeId);
            cdrData.setTelephonyTypeName(result.bestPrefixInfo.telephonyTypeName);

            if (result.bestDestInfo.getOperatorId() != null && result.bestDestInfo.getOperatorId() != 0L) {
                cdrData.setOperatorId(result.bestDestInfo.getOperatorId());
                String operatorNameFromIndicator = operatorLookupService
                        .findOperatorNameById(result.bestDestInfo.getOperatorId());
                cdrData.setOperatorName(operatorNameFromIndicator != null ? operatorNameFromIndicator
                        : result.bestPrefixInfo.operatorName);
            } else {
                cdrData.setOperatorId(result.bestPrefixInfo.operatorId);
                cdrData.setOperatorName(result.bestPrefixInfo.operatorName);
            }

            cdrData.setIndicatorId(result.bestDestInfo.getIndicatorId());
            cdrData.setDestinationCityName(result.bestDestInfo.getDestinationDescription());

            if (cdrData.getTelephonyTypeId() == TelephonyTypeEnum.LOCAL.getValue() &&
                    indicatorLookupService.isLocalExtended(result.bestDestInfo.getNdc(), commLocation.getIndicatorId(),
                            result.bestDestInfo.getIndicatorId())) {
                log.debug("Call to {} identified as LOCAL_EXTENDED.", result.bestDestInfo.getDestinationDescription());
                cdrData.setTelephonyTypeId(TelephonyTypeEnum.LOCAL_EXTENDED.getValue());
                cdrData.setTelephonyTypeName(
                        telephonyTypeLookupService.getTelephonyTypeName(TelephonyTypeEnum.LOCAL_EXTENDED.getValue()));
                PrefixInfo localExtPrefixInfo = telephonyTypeLookupService
                        .getPrefixInfoForLocalExtended(commLocation.getIndicator().getOriginCountryId());
                if (localExtPrefixInfo != null) {
                    cdrData.setOperatorId(localExtPrefixInfo.getOperatorId());
                    cdrData.setOperatorName(localExtPrefixInfo.getOperatorName());
                    result.bestPrefixInfo.prefixId = localExtPrefixInfo.getPrefixId(); // Update for subsequent logic
                }
            }

            TariffValue baseTariff = telephonyTypeLookupService.getBaseTariffValue(
                    result.bestPrefixInfo.prefixId,
                    result.bestDestInfo.getIndicatorId(),
                    commLocation.getId(),
                    commLocation.getIndicatorId());
            log.debug("Base tariff for prefixId {}: {}", result.bestPrefixInfo.prefixId, baseTariff);

            cdrData.setPricePerMinute(baseTariff.getRateValue());
            cdrData.setPriceIncludesVat(baseTariff.isIncludesVat());
            cdrData.setVatRate(baseTariff.getVatRate());
            // Initial price defaults to 0. It is only set if a rule changes it from the
            // base.

            if (trunkInfoOpt.isPresent() && !result.isWasNormalizedAttempt()) {
                applyTrunkSpecificRates(cdrData, trunkInfoOpt.get(), commLocation);
            }

            applySpecialRatesAndRules(cdrData, commLocation, result.bestDestInfo, trunkInfoOpt.orElse(null));
            cdrData.setBilledAmount(calculateFinalBilledAmount(cdrData));
        } else {
            log.debug(
                    "Could not determine destination or tariff for: {} (original number for tariffing: {}). Applying fallback logic.",
                    result.finalNumberUsedForDestLookup, result.finalNumberUsedForDestLookup);

            Long attemptedTelephonyTypeId = null;
            int attemptedMinLength = 0;

            if (result.bestPrefixInfo != null) {
                attemptedTelephonyTypeId = result.bestPrefixInfo.telephonyTypeId;
                attemptedMinLength = result.bestPrefixInfo.telephonyTypeMinLength != null
                        ? result.bestPrefixInfo.telephonyTypeMinLength
                        : 0;
            } else {
                // This is the corrected logic. If no prefix was found, we don't default to
                // LOCAL.
                // We set the type to an error/unclassified state.
                attemptedTelephonyTypeId = TelephonyTypeEnum.ERRORS.getValue();
                log.debug("No matching prefix found. Setting attempted telephony type to ERROR state.");
            }

            int phoneLength = result.finalNumberUsedForDestLookup.length();
            int maxInternalLength = String.valueOf(extensionLimits.getMaxLength()).length();
            boolean isLocalType = telephonyTypeLookupService.isLocalType(attemptedTelephonyTypeId);

            boolean isError = (isLocalType && phoneLength > maxInternalLength && phoneLength < attemptedMinLength) ||
                    (!isLocalType && phoneLength < attemptedMinLength);

            if (isError || attemptedTelephonyTypeId == null
                    || attemptedTelephonyTypeId.equals(TelephonyTypeEnum.ERRORS.getValue())) {
                log.debug("Number '{}' has invalid length or no matching prefix type. Marking as ERROR.",
                        result.finalNumberUsedForDestLookup);
                cdrData.setTelephonyTypeId(TelephonyTypeEnum.ERRORS.getValue());
                cdrData.setTelephonyTypeName("Invalid Number Length or No Matching Prefix");
            } else {
                log.debug(
                        "Number '{}' is valid for attempted type {} but no destination was found. Assigning type with zero cost.",
                        result.finalNumberUsedForDestLookup, attemptedTelephonyTypeId);
                cdrData.setTelephonyTypeId(attemptedTelephonyTypeId);
                cdrData.setTelephonyTypeName(telephonyTypeLookupService.getTelephonyTypeName(attemptedTelephonyTypeId)
                        + " (Unclassified - No Destination Match)");
            }

            cdrData.setBilledAmount(BigDecimal.ZERO);
            cdrData.setPricePerMinute(BigDecimal.ZERO);
            cdrData.setInitialPricePerMinute(BigDecimal.ZERO);
        }
    }

    private void applyTrunkSpecificRates(CdrData cdrData, TrunkInfo trunkInfo, CommunicationLocation commLocation) {
        log.debug("Applying trunk-specific rates for trunk: {}", trunkInfo.description);
        Optional<TrunkRateDetails> rateDetailsOpt = trunkLookupService.getRateDetailsForTrunk(
                trunkInfo.id, cdrData.getTelephonyTypeId(), cdrData.getOperatorId());
        if (rateDetailsOpt.isPresent()) {
            TrunkRateDetails rd = rateDetailsOpt.get();
            log.debug("Found specific rate details for trunk: {}", rd);
            // Store current price as initial before overriding with trunk rate, ONLY if not
            // already set (legacy logic: defaults to 0)
            if (cdrData.getInitialPricePerMinute() == null
                    || cdrData.getInitialPricePerMinute().compareTo(BigDecimal.ZERO) == 0) {
                cdrData.setInitialPricePerMinute(cdrData.getPricePerMinute());
                cdrData.setInitialPriceIncludesVat(cdrData.isPriceIncludesVat());
            }

            cdrData.setPricePerMinute(rd.rateValue);
            cdrData.setPriceIncludesVat(rd.includesVat);
            cdrData.setChargeBySecond(rd.seconds != null && rd.seconds > 0);
            cdrData.setVatRate(telephonyTypeLookupService.getVatForPrefix(rd.telephonyTypeId, rd.operatorId,
                    commLocation.getIndicator().getOriginCountryId()));
            cdrData.setTelephonyTypeName(cdrData.getTelephonyTypeName() + " (Trunk: " + trunkInfo.description + ")");

            if (trunkInfo.isCelufijo() && cdrData.getTelephonyTypeId() == TelephonyTypeEnum.CELLULAR.getValue()) {
                log.debug("Trunk is celufijo and call is cellular. Changing type to CELUFIJO.");
                cdrData.setTelephonyTypeId(TelephonyTypeEnum.CELUFIJO.getValue());
                cdrData.setTelephonyTypeName("Celufijo (Trunk: " + trunkInfo.description + ")");
            }
        } else {
            log.debug(
                    "No specific rate details found for trunk {} with type {} and operator {}. Using previously determined base prefix tariff.",
                    trunkInfo.description, cdrData.getTelephonyTypeId(), cdrData.getOperatorId());
        }
    }

    private void applySpecialRatesAndRules(CdrData cdrData, CommunicationLocation commLocation,
            DestinationInfo destinationInfo, TrunkInfo trunkInfo) {
        // Initial price logic: Defaults to 0. If a rule is applied, we save the
        // *previous* rate as initial (Logic: "First Time Assigned")

        if (cdrConfigService.isSpecialValueTariffingEnabled()) {
            log.debug("Special value tariffing is enabled. Looking for applicable special rates.");
            Optional<SpecialRateInfo> specialRateOpt = specialRateValueLookupService.getApplicableSpecialRate(
                    cdrData.getDateTimeOrigination(),
                    commLocation.getIndicatorId(),
                    cdrData.getTelephonyTypeId(),
                    cdrData.getOperatorId(),
                    destinationInfo != null ? destinationInfo.getBandId() : null);

            if (specialRateOpt.isPresent()) {
                SpecialRateInfo sr = specialRateOpt.get();
                log.debug("Applying special rate: {}", sr);
                // Store current price as initial *before* applying special rate, if it hasn't
                // been set yet (is 0)
                if (cdrData.getInitialPricePerMinute() == null
                        || cdrData.getInitialPricePerMinute().compareTo(BigDecimal.ZERO) == 0) {
                    cdrData.setInitialPricePerMinute(cdrData.getPricePerMinute());
                    cdrData.setInitialPriceIncludesVat(cdrData.isPriceIncludesVat());
                }

                if (sr.valueType == 0) { // Absolute value
                    cdrData.setPricePerMinute(sr.rateValue);
                    cdrData.setPriceIncludesVat(sr.includesVat);
                } else { // Percentage discount
                    BigDecimal currentRateNoVat = cdrData.isPriceIncludesVat() && cdrData.getVatRate() != null
                            && cdrData.getVatRate().compareTo(BigDecimal.ZERO) > 0
                                    ? cdrData.getPricePerMinute()
                                            .divide(BigDecimal.ONE.add(cdrData.getVatRate()
                                                    .divide(BigDecimal.valueOf(100), 8, RoundingMode.HALF_UP)), 8,
                                                    RoundingMode.HALF_UP)
                                    : cdrData.getPricePerMinute();

                    BigDecimal discountPercentage = sr.rateValue;
                    BigDecimal discountFactor = BigDecimal.ONE
                            .subtract(discountPercentage.divide(BigDecimal.valueOf(100), 8, RoundingMode.HALF_UP));
                    cdrData.setPricePerMinute(currentRateNoVat.multiply(discountFactor));
                    cdrData.setPriceIncludesVat(false);
                    cdrData.setSpecialRateDiscountPercentage(discountPercentage);
                }
                cdrData.setVatRate(sr.vatRate);
                cdrData.setTelephonyTypeName(cdrData.getTelephonyTypeName() + " (Special Rate)");
            }
        } else {
            log.debug("Special value tariffing is disabled. Skipping special rate lookup.");
        }

        if (cdrData.getCallDirection() != CallDirection.INCOMING && cdrData.getDestDeviceName() != null
                && !cdrData.getDestDeviceName().isEmpty()) {
            Optional<AppliedTrunkRuleInfo> ruleInfoOpt = trunkRuleLookupService.getAppliedTrunkRule(
                    cdrData.getDestDeviceName(),
                    cdrData.getTelephonyTypeId(), // Use current type, which might have been changed by special rate
                    cdrData.getIndicatorId(),
                    commLocation.getIndicatorId());
            if (ruleInfoOpt.isPresent()) {
                AppliedTrunkRuleInfo rule = ruleInfoOpt.get();
                log.debug("Applying trunk rule: {}", rule);
                // Store current price as initial *before* applying rule, if it hasn't been set
                // yet (is 0)
                if (cdrData.getInitialPricePerMinute() == null
                        || cdrData.getInitialPricePerMinute().compareTo(BigDecimal.ZERO) == 0) {
                    cdrData.setInitialPricePerMinute(cdrData.getPricePerMinute());
                    cdrData.setInitialPriceIncludesVat(cdrData.isPriceIncludesVat());
                }

                cdrData.setPricePerMinute(rule.rateValue);
                cdrData.setPriceIncludesVat(rule.includesVat);
                cdrData.setChargeBySecond(rule.seconds != null && rule.seconds > 0);

                if (rule.newTelephonyTypeId != null && rule.newTelephonyTypeId != 0L) {
                    cdrData.setTelephonyTypeId(rule.newTelephonyTypeId);
                    cdrData.setTelephonyTypeName(rule.newTelephonyTypeName != null ? rule.newTelephonyTypeName
                            : telephonyTypeLookupService.getTelephonyTypeName(rule.newTelephonyTypeId));
                }
                if (rule.newOperatorId != null && rule.newOperatorId != 0L) {
                    cdrData.setOperatorId(rule.newOperatorId);
                    cdrData.setOperatorName(rule.newOperatorName != null ? rule.newOperatorName
                            : operatorLookupService.findOperatorNameById(rule.newOperatorId));
                }
                cdrData.setVatRate(rule.vatRate);
                cdrData.setTelephonyTypeName(cdrData.getTelephonyTypeName() + " (Rule Applied)");
            }
        }
    }

    private boolean isTariffResultInvalidOrAssumed(TariffingAttemptResult result) {
        return result.bestDestInfo == null ||
                result.bestPrefixInfo == null ||
                result.bestPrefixInfo.telephonyTypeId == null ||
                result.bestPrefixInfo.telephonyTypeId <= 0 ||
                result.bestPrefixInfo.telephonyTypeId == TelephonyTypeEnum.ERRORS.getValue() ||
                (result.bestDestInfo.getDestinationDescription() != null
                        && result.bestDestInfo.getDestinationDescription().contains(appConfigService.getAssumedText()))
                ||
                (result.bestPrefixInfo.telephonyTypeName != null
                        && result.bestPrefixInfo.telephonyTypeName.contains(appConfigService.getAssumedText()));
    }

    private BigDecimal calculateFinalBilledAmount(CdrData cdrData) {
        if (cdrData.getPricePerMinute() == null || cdrData.getDurationSeconds() == null
                || cdrData.getDurationSeconds() < 0) {
            log.debug("Cannot calculate billed amount: PricePerMinute or DurationSeconds is null/invalid.");
            return BigDecimal.ZERO;
        }

        long billableDurationUnits;
        BigDecimal ratePerUnit;

        if (cdrData.isChargeBySecond()) {
            billableDurationUnits = cdrData.getDurationSeconds();
            if (cdrData.getPricePerMinute().compareTo(BigDecimal.ZERO) == 0 && billableDurationUnits > 0) {
                ratePerUnit = BigDecimal.ZERO;
            } else if (cdrData.getPricePerMinute().compareTo(BigDecimal.ZERO) == 0 && billableDurationUnits == 0) {
                ratePerUnit = BigDecimal.ZERO;
            } else {
                ratePerUnit = cdrData.getPricePerMinute().divide(BigDecimal.valueOf(60), 8, RoundingMode.HALF_UP);
            }
        } else {
            billableDurationUnits = (long) Math.ceil((double) cdrData.getDurationSeconds() / 60.0);
            if (billableDurationUnits == 0 && cdrData.getDurationSeconds() > 0)
                billableDurationUnits = 1;
            ratePerUnit = cdrData.getPricePerMinute();
        }

        if (billableDurationUnits == 0)
            return BigDecimal.ZERO;

        BigDecimal totalCost = ratePerUnit.multiply(BigDecimal.valueOf(billableDurationUnits));
        if (!cdrData.isPriceIncludesVat() && cdrData.getVatRate() != null
                && cdrData.getVatRate().compareTo(BigDecimal.ZERO) > 0) {
            BigDecimal vatMultiplier = BigDecimal.ONE
                    .add(cdrData.getVatRate().divide(BigDecimal.valueOf(100), 8, RoundingMode.HALF_UP));
            totalCost = totalCost.multiply(vatMultiplier);
        }
        return totalCost.setScale(4, RoundingMode.HALF_UP);
    }
}

============================================================
FILE: TariffValue.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/TariffValue.java
SIZE: 0.3 KB
MODIFIED: 2025-06-04 13:40:58
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import lombok.*;

import java.math.BigDecimal;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class TariffValue {
    private BigDecimal rateValue;
    private boolean includesVat;
    private BigDecimal vatRate;
}



============================================================
FILE: TariffingAttemptResult.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/TariffingAttemptResult.java
SIZE: 0.57 KB
MODIFIED: 2025-06-09 13:50:53
============================================================
// File: com/infomedia/abacox/telephonypricing/component/cdrprocessing/TariffingAttemptResult.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import lombok.Data;

@Data
public class TariffingAttemptResult {
    DestinationInfo bestDestInfo;
    PrefixInfo bestPrefixInfo;
    String finalNumberUsedForDestLookup; // The number string after operator prefix stripping, used for findDestinationIndicator
    boolean wasNormalizedAttempt = false; // Flag to indicate if this result came from a normalization attempt
    String matchedNumber;
}

============================================================
FILE: TelephonyTypeEnum.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/TelephonyTypeEnum.java
SIZE: 1.49 KB
MODIFIED: 2025-06-09 13:11:55
============================================================
// File: com/infomedia/abacox/telephonypricing/cdr/TelephonyTypeEnum.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

public enum TelephonyTypeEnum {
    CELUFIJO(1L, "Celufijo"),
    CELLULAR(2L, "Celular"),
    LOCAL(3L, "Local"),
    NATIONAL(4L, "Nacional"),
    INTERNATIONAL(5L, "Internacional"),
    VARIOUS_SERVICES(6L, "Servicios varios"),
    INTERNAL_SIMPLE(7L, "Interna"), // Mapped from CSV ID 7 "Interna"
    LOCAL_IP(8L, "Interna Local"),
    NATIONAL_IP(9L, "Interna Nacional"),
    SATELLITE(10L, "Satelital"),
    SPECIAL_SERVICES(11L, "Nmeros especiales"),
    LOCAL_EXTENDED(12L, "Local extendida"),
    REVERTED_PAYMENT(13L, "Pago revertido"),
    INTERNAL_INTERNATIONAL_IP(14L, "Interna Internacional"),
    // ID 15 is missing in CSV
    NO_CONSUMPTION(16L, "Sin Consumo"),
    ERRORS(null, "Errores (No Vlido)"); // PHP: _TIPOTELE_ERRORES

    private final Long value;
    private final String defaultName;

    TelephonyTypeEnum(Long value, String defaultName) {
        this.value = value;
        this.defaultName = defaultName;
    }

    public Long getValue() {
        return value;
    }

    public String getDefaultName() { return defaultName; }

    public static TelephonyTypeEnum fromId(Long id) {
        if (id == null) return ERRORS;
        for (TelephonyTypeEnum type : values()) {
            if (type.value == id) {
                return type;
            }
        }
        return ERRORS;
    }
}

============================================================
FILE: TelephonyTypeLookupService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/TelephonyTypeLookupService.java
SIZE: 17.07 KB
MODIFIED: 2025-11-21 13:32:24
============================================================
// File: com/infomedia/abacox/telephonypricing/cdr/TelephonyTypeLookupService.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.Prefix;
import com.infomedia.abacox.telephonypricing.db.entity.TelephonyTypeConfig;
import jakarta.persistence.EntityManager;
import jakarta.persistence.NoResultException;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.Tuple;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.*;

@Service
@Log4j2
public class TelephonyTypeLookupService {
    @PersistenceContext
    private EntityManager entityManager;

    @Transactional(readOnly = true)
    public String getTelephonyTypeName(Long telephonyTypeId) {
        if (telephonyTypeId == null) return TelephonyTypeEnum.ERRORS.getDefaultName();
        try {
            return entityManager.createQuery("SELECT tt.name FROM TelephonyType tt WHERE tt.id = :id AND tt.active = true", String.class)
                    .setParameter("id", telephonyTypeId)
                    .getSingleResult();
        } catch (NoResultException e) {
            return TelephonyTypeEnum.fromId(telephonyTypeId).getDefaultName();
        }
    }

    @Transactional(readOnly = true)
    public PrefixInfo getPrefixInfoForLocalExtended(Long originCountryId) {
        String queryStr = "SELECT p.*, ttc.min_value as ttc_min, ttc.max_value as ttc_max, " +
                "(SELECT COUNT(*) FROM band b WHERE b.prefix_id = p.id AND b.active = true) as bands_count " +
                "FROM prefix p " +
                "JOIN operator o ON p.operator_id = o.id " +
                "JOIN telephony_type tt ON p.telephony_type_id = tt.id " +
                "LEFT JOIN telephony_type_config ttc ON tt.id = ttc.telephony_type_id AND ttc.origin_country_id = :originCountryId AND ttc.active = true " +
                "WHERE p.active = true AND o.active = true AND tt.active = true AND o.origin_country_id = :originCountryId " +
                "AND p.telephony_type_id = :localExtendedTypeId LIMIT 1";

        jakarta.persistence.Query nativeQuery = entityManager.createNativeQuery(queryStr, Tuple.class);
        nativeQuery.setParameter("originCountryId", originCountryId);
        nativeQuery.setParameter("localExtendedTypeId", TelephonyTypeEnum.LOCAL_EXTENDED.getValue());

        try {
            Tuple tuple = (Tuple) nativeQuery.getSingleResult();
            Prefix p = entityManager.find(Prefix.class, tuple.get("id", Number.class).longValue());
            TelephonyTypeConfig cfg = new TelephonyTypeConfig();
            cfg.setMinValue(tuple.get("ttc_min", Number.class) != null ? tuple.get("ttc_min", Number.class).intValue() : 0);
            cfg.setMaxValue(tuple.get("ttc_max", Number.class) != null ? tuple.get("ttc_max", Number.class).intValue() : 99);
            int bandsCount = tuple.get("bands_count", Number.class).intValue();
            return new PrefixInfo(p, cfg, bandsCount);
        } catch (NoResultException e) {
            log.debug("No prefix definition found for LOCAL_EXTENDED type in country {}", originCountryId);
            return null;
        }
    }

    @Transactional(readOnly = true)
    public OperatorInfo getInternalOperatorInfo(Long telephonyTypeId, Long originCountryId) {
        String queryStr = "SELECT o.id, o.name FROM operator o JOIN prefix p ON p.operator_id = o.id " +
                "WHERE p.telephony_type_id = :telephonyTypeId AND o.origin_country_id = :originCountryId " +
                "AND o.active = true AND p.active = true " +
                "LIMIT 1";
        jakarta.persistence.Query query = entityManager.createNativeQuery(queryStr, Tuple.class);
        query.setParameter("telephonyTypeId", telephonyTypeId);
        query.setParameter("originCountryId", originCountryId);
        try {
            Tuple result = (Tuple) query.getSingleResult();
            return new OperatorInfo(result.get("id", Number.class).longValue(), result.get("name", String.class));
        } catch (NoResultException e) {
            log.debug("No internal operator found for telephony type {} and country {}", telephonyTypeId, originCountryId);
            return new OperatorInfo(CdrConfigService.DEFAULT_OPERATOR_ID_FOR_INTERNAL, "UnknownInternalOperator");
        }
    }

    @Transactional(readOnly = true)
    public BigDecimal getVatForPrefix(Long telephonyTypeId, Long operatorId, Long originCountryId) {
        String queryStr = "SELECT p.vat_value FROM prefix p " +
                "WHERE p.active = true AND p.telephony_type_id = :telephonyTypeId AND p.operator_id = :operatorId " +
                "AND EXISTS (SELECT 1 FROM operator o WHERE o.id = p.operator_id AND o.origin_country_id = :originCountryId AND o.active = true) " +
                "LIMIT 1";
        jakarta.persistence.Query query = entityManager.createNativeQuery(queryStr);
        query.setParameter("telephonyTypeId", telephonyTypeId);
        query.setParameter("operatorId", operatorId);
        query.setParameter("originCountryId", originCountryId);
        try {
            Object result = query.getSingleResult();
            return result != null ? (BigDecimal) result : BigDecimal.ZERO;
        } catch (NoResultException e) {
            log.debug("No VAT rate found for prefix with type {}, operator {}, country {}", telephonyTypeId, operatorId, originCountryId);
            return BigDecimal.ZERO;
        }
    }

    @Transactional(readOnly = true)
    public TariffValue getBaseTariffValue(Long prefixId, Long destinationIndicatorId,
                                          Long commLocationId, Long originIndicatorIdForBand) {
        String prefixQueryStr = "SELECT p.base_value, p.vat_included, p.vat_value, p.band_ok, p.id as prefix_id, p.telephony_type_id " +
                "FROM prefix p WHERE p.id = :prefixId AND p.active = true";
        jakarta.persistence.Query prefixQuery = entityManager.createNativeQuery(prefixQueryStr, Tuple.class);
        prefixQuery.setParameter("prefixId", prefixId);

        try {
            Tuple pRes = (Tuple) prefixQuery.getSingleResult();
            BigDecimal baseValue = pRes.get("base_value", BigDecimal.class);
            boolean vatIncluded = pRes.get("vat_included", Boolean.class);
            BigDecimal vatValue = pRes.get("vat_value", BigDecimal.class);
            boolean bandOk = pRes.get("band_ok", Boolean.class);
            Long telephonyTypeId = pRes.get("telephony_type_id", Number.class).longValue();


            if (bandOk && (destinationIndicatorId != null && destinationIndicatorId > 0 || isLocalType(telephonyTypeId))) {
                StringBuilder bandQueryBuilder = new StringBuilder(
                    "SELECT b.value as band_value, b.vat_included as band_vat_included " +
                    "FROM band b ");
                if (!isLocalType(telephonyTypeId)) {
                    bandQueryBuilder.append("JOIN band_indicator bi ON b.id = bi.band_id AND bi.indicator_id = :destinationIndicatorId ");
                }
                bandQueryBuilder.append("WHERE b.active = true AND b.prefix_id = :prefixId ");
                bandQueryBuilder.append("AND (b.origin_indicator_id = 0 OR b.origin_indicator_id IS NULL OR b.origin_indicator_id = :originIndicatorIdForBand) ");
                bandQueryBuilder.append("ORDER BY b.origin_indicator_id DESC NULLS LAST LIMIT 1");

                jakarta.persistence.Query bandQuery = entityManager.createNativeQuery(bandQueryBuilder.toString(), Tuple.class);
                bandQuery.setParameter("prefixId", prefixId);
                bandQuery.setParameter("originIndicatorIdForBand", originIndicatorIdForBand);
                if (!isLocalType(telephonyTypeId)) {
                    bandQuery.setParameter("destinationIndicatorId", destinationIndicatorId);
                }

                List<Tuple> bandResults = bandQuery.getResultList();
                if (!bandResults.isEmpty()) {
                    Tuple bRes = bandResults.get(0);
                    log.debug("Found band-specific rate for prefixId {}", prefixId);
                    return new TariffValue(
                            bRes.get("band_value", BigDecimal.class),
                            bRes.get("band_vat_included", Boolean.class),
                            vatValue // VAT rate is from prefix, not band
                    );
                }
            }
            return new TariffValue(baseValue, vatIncluded, vatValue);

        } catch (NoResultException e) {
            log.debug("No prefix found for ID: {}", prefixId);
            return new TariffValue(BigDecimal.ZERO, false, BigDecimal.ZERO);
        }
    }

    public boolean isLocalType(Long telephonyTypeId) {
        return telephonyTypeId != null &&
                (telephonyTypeId.equals(TelephonyTypeEnum.LOCAL.getValue()) ||
                        telephonyTypeId.equals(TelephonyTypeEnum.LOCAL_EXTENDED.getValue()));
    }

    @Transactional(readOnly = true)
    public TariffValue getInternalTariffValue(Long internalTelephonyTypeId, Long originCountryId) {
        String queryStr = "SELECT p.base_value, p.vat_included, p.vat_value " +
                          "FROM prefix p JOIN operator o ON p.operator_id = o.id " +
                          "WHERE p.active = true AND o.active = true " +
                          "AND p.telephony_type_id = :telephonyTypeId AND o.origin_country_id = :originCountryId " +
                          "LIMIT 1";

        jakarta.persistence.Query query = entityManager.createNativeQuery(queryStr, Tuple.class);
        query.setParameter("telephonyTypeId", internalTelephonyTypeId);
        query.setParameter("originCountryId", originCountryId);

        try {
            Tuple result = (Tuple) query.getSingleResult();
            return new TariffValue(
                result.get("base_value", BigDecimal.class),
                result.get("vat_included", Boolean.class),
                result.get("vat_value", BigDecimal.class)
            );
        } catch (NoResultException e) {
            log.debug("No internal tariff found for type {} and country {}", internalTelephonyTypeId, originCountryId);
            return new TariffValue(BigDecimal.ZERO, false, BigDecimal.ZERO);
        }
    }


    public boolean isInternalIpType(Long telephonyTypeId) {
        if (telephonyTypeId == null) return false;
        return telephonyTypeId.equals(TelephonyTypeEnum.INTERNAL_SIMPLE.getValue()) ||
                telephonyTypeId.equals(TelephonyTypeEnum.LOCAL_IP.getValue()) ||
                telephonyTypeId.equals(TelephonyTypeEnum.NATIONAL_IP.getValue()) ||
                telephonyTypeId.equals(TelephonyTypeEnum.INTERNAL_INTERNATIONAL_IP.getValue());
    }

    public List<Long> getInternalTypeIds() {
        return new ArrayList<>(Arrays.asList(
                TelephonyTypeEnum.INTERNAL_SIMPLE.getValue(),
                TelephonyTypeEnum.LOCAL_IP.getValue(),
                TelephonyTypeEnum.NATIONAL_IP.getValue(),
                TelephonyTypeEnum.INTERNAL_INTERNATIONAL_IP.getValue()
        ));
    }

    @Transactional(readOnly = true)
    public List<IncomingTelephonyTypePriority> getIncomingTelephonyTypePriorities(Long originCountryId) {
        // PHP's prefijos_OrdenarEntrantes
        // It iterates prefixes, then groups by telephony_type_id, calculating min/max subscriber lengths.
        // Then adds LOCAL if not present. Finally sorts by min_subscriber_length (derived from total_length) descending.

        String queryStr = "SELECT DISTINCT " +
                "p.telephony_type_id, tt.name as telephony_type_name, p.code as prefix_code, " +
                "ttc.min_value as cfg_min_len, ttc.max_value as cfg_max_len " +
                "FROM prefix p " +
                "JOIN telephony_type tt ON p.telephony_type_id = tt.id " +
                "JOIN operator o ON p.operator_id = o.id " +
                "LEFT JOIN telephony_type_config ttc ON p.telephony_type_id = ttc.telephony_type_id AND ttc.origin_country_id = :originCountryId AND ttc.active = true " +
                "WHERE p.active = true AND tt.active = true AND o.active = true AND o.origin_country_id = :originCountryId " +
                "AND p.telephony_type_id NOT IN (:excludedTypeIds) " +
                "AND p.code IS NOT NULL AND p.code != '' "; // Only consider types that have operator prefixes defined for this initial gathering

        List<Long> excludedTypeIds = new ArrayList<>(getInternalTypeIds());
        excludedTypeIds.add(TelephonyTypeEnum.CELUFIJO.getValue());
        excludedTypeIds.add(TelephonyTypeEnum.SPECIAL_SERVICES.getValue());

        jakarta.persistence.Query nativeQuery = entityManager.createNativeQuery(queryStr, Tuple.class);
        nativeQuery.setParameter("originCountryId", originCountryId);
        nativeQuery.setParameter("excludedTypeIds", excludedTypeIds);

        List<Tuple> results = nativeQuery.getResultList();
        Map<Long, IncomingTelephonyTypePriority> typeMap = new HashMap<>();

        for (Tuple row : results) {
            Long ttId = row.get("telephony_type_id", Number.class).longValue();
            String ttName = row.get("telephony_type_name", String.class);
            String prefixCode = row.get("prefix_code", String.class);
            Integer cfgMin = row.get("cfg_min_len", Number.class) != null ? row.get("cfg_min_len", Number.class).intValue() : 0;
            Integer cfgMax = row.get("cfg_max_len", Number.class) != null ? row.get("cfg_max_len", Number.class).intValue() : 99;

            int prefixLen = (prefixCode != null) ? prefixCode.length() : 0;
            int subscriberMinLen = Math.max(0, cfgMin - prefixLen);
            int subscriberMaxLen = Math.max(0, cfgMax - prefixLen);

            IncomingTelephonyTypePriority current = typeMap.get(ttId);
            if (current == null) {
                current = new IncomingTelephonyTypePriority(ttId, ttName, subscriberMinLen, subscriberMaxLen, cfgMin, cfgMax, "");
                typeMap.put(ttId, current);
            } else {
                // If a type is associated with multiple prefixes, take the most lenient subscriber lengths
                // and the original total lengths (cfgMin/Max should be consistent for a type/country).
                // Take the HIGHEST of the minimums.
                current.setMinSubscriberLength(Math.max(current.getMinSubscriberLength(), subscriberMinLen));
                // Take the LOWEST of the maximums.
                current.setMaxSubscriberLength(Math.min(current.getMaxSubscriberLength(), subscriberMaxLen));
            }
        }
        
        // Add LOCAL type explicitly if not covered by prefixes, as PHP does
        if (!typeMap.containsKey(TelephonyTypeEnum.LOCAL.getValue())) {
            TelephonyTypeConfig localCfg = getTelephonyTypeConfig(TelephonyTypeEnum.LOCAL.getValue(), originCountryId);
            int localMin = localCfg != null ? localCfg.getMinValue() : 0;
            int localMax = localCfg != null ? localCfg.getMaxValue() : 99;
            typeMap.put(TelephonyTypeEnum.LOCAL.getValue(), new IncomingTelephonyTypePriority(
                TelephonyTypeEnum.LOCAL.getValue(),
                getTelephonyTypeName(TelephonyTypeEnum.LOCAL.getValue()),
                localMin, // For LOCAL, subscriber length is total length as no operator prefix is stripped
                localMax,
                localMin, // Total min length
                localMax, // Total max length
                ""
            ));
        }

        List<IncomingTelephonyTypePriority> sortedList = new ArrayList<>(typeMap.values());
        for (IncomingTelephonyTypePriority item : sortedList) {
            // This now correctly mimics the PHP logic of sorting by the length of the
            // subscriber number part, not the total number length.
            item.setOrderKey(String.format("%02d", item.getMinSubscriberLength()));
        }

        // The reverse sort on this new key will now produce the correct priority order.
        sortedList.sort(Comparator.comparing(IncomingTelephonyTypePriority::getOrderKey, Comparator.reverseOrder()));
        log.debug("Sorted incoming telephony type priorities for country {}: {}", originCountryId, sortedList);
        return sortedList;
    }

    @Transactional(readOnly = true)
    public TelephonyTypeConfig getTelephonyTypeConfig(Long telephonyTypeId, Long originCountryId) {
        try {
            return entityManager.createQuery(
                            "SELECT ttc FROM TelephonyTypeConfig ttc " +
                                    "WHERE ttc.telephonyTypeId = :telephonyTypeId AND ttc.originCountryId = :originCountryId AND ttc.active = true",
                            TelephonyTypeConfig.class)
                    .setParameter("telephonyTypeId", telephonyTypeId)
                    .setParameter("originCountryId", originCountryId)
                    .getSingleResult();
        } catch (NoResultException e) {
            return null;
        }
    }
}

============================================================
FILE: TenantBatchPersister.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/TenantBatchPersister.java
SIZE: 5.19 KB
MODIFIED: 2026-01-22 12:20:41
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.component.utils.CompressionZipUtil;
import com.infomedia.abacox.telephonypricing.db.entity.CallRecord;
import com.infomedia.abacox.telephonypricing.db.entity.FailedCallRecord;
import com.infomedia.abacox.telephonypricing.multitenancy.TenantContext;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

@Service
@Log4j2
@RequiredArgsConstructor
public class TenantBatchPersister {

    private final CallRecordPersistenceService callRecordService;
    private final FailedCallRecordPersistenceService failedRecordService;
    private final FileProcessingTrackerService trackerService;

    @PersistenceContext
    private EntityManager entityManager;

    @Transactional(propagation = Propagation.REQUIRED)
    public void persistTenantBatch(List<ProcessedCdrResult> tenantBatch) {
        long batchStartTime = System.currentTimeMillis();
        String tenantId = TenantContext.getTenant(); // For logging

        // 1. Separate Success vs Failed
        List<ProcessedCdrResult> successResults = tenantBatch.stream()
                .filter(r -> r.getOutcome() == ProcessingOutcome.SUCCESS)
                .toList();
        List<ProcessedCdrResult> failedResults = tenantBatch.stream()
                .filter(r -> r.getOutcome() != ProcessingOutcome.SUCCESS)
                .toList();

        if (!successResults.isEmpty()) {
            processSuccessfulBatch(successResults);
        }
        if (!failedResults.isEmpty()) {
            processFailedBatch(failedResults);
        }

        // 2. Measure Database Flush
        long flushStart = System.currentTimeMillis();
        entityManager.flush();
        entityManager.clear();
        long flushTime = System.currentTimeMillis() - flushStart;

        long totalTime = System.currentTimeMillis() - batchStartTime;
        log.info("Persisted Batch of {} records for tenant [{}] in {} ms. (DB Flush took {} ms)",
                tenantBatch.size(), tenantId, totalTime, flushTime);

        // 3. Update Tracker
        updateFileTrackers(tenantBatch);
    }

    private void processSuccessfulBatch(List<ProcessedCdrResult> results) {
        // Changed Map Key to UUID
        Map<UUID, ProcessedCdrResult> uniqueBatch = new HashMap<>();
        for (ProcessedCdrResult res : results) {
            uniqueBatch.put(res.getCdrData().getCtlHash(), res);
        }

        // Changed List<Long> to List<UUID>
        List<UUID> hashesToCheck = new ArrayList<>(uniqueBatch.keySet());
        Set<UUID> existingInDb = callRecordService.findExistingHashes(hashesToCheck);

        existingInDb.forEach(uniqueBatch::remove);
        if (uniqueBatch.isEmpty()) return;

        for (ProcessedCdrResult res : uniqueBatch.values()) {
            CallRecord entity = callRecordService.createEntityFromDto(res.getCdrData(), res.getCommLocation());
            if (entity != null) {
                entityManager.persist(entity);
            }
        }
    }

    private void processFailedBatch(List<ProcessedCdrResult> results) {
        // Changed Map Key to UUID
        Map<UUID, ProcessedCdrResult> uniqueBatch = new HashMap<>();
        for (ProcessedCdrResult res : results) {
            uniqueBatch.put(res.getCdrData().getCtlHash(), res);
        }

        // Changed List<Long> to List<UUID>
        List<UUID> hashesToCheck = new ArrayList<>(uniqueBatch.keySet());
        List<FailedCallRecord> existingRecords = failedRecordService.findExistingRecordsByHashes(hashesToCheck);

        // Changed Map Key to UUID
        Map<UUID, FailedCallRecord> existingMap = existingRecords.stream()
                .collect(Collectors.toMap(FailedCallRecord::getCtlHash, r -> r));

        for (ProcessedCdrResult res : uniqueBatch.values()) {
            UUID hash = res.getCdrData().getCtlHash(); // Changed Long to UUID
            FailedCallRecord existing = existingMap.get(hash);

            if (existing != null) {
                failedRecordService.updateEntityFromDto(existing, res);
                entityManager.merge(existing);
            } else {
                FailedCallRecord newRecord = failedRecordService.createEntityFromDto(res);
                entityManager.persist(newRecord);
            }
        }
    }

    private void updateFileTrackers(List<ProcessedCdrResult> batch) {
        Map<Long, Integer> processedCounts = new HashMap<>();
        for (ProcessedCdrResult res : batch) {
            if (res.getCdrData() != null && res.getCdrData().getFileInfo() != null) {
                Long fileId = res.getCdrData().getFileInfo().getId();
                processedCounts.merge(fileId, 1, Integer::sum);
            }
        }
        processedCounts.forEach(trackerService::decrementPendingCount);
    }
}

============================================================
FILE: TransferCause.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/TransferCause.java
SIZE: 0.84 KB
MODIFIED: 2025-06-14 12:27:06
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

// Based on IMDEX_TRANSFER_* constants
public enum TransferCause {
    NONE(0),
    NORMAL(1), // Transfer
    AUTO(2), // IMDEX_TRANSFER_AUTO
    CONFERENCE(3), // IMDEX_TRANSFER_CONFERENCIA
    CONFERENCE_END(4), // IMDEX_TRANSFER_CONFERE_FIN
    NO_ANSWER(6), // Call Forward No Answer
    BUSY(7), // Call Forward Busy
    CONFERENCE_ADD(8), // IMDEX_TRANSFER_CONFERE_ADD
    PRE_CONFERENCE_NOW(9), // IMDEX_TRANSFER_PRECONFENOW (finaliza_union = 7 for conference setup)
    CONFERENCE_NOW(10); // IMDEX_TRANSFER_CONFENOW (joinOnBehalfOf = 7)

    // ... other causes from PHP's IMDEX_TRANSFER_*




    private final int value;

    TransferCause(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }
}


============================================================
FILE: TransformationResult.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/TransformationResult.java
SIZE: 0.35 KB
MODIFIED: 2025-06-04 13:40:58
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@AllArgsConstructor
@NoArgsConstructor
@Data
public class TransformationResult {
    private String transformedNumber;
    private boolean transformed;
    private Long newTelephonyTypeId;
}

============================================================
FILE: TrunkInfo.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/TrunkInfo.java
SIZE: 1.72 KB
MODIFIED: 2025-06-04 13:40:58
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

@AllArgsConstructor
@NoArgsConstructor
@Data
public class TrunkInfo {
    public Long id;
    public String description;
    public Long operatorId;
    public Boolean noPbxPrefix;
    public List<TrunkRateDetails> rates;

    public List<Long> getAllowedTelephonyTypeIds() {
        if (rates == null) return Collections.emptyList();
        return rates.stream().map(r -> r.telephonyTypeId).distinct().collect(Collectors.toList());
    }

    /**
     * Mimics PHP's $celulink['tr'][$troncal]['celufijo'] logic.
     * A trunk is considered "celufijo" if it ONLY has rates defined for CELLULAR telephony type.
     * @return true if this trunk is exclusively for cellular calls, false otherwise.
     */
    public boolean isCelufijo() {
        if (rates == null || rates.isEmpty()) {
            return false;
        }
        // Check if all defined rates are for cellular and there's at least one such rate.
        boolean hasCellularRate = false;
        for (TrunkRateDetails rate : rates) {
            if (rate.telephonyTypeId != null && rate.telephonyTypeId.equals(TelephonyTypeEnum.CELLULAR.getValue())) {
                hasCellularRate = true;
            } else if (rate.telephonyTypeId != null) {
                // If any rate is for a non-cellular type, it's not exclusively celufijo
                return false;
            }
        }
        return hasCellularRate; // True only if all defined rates were cellular and at least one existed
    }
}

============================================================
FILE: TrunkLookupService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/TrunkLookupService.java
SIZE: 5.78 KB
MODIFIED: 2025-06-11 16:13:09
============================================================
// File: com/infomedia/abacox/telephonypricing/cdr/TrunkLookupService.java
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import com.infomedia.abacox.telephonypricing.db.entity.Trunk;
import com.infomedia.abacox.telephonypricing.db.entity.TrunkRate;
import jakarta.persistence.EntityManager;
import jakarta.persistence.NoResultException;
import jakarta.persistence.PersistenceContext;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@Log4j2
public class TrunkLookupService {
    @PersistenceContext
    private EntityManager entityManager;

    @Transactional(readOnly = true)
    public Optional<TrunkInfo> findTrunkByName(String trunkName, Long commLocationId) {
        // PHP: CargarTroncales and buscarTroncal
        // PHP: CELULINK_COMUBICACION_ID in (0, $comubicacion_id) ORDER BY CELULINK_COMUBICACION_ID ASC
        // This means specific comm_location_id takes precedence if 0 means "all".
        // However, the PHP query actually sorts ASC, meaning 0 (all) would be preferred if both exist.
        // Let's stick to PHP's ASC sort for CELULINK_COMUBICACION_ID (which is t.comm_location_id).
        // If 0 means "global/default" and a specific one exists, the specific one should usually override.
        // The PHP query `ORDER BY CELULINK_COMUBICACION_ID ASC` would pick 0 first if both 0 and specific ID exist.
        // This seems counter-intuitive for overrides. Let's assume the PHP meant specific overrides global.
        // So, `ORDER BY t.comm_location_id DESC` (specific first, then 0 for global).
        String queryStr = "SELECT t.* FROM trunk t " +
                "WHERE t.active = true AND UPPER(t.name) = :trunkName " + // PHP uses strtoupper for troncal_buscar
                "AND (t.comm_location_id = :commLocationId OR t.comm_location_id = 0 OR t.comm_location_id IS NULL) " + // 0 or NULL for global trunks
                "ORDER BY CASE WHEN t.comm_location_id = :commLocationId THEN 0 ELSE 1 END, t.comm_location_id DESC NULLS LAST LIMIT 1";
                // Prioritize exact commLocationId match, then specific non-zero commLocationId, then global (0 or NULL)

        jakarta.persistence.Query nativeQuery = entityManager.createNativeQuery(queryStr, Trunk.class);
        nativeQuery.setParameter("trunkName", trunkName.toUpperCase());
        nativeQuery.setParameter("commLocationId", commLocationId);

        try {
            Trunk trunk = (Trunk) nativeQuery.getSingleResult();
            TrunkInfo ti = new TrunkInfo();
            ti.id = trunk.getId();
            ti.description = trunk.getDescription();
            ti.operatorId = trunk.getOperatorId();
            ti.noPbxPrefix = trunk.getNoPbxPrefix();

            String ratesQueryStr = "SELECT tr.* FROM trunk_rate tr WHERE tr.active = true AND tr.trunk_id = :trunkId";
            List<TrunkRate> trunkRates = entityManager.createNativeQuery(ratesQueryStr, TrunkRate.class)
                    .setParameter("trunkId", trunk.getId())
                    .getResultList();
            ti.rates = trunkRates.stream().map(tr -> {
                TrunkRateDetails rd = new TrunkRateDetails();
                rd.operatorId = tr.getOperatorId();
                rd.telephonyTypeId = tr.getTelephonyTypeId();
                rd.rateValue = tr.getRateValue();
                rd.includesVat = tr.getIncludesVat();
                rd.seconds = tr.getSeconds();
                rd.noPbxPrefix = tr.getNoPbxPrefix();
                rd.noPrefix = tr.getNoPrefix();
                return rd;
            }).collect(Collectors.toList());

            return Optional.of(ti);
        } catch (NoResultException e) {
            return Optional.empty();
        }
    }

    @Transactional(readOnly = true)
    public Optional<TrunkRateDetails> getRateDetailsForTrunk(Long trunkId, Long telephonyTypeId, Long operatorId) {
        // PHP: if (isset($existe_troncal['operador_destino'][$operador_id][$tipotele_id]))
        // PHP: else { $operador_troncal = 0; ... if (isset($existe_troncal['operador_destino'][0][$tipotele_id])) }
        // This means it first tries the specific operator, then operator 0 (all).
        String queryStr = "SELECT tr.* FROM trunk_rate tr " +
                "WHERE tr.active = true AND tr.trunk_id = :trunkId " +
                "AND tr.telephony_type_id = :telephonyTypeId " +
                "AND (tr.operator_id = :operatorId OR tr.operator_id = 0 OR tr.operator_id IS NULL) " + // Check specific operator or generic (0/NULL)
                "ORDER BY CASE WHEN tr.operator_id = :operatorId THEN 0 ELSE 1 END, tr.operator_id DESC NULLS LAST LIMIT 1"; // Prefer specific operator rate

        jakarta.persistence.Query nativeQuery = entityManager.createNativeQuery(queryStr, TrunkRate.class);
        nativeQuery.setParameter("trunkId", trunkId);
        nativeQuery.setParameter("telephonyTypeId", telephonyTypeId);
        nativeQuery.setParameter("operatorId", operatorId != null ? operatorId : 0L); // Use 0 if operatorId is null

        try {
            TrunkRate tr = (TrunkRate) nativeQuery.getSingleResult();
            TrunkRateDetails rd = new TrunkRateDetails();
            rd.operatorId = tr.getOperatorId();
            rd.telephonyTypeId = tr.getTelephonyTypeId();
            rd.rateValue = tr.getRateValue();
            rd.includesVat = tr.getIncludesVat();
            rd.seconds = tr.getSeconds();
            rd.noPbxPrefix = tr.getNoPbxPrefix();
            rd.noPrefix = tr.getNoPrefix();
            return Optional.of(rd);
        } catch (NoResultException e) {
            return Optional.empty();
        }
    }
}

============================================================
FILE: TrunkRateDetails.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/TrunkRateDetails.java
SIZE: 0.61 KB
MODIFIED: 2025-06-04 13:40:58
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@AllArgsConstructor
@NoArgsConstructor
@Data
public class TrunkRateDetails {
    public Long operatorId; // Operator for this specific rate
    public Long telephonyTypeId;
    public BigDecimal rateValue;
    public Boolean includesVat;
    public Integer seconds; // TARIFATRONCAL_SEGUNDOS
    public Boolean noPbxPrefix; // TARIFATRONCAL_NOPREFIJOPBX
    public Boolean noPrefix;    // TARIFATRONCAL_NOPREFIJO
}

============================================================
FILE: TrunkRuleLookupService.java
PATH: E:/Github/abacox/abacox-telephony-pricing/src/main/java/com/infomedia/abacox/telephonypricing/component/cdrprocessing/TrunkRuleLookupService.java
SIZE: 5.19 KB
MODIFIED: 2025-11-21 13:34:57
============================================================
package com.infomedia.abacox.telephonypricing.component.cdrprocessing;

import jakarta.persistence.EntityManager;
import jakarta.persistence.NoResultException;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.Tuple;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.Optional;

@Service
@Log4j2
public class TrunkRuleLookupService {

    @PersistenceContext
    private EntityManager entityManager;


    @Transactional(readOnly = true)
    public Optional<AppliedTrunkRuleInfo> getAppliedTrunkRule(String trunkName, Long currentTelephonyTypeId,
                                                              Long destinationIndicatorId, Long originIndicatorId) {
        // PHP's Calcular_Valor_Reglas
        String queryStr = "SELECT tr.rate_value, tr.includes_vat, tr.seconds, " +
                "tr.new_telephony_type_id, ntt.name as new_tt_name, " +
                "tr.new_operator_id, nop.name as new_op_name, " +
                "COALESCE(p_new.vat_value, 0) as new_vat_rate, " + // VAT for the new type/op
                "t.id as trunk_id_matched " +
                "FROM trunk_rule tr " +
                "LEFT JOIN trunk t ON tr.trunk_id = t.id AND t.active = true AND t.name = :trunkName " +
                "LEFT JOIN telephony_type ntt ON tr.new_telephony_type_id = ntt.id AND ntt.active = true " +
                "LEFT JOIN operator nop ON tr.new_operator_id = nop.id AND nop.active = true " +
                // Prefix for getting VAT of the *new* type/operator
                "LEFT JOIN prefix p_new ON tr.new_telephony_type_id = p_new.telephony_type_id AND tr.new_operator_id = p_new.operator_id AND p_new.active = true " +
                "WHERE tr.active = true " +
                "AND (tr.trunk_id = 0 OR tr.trunk_id IS NULL OR t.id IS NOT NULL) " +
                "AND tr.telephony_type_id = :currentTelephonyTypeId " +
                "AND (tr.origin_indicator_id = 0 OR tr.origin_indicator_id IS NULL OR tr.origin_indicator_id = :originIndicatorId) " +
                "AND (tr.indicator_ids = '' OR :destinationIndicatorIdStr LIKE ('%,' || tr.indicator_ids || ',%') OR tr.indicator_ids = :destinationIndicatorIdStr) " +
                // PHP: OR REGLATRONCAL_INDICATIVO_ID like '$indica_bd,%' OR REGLATRONCAL_INDICATIVO_ID like '%,$indica_bd' OR REGLATRONCAL_INDICATIVO_ID like '%,$indica_bd,%'
                // This is simplified. A more robust way for comma-separated IDs is needed if not using a proper join table.
                // For native query, string manipulation or array overlap might be needed depending on DB.
                // PostgreSQL: AND (:destinationIndicatorId = ANY(string_to_array(tr.indicator_ids, ',')::bigint[]))
                // For simplicity, we'll use LIKE for now, assuming indicator_ids is a single ID or empty.
                "ORDER BY tr.trunk_id DESC NULLS LAST, tr.indicator_ids DESC NULLS LAST, tr.origin_indicator_id DESC NULLS LAST LIMIT 1"; // Prefer more specific rules

        jakarta.persistence.Query nativeQuery = entityManager.createNativeQuery(queryStr, Tuple.class);
        nativeQuery.setParameter("trunkName", trunkName.toUpperCase());
        nativeQuery.setParameter("currentTelephonyTypeId", currentTelephonyTypeId);
        nativeQuery.setParameter("originIndicatorId", originIndicatorId);
        nativeQuery.setParameter("destinationIndicatorIdStr", destinationIndicatorId != null ? String.valueOf(destinationIndicatorId) : "");
        // For comma separated list in indicator_ids, the LIKE needs to be adjusted or use DB specific array functions.
        // Example for PostgreSQL if indicator_ids was an array:
        // AND (:destinationIndicatorId = ANY(string_to_array(tr.indicator_ids, ',')::bigint[]))
        // For now, the LIKE '%,' || :destId || ',%' is a common workaround for comma-separated strings.
        // The query above uses a simplified LIKE for single ID match or full list match.

        try {
            Tuple row = (Tuple) nativeQuery.getSingleResult();
            AppliedTrunkRuleInfo ruleInfo = new AppliedTrunkRuleInfo();
            ruleInfo.rateValue = row.get("rate_value", BigDecimal.class);
            ruleInfo.includesVat = row.get("includes_vat", Boolean.class);
            ruleInfo.seconds = row.get("seconds", Integer.class);
            ruleInfo.newTelephonyTypeId = row.get("new_telephony_type_id", Number.class) != null ? row.get("new_telephony_type_id", Number.class).longValue() : null;
            ruleInfo.newTelephonyTypeName = row.get("new_tt_name", String.class);
            ruleInfo.newOperatorId = row.get("new_operator_id", Number.class) != null ? row.get("new_operator_id", Number.class).longValue() : null;
            ruleInfo.newOperatorName = row.get("new_op_name", String.class);
            ruleInfo.vatRate = row.get("new_vat_rate", BigDecimal.class);

            log.debug("Applied trunk rule for trunk {}, current type {}", trunkName, currentTelephonyTypeId);
            return Optional.of(ruleInfo);
        } catch (NoResultException e) {
            return Optional.empty();
        }
    }
}
